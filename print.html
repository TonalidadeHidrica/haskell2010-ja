<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Haskell2010 Language Report 日本語訳</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="src/customize.css">
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="toc.html">目次</a></li><li class="affix"><a href="preface.html">前書き</a></li><li><a href="chapters/1-introduction.html"><strong aria-hidden="true">1.</strong> 序説</a></li><li><a href="chapters/2-lexical-structure.html"><strong aria-hidden="true">2.</strong> 字句構造</a></li><li><a href="chapters/3-expressions.html"><strong aria-hidden="true">3.</strong> 式</a></li><li><a href="chapters/4-declarations-and-bindings.html"><strong aria-hidden="true">4.</strong> 宣言と束縛</a></li><li><a href="chapters/5-modules.html"><strong aria-hidden="true">5.</strong> モジュール</a></li><li><a href="chapters/6-predefined-types-and-classes.html"><strong aria-hidden="true">6.</strong> 事前定義された型とクラス</a></li><li><a href="chapters/7-basic-input-output.html"><strong aria-hidden="true">7.</strong> 入出力の基本</a></li><li><a href="chapters/8-foreign-function-interface.html"><strong aria-hidden="true">8.</strong> Foreign Function Interface</a></li><li><a href="chapters/9-standard-prelude.html"><strong aria-hidden="true">9.</strong> 標準 Prelude</a></li><li><a href="chapters/10-syntax-reference.html"><strong aria-hidden="true">10.</strong> 文法リファレンス</a></li><li><a href="chapters/11-specification-of-derived-instances.html"><strong aria-hidden="true">11.</strong> インスタンス導出の仕様</a></li><li><a href="chapters/12-compiler-pragmas.html"><strong aria-hidden="true">12.</strong> コンパイラプラグマ</a></li><li><a href="chapters/13-control-monad.html"><strong aria-hidden="true">13.</strong> Control.Monad</a></li><li><a href="chapters/14-data-array.html"><strong aria-hidden="true">14.</strong> Data.Array</a></li><li><a href="chapters/15-data-bits.html"><strong aria-hidden="true">15.</strong> Data.Bits</a></li><li><a href="chapters/16-data-char.html"><strong aria-hidden="true">16.</strong> Data.Char</a></li><li><a href="chapters/17-data-complex.html"><strong aria-hidden="true">17.</strong> Data.Complex</a></li><li><a href="chapters/18-data-int.html"><strong aria-hidden="true">18.</strong> Data.Int</a></li><li><a href="chapters/19-data-ix.html"><strong aria-hidden="true">19.</strong> Data.Ix</a></li><li><a href="chapters/20-data-list.html"><strong aria-hidden="true">20.</strong> Data.List</a></li><li><a href="chapters/21-data-maybe.html"><strong aria-hidden="true">21.</strong> Data.Maybe</a></li><li><a href="chapters/22-data-ratio.html"><strong aria-hidden="true">22.</strong> Data.Ratio</a></li><li><a href="chapters/23-data-word.html"><strong aria-hidden="true">23.</strong> Data.Word</a></li><li><a href="chapters/24-foreign.html"><strong aria-hidden="true">24.</strong> Foreign</a></li><li><a href="chapters/25-foreign-c.html"><strong aria-hidden="true">25.</strong> Foreign.C</a></li><li><a href="chapters/26-foreign-c-error.html"><strong aria-hidden="true">26.</strong> Foreign.C.Error</a></li><li><a href="chapters/27-foreign-c-string.html"><strong aria-hidden="true">27.</strong> Foreign.C.String</a></li><li><a href="chapters/28-foreign-c-types.html"><strong aria-hidden="true">28.</strong> Foreign.C.Types</a></li><li><a href="chapters/29-foreign-foregin-ptr.html"><strong aria-hidden="true">29.</strong> Foreign.ForeignPtr</a></li><li><a href="chapters/30-foreign-marshal.html"><strong aria-hidden="true">30.</strong> Foreign.Marshal</a></li><li><a href="chapters/31-foreign-marshal-alloc.html"><strong aria-hidden="true">31.</strong> Foreign.Marshal.Alloc</a></li><li><a href="chapters/32-foreign-marshal-array.html"><strong aria-hidden="true">32.</strong> Foreign.Marshal.Array</a></li><li><a href="chapters/33-foreign-marshal-error.html"><strong aria-hidden="true">33.</strong> Foreign.Marshal.Error</a></li><li><a href="chapters/34-foreign-marshal-utils.html"><strong aria-hidden="true">34.</strong> Foreign.Marshal.Utils</a></li><li><a href="chapters/35-foreign-ptr.html"><strong aria-hidden="true">35.</strong> Foreign.Ptr</a></li><li><a href="chapters/36-foreign-stable-ptr.html"><strong aria-hidden="true">36.</strong> Foregin.StablePtr</a></li><li><a href="chapters/37-foreign-storable.html"><strong aria-hidden="true">37.</strong> Foregin.Storable</a></li><li><a href="chapters/38-numeric.html"><strong aria-hidden="true">38.</strong> Numeric</a></li><li><a href="chapters/39-system-environment.html"><strong aria-hidden="true">39.</strong> System.Environment</a></li><li><a href="chapters/40-system-exit.html"><strong aria-hidden="true">40.</strong> Sytem.Exit</a></li><li><a href="chapters/41-system-io.html"><strong aria-hidden="true">41.</strong> System.IO</a></li><li><a href="chapters/42-system-io-error.html"><strong aria-hidden="true">42.</strong> System.IO.Error</a></li><li class="affix"><a href="bibliography.html">参考文献</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Haskell2010 Language Report 日本語訳</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#haskell2010-language-report-日本語訳" id="haskell2010-language-report-日本語訳"><h1>Haskell2010 Language Report 日本語訳</h1></a>
<p>翻訳元: <a href="https://www.haskell.org/onlinereport/haskell2010/">Haskell2010 Language Report</a></p>
<p>Simon Marlow (editor)</p>
<p>著作権表示
著者と発行者はこのレポートを Haskell コミュニティ全体へ帰属させることを意図しており、この表示を含め文章全体が再現される限りにおいてはコピーと配布をいかなる目的でも許可している。このレポートの改変も、改変がそうと明示されており、Haskell2010 言語の定義であることを主張しなければ、いかなる目的でもコピーや再配布することができる。</p>
<blockquote>
<p>Copyright notice.
The authors and publisher intend this Report to belong to the entire Haskell community, and grant permission to copy and distribute it for any purpose, provided that it is reproduced in its entirety, including this Notice. Modified versions of this Report may also be copied and distributed for any purpose, provided that the modified version is clearly presented as such, and that it does not claim to be a definition of the language Haskell 2010.</p>
</blockquote>
<ul>
<li>目次</li>
<li>前書き
<ul>
<li>目標</li>
<li>Haskell2010: 言語とライブラリ</li>
<li>Haskell98 からの拡張</li>
<li>リソース</li>
<li>言語の作成</li>
</ul>
</li>
</ul>
<a class="header" href="#i-haskell-2010-言語" id="i-haskell-2010-言語"><h3>I. Haskell 2010 言語</h3></a>
<ol>
<li><a href="./chapters/1-introduction.html">序説</a>
<ul>
<li>プログラムの構造</li>
<li>Haskell のコア</li>
<li>値と型</li>
<li>名前空間</li>
</ul>
</li>
<li><a href="./chapters/2-lexical-structure.html">字句構造</a>
<ul>
<li>慣習的表記</li>
<li>字句の構造</li>
<li>コメント</li>
<li>識別子と演算子</li>
<li>数値リテラル</li>
<li>文字と文字列リテラル</li>
<li>レイアウト</li>
</ul>
</li>
<li><a href="./chapters/3-expressions.html">式</a>
<ul>
<li>エラー</li>
<li>変数、コンストラクタ、演算子、リテラル</li>
<li>カリー化された適用とラムダ抽象</li>
<li>演算子の適用</li>
<li>セクション</li>
<li>条件</li>
<li>リスト</li>
<li>タプル</li>
<li>ユニット式と括弧つき式</li>
<li>算術列</li>
<li>リスト内法表記</li>
<li>let 式</li>
<li>case 式</li>
<li>do 式</li>
<li>フィールドラベルのついたデータ型</li>
<li>型シグネチャ</li>
<li>パターンマッチ</li>
</ul>
</li>
<li><a href="./chapters/4-declarations-and-bindings.html">宣言と束縛</a>
<ul>
<li>型とクラスの概観</li>
<li>ユーザー定義データ型</li>
<li>型クラスとオーバーロード</li>
<li>ネストされた宣言</li>
<li>関数とパターン束縛の静的な意味論</li>
<li>カインド推論</li>
</ul>
</li>
<li><a href="./chapters/5-modules.html">モジュール</a>
<ul>
<li>モジュール構造</li>
<li>export リスト</li>
<li>import 宣言</li>
<li>インスタンス宣言の import と export</li>
<li>名前衝突とクロージャー</li>
<li>標準 Prelude</li>
<li>分割コンパイル</li>
<li>抽象データ型</li>
</ul>
</li>
<li>事前定義された型とクラス
<ul>
<li>標準的な Haskell の型</li>
<li>正格評価</li>
<li>標準的な Haskell のクラス</li>
<li>数値</li>
</ul>
</li>
<li>入出力の基本
<ul>
<li>標準的な I/O 関数</li>
<li>I/O 操作列</li>
<li>I/O モナドにおける例外処理</li>
</ul>
</li>
<li>Foreign Function Interface
<ul>
<li>外部言語</li>
<li>コンテキスト</li>
<li>字句構造</li>
<li>外部宣言</li>
<li>外部エンティティの規格</li>
<li>マーシャリング</li>
<li>外部 C インターフェイス</li>
</ul>
</li>
<li>標準 Prelude
<ul>
<li>Prelude <code>PreludeList</code></li>
<li>Prelude <code>PreludeText</code></li>
<li>Prelude <code>PreludeIO</code></li>
</ul>
</li>
<li><a href="./chapters/10-syntax-reference.html">文法リファレンス</a>
<ul>
<li>慣習的表記</li>
<li>字句文法</li>
<li>レイアウト</li>
<li>文芸的コメント</li>
<li>文脈自由文法</li>
<li>結合の解決</li>
</ul>
</li>
<li><a href="./chapters/11-specification-of-derived-instances.html">インスタンス導出の仕様</a>
<ul>
<li><code>Eq</code>と<code>Ord</code>のインスタンス導出</li>
<li><code>Enum</code>のインスタンス導出</li>
<li><code>Bounded</code>のインスタンス導出</li>
<li><code>Read</code>と<code>Show</code>のインスタンス導出</li>
<li>例</li>
</ul>
</li>
<li><a href="./chapters/12-compiler-pragmas.html">コンパイラプラグマ</a>
<ul>
<li>インライン化</li>
<li>限定化</li>
<li>言語拡張</li>
</ul>
</li>
</ol>
<a class="header" href="#haskell-2010-ライブラリ" id="haskell-2010-ライブラリ"><h3>Haskell 2010 ライブラリ</h3></a>
<ol start="13">
<li><a href="./chapters/13-control-monad.html">Control.Monad</a>
<ul>
<li>ファンクターとモナドクラス</li>
<li>関数</li>
</ul>
</li>
<li><code>Data.Array</code>
<ul>
<li>不変非正格配列</li>
<li>配列の構成</li>
<li>配列へのアクセス</li>
<li>配列の逐次更新</li>
<li>導出された配列</li>
<li>規格</li>
</ul>
</li>
<li><code>Data.Bits</code></li>
<li><code>Data.Char</code>
<ul>
<li>文字と文字列</li>
<li>文字の分類</li>
<li>複合語の慣習</li>
<li>単一の数値文字</li>
<li>数値の表現</li>
<li>文字列の表現</li>
</ul>
</li>
<li><code>Data.Complex</code>
<ul>
<li>直行形式</li>
<li>極形式</li>
<li>共役</li>
<li>規格</li>
</ul>
</li>
<li><code>Data.Int</code>
<ul>
<li>符号付き整数型</li>
</ul>
</li>
<li><code>Data.Ix</code>
<ul>
<li><code>Ix</code>クラス</li>
<li><code>Ix</code>インスタンスの導出</li>
</ul>
</li>
<li><code>Data.List</code>
<ul>
<li>基本的な関数</li>
<li>リスト変換</li>
<li>リストの縮小(畳み込み)</li>
<li>リストの作成</li>
<li>部分リスト</li>
<li>リストの検索</li>
<li>リストの添え字アクセス</li>
<li>リストの zip/unzip</li>
<li>特別なリスト</li>
<li>一般化された関数</li>
</ul>
</li>
<li><code>Data.Maybe</code>
<ul>
<li><code>Maybe</code>型と操作</li>
<li>規格</li>
</ul>
</li>
<li><code>Data.Ratio</code>
<ul>
<li>規格</li>
</ul>
</li>
<li><code>Data.Word</code>
<ul>
<li>符号なし整数型</li>
</ul>
</li>
<li><code>Foreign</code></li>
<li><code>Foreign.C</code></li>
<li><code>Foreign.C.Error</code>
<ul>
<li><code>errno</code>値の Haskell における表現</li>
</ul>
</li>
<li><code>Foreign.C.String</code>
<ul>
<li>C の文字列</li>
<li>C のワイド文字列</li>
</ul>
</li>
<li><code>Foreign.C.Types</code>
<ul>
<li>C の型の表現</li>
</ul>
</li>
<li><code>Foreign.ForeignPtr</code>
<ul>
<li>ファイナライズされたデータポインター</li>
</ul>
</li>
<li><code>Foreign.Marshal</code></li>
<li><code>Foreign.Marshal.Alloc</code>
<ul>
<li>メモリ確保</li>
</ul>
</li>
<li><code>Foregin.Marshal.Array</code>
<ul>
<li>配列のマーシャリング</li>
</ul>
</li>
<li><code>Foreign.Marshal.Error</code></li>
<li><code>Foreign.Marshal.Utils</code>
<ul>
<li>一般的なマーシャリングのユーティリティ</li>
</ul>
</li>
<li><code>Foregin.Ptr</code>
<ul>
<li>データポインタ</li>
<li>関数ポインタ</li>
<li>整数型とポインタのロスのない相互変換</li>
</ul>
</li>
<li><code>Foregin.StablePtr</code>
<ul>
<li>Haskell の値への安定参照</li>
</ul>
</li>
<li><code>Foregin.Storable</code></li>
<li><code>Numeric</code>
<ul>
<li>表示</li>
<li>読み取り</li>
<li>その他</li>
</ul>
</li>
<li><code>System.Environment</code></li>
<li><code>Sytem.Exit</code></li>
<li><code>System.IO</code>
<ul>
<li>IO モナド</li>
<li>ファイルとハンドル</li>
<li>ファイルのオープンとクローズ</li>
<li>ハンドルに対する捜査</li>
<li>テキストの入力と出力</li>
</ul>
</li>
<li><code>System.IO.Error</code>
<ul>
<li>I/O エラー</li>
<li>I/O エラーの型</li>
<li>I/O エラーの送出と捕捉</li>
</ul>
</li>
</ol>
<p>参考文献</p>
<a class="header" href="#前書き" id="前書き"><h1>前書き</h1></a>
<blockquote>
<p>『幾多の人々がコンビネーター論理に関する技術的な文書を残しており、さらにその多くは、われわれのものも含めて誤った状態で出版されている。我々の罪を犯した仲間たちはその時代で最も注意深くて有能な論理学者に属する人々であり、我々はこのことがこの分野が手に負えないことの証拠であると考えている。よって十分な解説は正確さのために必要であるし、極端な要約は(通常よりも遥かに)節約にならないであろう。』</p>
<p>ハスケル・B・カリー, ロベール・フェイ<br />
コンビネーター論理[3]の前書きにて 1956年5月31日</p>
</blockquote>
<p>1987年の7月、オレゴン州のポートランドでの関数型言語とコンピューターの設計(FPCA '87)学会にて会議が開かれ、関数型言語コミュニティが置かれている不幸な状況について話し合われた。すなわち、それまで10を超える非正格な純粋関数型言語が実装されており、それらの表現力とベースとなる意味論がどれも似かよっていたことである。その会議で強く意見が一致したこととして、共通となる言語が欠けていることはこの種の関数型言語がより広く使われるようになることの妨げとなっているということであった。新しいアイデアの素早いやりとりの場、現実のアプリケーション開発のための安定した基盤、そして人々が関数型言語を利用することを推奨する売り込みの手段を提供する、共通言語を設計するための委員会が結成されることが決定された。。この文書はその委員会(とそれに続く)の努力の結果である、Haskellと呼ばれる純粋関数型言語を説明したものである。これは我々の多くの部分の論理学的な基礎を提供する仕事を成した論理学者ハスケル・B・カリーにちなんでつけられた。</p>
<a class="header" href="#目的" id="目的"><h2>目的</h2></a>
<p>委員会の主たる目的は次の条件を満たすような言語をデザインすることであった。</p>
<ol>
<li>教育、研究、そして大規模なシステムを作ることも含めたアプリケーションに適したものであること。</li>
<li>公表された形式的な文法および意味論により完全に説明されるものであること。</li>
<li>自由に利用可能なものであること。誰でも言語を実装し、それを配りたい人に配ることが許可されていること。</li>
<li>広く認められたアイデアに基づいているものであること。</li>
<li>関数型プログラミング言語の不要な多様性を減らすこと。</li>
</ol>
<a class="header" href="#haskell-2010-言語とライブラリ" id="haskell-2010-言語とライブラリ"><h2>Haskell 2010: 言語とライブラリ</h2></a>
<p>委員会はHaskellが言語デザインにおいて将来の研究の礎の役割を果たすことを目的とし、実験的な機能を盛り込んだその拡張や変種たる言語が登場することを望んでいた。</p>
<p>Haskellは実際には最初の発表から進化を続けてきている。1997年の中頃までには、言語デザインに5つのバージョンが存在していた(Haskell 1.0から1.4)。1997年にアムステルダムで開かれたHaskellのワークショップにおいて、Haskellの安定した変種が必要であることが決定され、これが&quot;Haskell 98&quot;となり、1999年の2月に発表された。小さなバグを修正したものが2002年に <strong>改訂版</strong> Haskell 98レポートとされた。</p>
<p>2005年のHaskellワークショップにおいて、公式の言語に対する多くの拡張が広く使われているということ(そしてそれらは複数の実装でサポートされていること)と、言語標準を定期的に定義することは意味のあることであることが合意された。それには現在の状態の明文化(とルール化)が必須であった。</p>
<p>このためHaskell Primeの取り組みがHaskell 98の相対的に保守的な拡張であると理解された、新しい機能は皆によく理解され広く合意されたものにしか立脚しないのである。それは&quot;安定した&quot;言語であることも意図されていたが、近年の言語デザインの研究でのかなりの進歩も反映したものであった。</p>
<p>色々な言語デザインを調査し数年の後には、唯一の一枚岩な言語の版でやるには仕事が大きすぎること、進捗を生む最良の方法は言語を小さくゆっくりと段階を踏んだ言語の進化であるので、各版はよく理解された拡張と変更のほんの一部だけを統一したものにすることが決定された。Haskell 2010はこのようにして作られた最初の版であり、新しい版は毎年1つずつ出される見込みである。</p>
<a class="header" href="#haskell-98への拡張" id="haskell-98への拡張"><h2>Haskell 98への拡張</h2></a>
<p>Haskell 98と比較してHaskell 2010に入った最も重要な言語の変更点をここに並べる。</p>
<p>新しい言語機能:</p>
<ul>
<li>外部関数インターフェイス(FFI)</li>
<li>階層的モジュール名(例: <code>Data.Bool</code>)</li>
<li>パターンガード</li>
</ul>
<p>削除された言語機能:</p>
<ul>
<li><code>(n + k)</code>パターン文法</li>
</ul>
<a class="header" href="#haskellのリソース" id="haskellのリソース"><h2>Haskellのリソース</h2></a>
<p>Haskellのウェブサイト https://www.haskell.org はたくさんの有益なリソースへのアクセスを可能にしている。次はその一部である:</p>
<ul>
<li>オンライン版の言語とライブラリの定義</li>
<li>Haskellのチュートリアルの資料</li>
<li>Haskellメーリングリストの詳細</li>
<li>Haskellの実装</li>
<li>Haskellに貢献したツールやライブラリ</li>
<li>Haskellのアプリケーション</li>
<li>ユーザーが貢献するwikiの記事</li>
<li>Haskellコミュニティにおけるニュースとイベント</li>
</ul>
<p>是非あなたもHaskellのメーリングリストやHaskell wikiにて、コメントし、改善を提案し、言語やレポートの現状について批評をしてみてください。</p>
<a class="header" href="#言語の構築" id="言語の構築"><h2>言語の構築</h2></a>
<p>Haskellは研究者やアプリケーションプログラマーたちの活発なコミュニティによって作られ、維持されてきた。言語とライブラリ委員会の一員を務める人々が、特に多量の時間とエネルギーをこの言語に捧げてきた。彼らの名前と、その期間での所属をここに記す。</p>
<p>(<strong>訳注</strong> ここでは名前と所属について翻訳をせず原文のまま表示します)</p>
<div style="text-align: center;">
Arvind (MIT)
<br />
Lennart Augustsson (Chalmers University)
<br />
Dave Barton (Mitre Corp)
<br />
Brian Boutel (Victoria University of Wellington)
<br />
Warren Burton (Simon Fraser University)
<br />
Manuel M T Chakravarty (University of New South Wales)
<br />
Duncan Coutts (Well-Typed LLP)
<br />
Jon Fairbairn (University of Cambridge)
<br />
Joseph Fasel (Los Alamos National Laboratory)
<br />
John Goerzen
<br />
Andy Gordon (University of Cambridge)
<br />
Maria Guzman (Yale University)
<br />
Kevin Hammond [編集者] (University of Glasgow)
<br />
Bastiaan Heeren (Utrecht University)
<br />
Ralf Hinze (University of Bonn)
<br />
Paul Hudak [編集者] (Yale University)
<br />
John Hughes [編集者] (University of Glasgow; Chalmers University)
<br />
Thomas Johnsson (Chalmers University)
<br />
Isaac Jones (Galois, inc.)
<br />
Mark Jones (Yale University, University of Nottingham, Oregon Graduate Institute)
<br />
Dick Kieburtz (Oregon Graduate Institute)
<br />
John Launchbury (University of Glasgow; Oregon Graduate Institute; Galois, inc.)
<br />
Andres Löh (Utrecht University)
<br />
Ian Lynagh (Well-Typed LLP)
<br />
Simon Marlow [編集者] (Microsoft Research)
<br />
John Meacham
<br />
Erik Meijer (Utrecht University)
<br />
Ravi Nanavati (Bluespec, inc.)
<br />
Rishiyur Nikhil (MIT)
<br />
Henrik Nilsson (University of Nottingham)
<br />
Ross Paterson (City University, London)
<br />
John Peterson [編集者] (Yale University)
<br />
Simon Peyton Jones [編集者] (University of Glasgow; Microsoft Research Ltd)
<br />
Mike Reeve (Imperial College)
<br />
Alastair Reid (University of Glasgow)
<br />
Colin Runciman (University of York)
<br />
Don Stewart (Galois, inc.)
<br />
Martin Sulzmann (Informatik Consulting Systems AG)
<br />
Audrey Tang
<br />
Simon Thompson (University of Kent)
<br />
Philip Wadler [編集者] (University of Glasgow)
<br />
Malcolm Wallace (University of York)
<br />
Stephanie Weirich (University of Pennsylvania)
<br />
David Wise (Indiana University)
<br />
Jonathan Young (Yale University)
</div>
<p>[編集者]と記された人々はこの言語の1つ以上の版での編集に協力してくれている。</p>
<p>加えて、他にも多くの人々が多かれ少なかれ有益な貢献をしてくれている。以下の人々である。
Hans Aberg, Kris Aerts, Sten Anderson, Richard Bird, Tom Blenko, Stephen Blott, Duke Briscoe, Paul Callaghan, Magnus Carlsson, Mark Carroll, Franklin Chen, Olaf Chitil, Chris Clack, Guy Cousineau, Tony Davie, Craig Dickson, Chris Dornan, Laura Dutton, Chris Fasel, Pat Fasel, Sigbjorn Finne, Michael Fryers, Peter Gammie, Andy Gill, Mike Gunter, Cordy Hall, Mark Hall, Thomas Hallgren, Matt Harden, Klemens Hemm, Fergus Henderson, Dean Herington, Bob Hiromoto, Nic Holt, Ian Holyer, Randy Hudson, Alexander Jacobson, Patrik Jansson, Robert Jeschofnik, Orjan Johansen, Simon B. Jones, Stef Joosten, Mike Joy, Wolfram Kahl, Stefan Kahrs, Antti-Juhani Kaijanaho, Jerzy Karczmarczuk, Kent Karlsson, Martin D. Kealey, Richard Kelsey, Siau-Cheng Khoo, Amir Kishon, Feliks Kluzniak, Jan Kort, Marcin Kowalczyk, Jose Labra, Jeff Lewis, Mark Lillibridge, Bjorn Lisper, Sandra Loosemore, Pablo Lopez, Olaf Lubeck, Christian Maeder, Ketil Malde, Michael Marte, Jim Mattson, John Meacham, Sergey Mechveliani, Gary Memovich, Randy Michelsen, Rick Mohr, Andy Moran, Graeme Moss, Arthur Norman, Nick North, Chris Okasaki, Bjarte M. Østvold, Paul Otto, Sven Panne, Dave Parrott, Larne Pekowsky, Rinus Plasmeijer, Ian Poole, Stephen Price, John Robson, Andreas Rossberg, George Russell, Patrick Sansom, Michael Schneider, Felix Schroeter, Julian Seward, Nimish Shah, Christian Sievers, Libor Skarvada, Jan Skibinski, Lauren Smith, Raman Sundaresh, Josef Svenningsson, Ken Takusagawa, Wolfgang Thaller, Satish Thatte, Tom Thomson, Tommy Thorn, Dylan Thurston, Mike Thyer, Mark Tullsen, David Tweed, Pradeep Varma, Keith Wansbrough, Tony Warnock, Michael Webber, Carl Witty, Stuart Wray, and Bonnie Yantis.</p>
<p>最後に、チャーチ、ロッサー、カリーによる重要で基礎的な仕事とほかの人々のラムダ計算に関する仕事はもちろんのこととして、長年にわたって開発されてきた注目に値する多くのプログラミング言語の影響を認めるのが正しい。様々なアイデアの源をピンポイントに挙げるのは難しいが、次の言語は特に影響を与えている: Lisp (とその現在での姿であるCommon LispとScheme)、ランディンのISWIM、APL、バッカスのFP[1]、MLとStandard ML、Hopeと Hope+、Clean、Id、Gofer、Sisal、そしてターナーのMiranda(Mirandaは有限会社リサーチソフトウェアのトレードマークである)が最後を飾った一連の言語。これらの先駆者たちなしにはHaskellは不可能であっただろう。</p>
<p>サイモン・マーロー<br />
2010年4月 ケンブリッジ大学にて</p>
<a class="header" href="#序説" id="序説"><h1>序説</h1></a>
<p>Haskellは汎用の純粋関数型言語であり、近年のプログラミング言語のデザインにおける多くの革新を取り入れている。Haskellは高階関数、非正格意味論、静的多相型付け、ユーザー定義代数的データ型、パターンマッチ、リスト内法表記、モジュールシステム、モナドを用いたI/Oシステム、リスト、配列、任意精度と固定精度整数、浮動小数点数などを含む豊富な基本データ型を備えている。Haskellは非正格関数型言語に対する長年の研究の極致であり結実である。</p>
<p>このレポートはHaskellプログラムの文法と、それらプログラムの意味づけを行うための形式的でない抽象意味論を定義するものである。Haskellプログラムがどのように操作され、実行され、コンパイルされるかなどについては実行依存のこととしておく。このことは、プログラミング環境の特質や、未定義のプログラムに対して返却されるエラーメッセージ(すなわち、形式的には⊥に評価されるプログラム)などに関する事項を含んでいる。</p>
<a class="header" href="#プログラムの構造" id="プログラムの構造"><h2>プログラムの構造</h2></a>
<p>このセクションでは、Haskellの大まかな文法と意味論の構造及びそれらがレポートの残りの章の構造とどのように関係しているかについて説明する。</p>
<ol>
<li>Haskellプログラムの一番トップレベルは5章で説明される <strong>モジュール</strong> の集合である。モジュールは名前空間の管理と大規模なプログラムにおいてソフトウェアが再利用できる手段を提供するものである。</li>
<li>モジュールのトップレベルは <strong>宣言</strong> の集まりであり、これらは複数の種類のものからなる。すべて4章で説明される。宣言は通常の値、データ型、型クラス、結合性情報などのものを定義するものである。</li>
<li>次に来るレベルは <strong>式</strong> であり、3章で説明される。式は <strong>値</strong> を表現し、 <strong>静的型</strong> を持つ。式は&quot;小規模な&quot;Haskellプログラミングにおいて中心的な役割を果たすものである。</li>
<li>一番下のレベルにくるものはHaskellの <strong>文法構造</strong> であり、2章で説明される。文法構造はテキストファイルに書かれたHaskellプログラムの具体的な表現を捉えるものである。</li>
</ol>
<p>このレポートはHaskellの文法的な構造を下から上に向かって進めていく。</p>
<p>上で触れられていない章は、Haskellの標準的な組み込みデータ型と組み込みクラスについて説明している6章と、HaskellにおけるI/O機能(すなわち、Haskellが外の世界とどのようにやりとりするか)について述べる7章である。また、Prelude、具体的な文法、文芸的プログラミング、インスタンス導出の仕様、多くのHaskellコンパイラによってサポートされるプラグマについても章を割いている。</p>
<p>本文ではHaskellプログラム断片の例をタイプライターフォント(訳注: このドキュメントではタイプライターフォントまたはコードブロックとして表示する)で表示する:</p>
<pre><code class="language-haskell">let x = 1
    z = x+y
in  z+1
</code></pre>
<p>任意の部分Haskellコードを表現しているプログラム断片における「穴」はイタリック体で表示され、例えば <tt>if</tt> <em>e1</em> <tt>then</tt> <em>e2</em> <tt>else</tt> <em>e3</em> となる。一般的にはイタリック体になっている部分はニーモニック(訳注: 覚えやすいようにそれらしい名前を付けること)であり、例えば <em>e</em> は式、 <em>d</em> は宣言、 <em>t</em> は型といった具合である。</p>
<a class="header" href="#haskellのカーネル" id="haskellのカーネル"><h2>Haskellのカーネル</h2></a>
<p>Haskellは関数型プログラミングで有名になった多くの便利な文法構造を採用している。このレポートではそういった構文糖衣の意味はより簡単な構成に変換されて与えられる。これら変換が漏れなく適用された場合、結果としてプログラムはHaskellの小さなサブセットによって書かれたことになるが、これを我々はHaskellの <strong>カーネル</strong> と呼ぶ。</p>
<p>カーネルは正確に規定されたものではないが、これは本質的には標準的な表示的意味論をもつラムダ計算を少し構文糖衣によって変えたものである。各文法構造からカーネルへの変換はその文法の導入と同様にして与えることができる。このように(訳注: カーネルがHaskellから切り離されているという)設計はHaskellプログラムに対する推論を容易にし、言語の実装者に対して便利なガイドラインを提供する。</p>
<a class="header" href="#値と型" id="値と型"><h2>値と型</h2></a>
<p>式は <strong>値</strong> に評価され、 <strong>静的型</strong> を持つ。値と型はHaskellでは混合されていない。しかし、型システムは色々な種類のユーザー定義データ型を許容しており、パラメータ多相(伝統的なHindley-Milner型推論を用いている)だけでなく <strong>アドホック多相</strong> あるいは(型クラスを用いた) <strong>オーバーロード</strong> と呼ばれるものも利用可能である。</p>
<p>Haskellでのエラーは意味論的には⊥ (「ボトム」)と同値である。技術的には、これは停止しないことと区別不可能であり、よって言語はエラーを検知したりそれに作用するような機構を持たない。しかし実装者はエラーに対して有用な情報を提供しようとするかもしれない。セクション3.1をみよ。</p>
<a class="header" href="#名前空間" id="名前空間"><h2>名前空間</h2></a>
<p>Haskellには名前が6種類ある: <strong>変数</strong> と <strong>コンストラクタ</strong> の名前は値を表現し、<strong>型変数</strong> と <strong>型コンストラクタ</strong> と <strong>型クラス</strong> の名前は型システムに関連したエンティティを表し、<strong>モジュール名</strong> はモジュールを表す。名前には2つの制約がある:</p>
<ol>
<li>変数と型変数の名前は小文字またはアンダースコアから始まる識別子、他の4種類の名前は大文字から始まる識別子である</li>
<li>識別子は同じスコープ内で、型コンストラクタの名前かつクラスの名前として使われてはならない</li>
</ol>
<p>制約はこれだけである。例えば、<code>Int</code>は1つのスコープで同時にモジュール、クラス、コンストラクタの名前として使われる可能性がある。</p>
<a class="header" href="#字句構造" id="字句構造"><h1>字句構造</h1></a>
<p>この章では、Haskellの低レベルな字句構造を説明する。このレポートを初めて読む場合には、詳細はほとんど読み飛ばしてもよいだろう。</p>
<a class="header" href="#表記法" id="表記法"><h2>表記法</h2></a>
<p>以下の表記法は構文を表すために使用される。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td align="left"> [<em>pattern</em>]                         </td><td align="left"> 任意 </td></tr>
<tr><td align="left"> {<em>pattern</em>}                         </td><td align="left"> 0、またはそれ以上の繰り返し </td></tr>
<tr><td align="left"> (<em>pattern</em>)                         </td><td align="left"> グルーピング </td></tr>
<tr><td align="left"> <em>pat<sub>1</sub></em> | <em>pat<sub>2</sub></em> </td><td align="left"> 選択 </td></tr>
<tr><td align="left"> pat<sub>(pat')</sub> </td><td align="left">  相違 ー <em>pat'</em>によって生成されたものを除いた、<em>pat</em>によって生成された要素</td></tr>
<tr><td align="left"> <code>fibonacci</code> </td><td align="left"> タイプライターフォントの終端構文 </td></tr>
</tbody></table>
<p>このセクション内の構文は字句構造を説明しているため、全ての空白は明示的に表現されているが、並置されたシンボル間には暗黙的な空白はない。BNFのような構文は今後使われ、次の形式を取る。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td> <em>nonterm</em> </td><td> → </td><td> <em>alt<sub>1</sub></em> | <em>alt<sub>2</sub></em> | … | <em>alt<sub>n</sub></em> </td></tr>
</tbody></table>
<p>通常は文脈によって区別が明確になるが、
<code>|</code>や<code>[…]</code>のような(タイプライターフォントで指定された)具体的な終端構文から|や[…]のようなメタデータ構文の区別には注意が必要である。</p>
<p>HaskellはUnicode[<a href="chapters/./bibliogrphy.html">2</a>]文字セットを使っている。しかしながら、プログラムソースは現在、以前のHaskellバージョンで使われていたASCII文字セットに偏っている。</p>
<p>この構文はUnicodeコンソーシアムによって定義されているUnicode文字の文字符号化スキームによって異なる。Haskellコンパイラーは新しいバージョンのUnicodeが利用可能になるにつれてそれらを利用されることが期待されている。</p>
<a class="header" href="#字句プログラム構造" id="字句プログラム構造"><h2>字句プログラム構造</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td> <em>program</em> </td><td>→</td><td> {<em>lexeme</em> | <em>whietespace</em>}</td></tr>
<tr><td> <em>lexeme</em> </td><td>→</td><td> <em>qvarid</em> | <em>qconid</em> | <em>qvarsym</em> | <em>qconsym</em> | <em>literal</em> | <em>special</em> | <em>reservedop</em> | <em>reservedid</em> </td></tr>
<tr><td> <em>literal</em> </td><td>→</td><td> <em>integer</em> | <em>float</em> | <em>char</em> | <em>string</em> </td></tr>
<tr><td> <em>special</em> </td><td>→</td><td> <code>(</code> | <code>)</code> | <code>,</code> | <code>;</code> | <code>[</code> | <code>]</code> | <code>`</code> | <code>{</code> | <code>}</code> </td></tr>
<tr><td> </td><td> </td><td> </td></tr>
<tr><td> <em>whitespace</em> </td><td>→</td><td> <em>whitestuff</em> {<em>whitestuff</em>}</td></tr>
<tr><td> <em>whitestuff</em> </td><td>→</td><td> <em>whitechar</em> | <em>comment</em> | <em>ncomment</em> </td></tr>
<tr><td> <em>whitechar</em> </td><td>→</td><td> <em>newline</em> | <em>vertab</em> | <em>space</em> | <em>tab</em> | <em>uniWhite</em> </td></tr>
<tr><td> <em>newline</em> </td><td>→</td><td> <em>return</em> <em>linefeed</em> | <em>return</em> | <em>linefeed</em> | <em>formfeed</em> </td></tr>
<tr><td> <em>return</em> </td><td>→</td><td> キャレッジ⏎ </td></tr>
<tr><td> <em>linefeed</em> </td><td>→</td><td> 改行 </td></tr>
<tr><td> <em>vertab</em> </td><td>→</td><td> 垂直タブ </td></tr>
<tr><td> <em>formfeed</em> </td><td>→</td><td> 改ページ </td></tr>
<tr><td> <em>space</em> </td><td>→</td><td> 空白 </td></tr>
<tr><td> <em>tab</em> </td><td>→</td><td> 水平タブ </td></tr>
<tr><td> <em>uniWhite</em> </td><td>→</td><td> 空白として定義されたUnicode文字 </td></tr>
<tr><td> </td><td> </td><td> </td></tr>
<tr><td> <em>comment</em> </td><td>→</td><td> <em>dashes</em> [ <em>any</em><sub><em>symbol</em></sub> {<em>any</em>} ] <em>newline</em> </td></tr>
<tr><td><em>dashes</em> </td><td>→</td><td> <code>--</code> {<code>-</code>} </td></tr>
<tr><td><em>opencom</em> </td><td>→</td><td> <code>{-</code> </td></tr>
<tr><td><em>closecom</em> </td><td>→</td><td> <code>-}</code> </td></tr>
<tr><td><em>ncomment</em> </td><td>→</td><td> <em>opencom</em> <em>ANY seq</em> {<em>ncomment</em> <em>ANY seq</em>} <em>closecom</em> </td></tr>
<tr><td><em>ANY seq</em> </td><td>→</td><td> {<em>ANY</em>}<sub>⟨{<em>ANY</em>} ( <em>opencom</em> | <em>closecom</em> ) {<em>ANY</em>}⟩</sub> </td></tr>
<tr><td><em>ANY</em> </td><td>→</td><td> <em>graphic</em> | <em>whitechar</em> </td></tr>
<tr><td><em>any</em> </td><td>→</td><td> <em>graphic</em> | <em>space</em> | <em>tab</em> </td></tr>
<tr><td><em>graphic</em> </td><td>→</td><td> <em>small</em> | <em>large</em> | <em>symbol</em> | <em>digit</em> | <em>special</em> | <code>&quot;</code> | <code>'</code> </td></tr>
<tr><td> </td><td> </td><td> </td></tr>
<tr><td><em>small</em> </td><td>→</td><td> <em>ascSmall</em> | <em>uniSmall</em> | <code>_</code> </td></tr>
<tr><td><em>ascSmall</em> </td><td>→</td><td> <code>a</code> | <code>b</code> | … | <code>z</code> </td></tr>
<tr><td><em>uniSmall</em> </td><td>→</td><td> 小文字Unicode </td></tr>
<tr><td> </td><td> </td><td> </td></tr>
<tr><td><em>large</em> </td><td>→</td><td> <em>ascLarge</em> | <em>uniLarge</em> </td></tr>
<tr><td><em>ascLarge</em> </td><td>→</td><td> <code>A</code> | <code>B</code> | … | <code>Z</code> </td></tr>
<tr><td><em>uniLarge</em> </td><td>→</td><td> 任意の大文字またはタイトルケース(<strong>訳注</strong>: 先頭のみ大文字で後は小文字にするスタイル)のユニコード文字 </td></tr>
<tr><td><em>symbol</em> </td><td>→</td><td> <em>ascSymbol</em> | <em>uniSymbol</em><sub>⟨<em>special</em> | <code>_</code> | <code>&quot;</code> | <code>'</code>⟩</sub> </td></tr>
<tr><td> </td><td> </td><td> </td></tr>
<tr><td><em>ascSymbol</em> </td><td>→</td><td> <code>!</code> | <code>#</code> | <code>$</code> | <code>%</code> | <code>&amp;</code> | <code>⋆</code> | <code>+</code> | <code>.</code> | <code>/</code> | <code>&lt;</code> | <code>=</code> | <code>&gt;</code> | <code>?</code> | <code>@</code> | <code>\</code> | <code>^</code> | <code>|</code> | <code>-</code> | <code>~</code> | <code>:</code></td></tr>
<tr><td><em>uniSymbol</em> </td><td>→</td><td> Unicodeのシンボル、または句読点 </td></tr>
<tr><td><em>digit</em> </td><td>→</td><td> <em>ascDigit</em> | <em>uniDigit</em> </td></tr>
<tr><td><em>ascDigit</em> </td><td>→</td><td> <code>0</code> | <code>1</code> | … | <code>9</code> </td></tr>
<tr><td><em>uniDigit</em> </td><td>→</td><td> 10進数Unicode </td></tr>
<tr><td><em>octit</em> </td><td>→</td><td> <code>0</code> | <code>1</code> | … | <code>7</code> </td></tr>
<tr><td><em>hexit</em> </td><td>→</td><td> <em>digit</em> | <code>A</code> | … | <code>F</code> | <code>a</code> | … | <code>f</code> </td></tr>
</tbody></table>
<p>字句解析は&quot;maximal munch&quot;規則に従うべきである。すなわち、語彙素生成規則を満たす可能な限り長くとった語彙素が読み取られる([訳注]:日本語訳、最長一致。&quot;longest match&quot; ともいう)。したがって、<code>case</code>は予約語だが、<code>cases</code>は予約語ではない。同様に<code>=</code>は予約されているが、<code>==</code>と<code>~=</code>は予約されていない。</p>
<p>空白はどんなものでも正しい字句の区切り文字である。</p>
<p><strong>Any</strong> カテゴリではない文字はHaskellプログラム内では有効ではなく、字句解析エラーを結果にすべきである。</p>
<a class="header" href="#コメント" id="コメント"><h2>コメント</h2></a>
<p>コメントは有効な空白である。</p>
<p>普通のコメントは二つ以上の連続したダッシュ(<code>--</code>など)で始まり、次の改行まで及ぶ。連続したダッシュは正当な語彙素の一部を形成してはいけない。例として、&quot;--&gt;&quot;や&quot;|--&quot;はコメントの開始としては見なさない。なぜならこれらは正当な語彙素だからだ。しかしながら、<code>&quot;--foo&quot;</code>はコメントの開始として見なされる。</p>
<p>ネストされたコメントは<code>&quot;{-&quot;</code>で始まり、<code>&quot;-}&quot;</code>で終わる。<code>&quot;{-&quot;</code>は違法な語彙素ではない。それゆえ、例えば<code>&quot;{---&quot;</code>は末尾に余分なダッシュがあるがネストされたコメントの始まりである。</p>
<p>コメントそれ自体は語彙的に解析されない。代わりに、初めに文字列<code>&quot;-}&quot;</code>が現れた前の部分までがネストされたコメントの範囲である。ネストされたコメントは任意の深さにネストできる。ネストされたコメント内に文字列<code>&quot;{-&quot;</code>があると新しいネストされたコメントが始まり、<code>&quot;-}&quot;</code>によって閉じられる。ネストされたコメント内では、各<code>&quot;{-&quot;</code>は対応する<code>&quot;-}&quot;</code>の出現によって照合される。</p>
<p>普通のコメント内では<code>&quot;{-&quot;</code>と<code>&quot;-}&quot;</code>の文字の並びは特別な意味を持たず、一方でネストされたコメント内ではダッシュの並びは特別な意味を持たない。</p>
<p>ネストされたコメントはコンパイラープラグマのためにも使われる。それについては<a href="chapters/./chapters/12-compiler-pragmas.html">12章</a>で説明される。</p>
<p>もし、いくつかのコードがネストされたコメントによってコメントアウトされていたら、その時、そのコード内の文字列内または行末コメントに<code>&quot;{-&quot;</code>と<code>&quot;-}&quot;</code>があるとネストされたコメントに干渉する。</p>
<a class="header" href="#識別子と演算子" id="識別子と演算子"><h2>識別子と演算子</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>varid</em> </td><td> → </td><td> (<em>small</em> {<em>small</em> | <em>large</em> | <em>digit</em> | <code>'</code> })<sub>⟨reservedid⟩</sub></td></tr>
<tr><td><em>conid</em> </td><td> → </td><td> <em>large</em> {<em>small</em> | <em>large</em> | <em>digit</em> | <code>'</code> }</td></tr>
<tr><td><em>reservedid</em> </td><td> → </td><td> <code>case</code> | <code>class</code> | <code>data</code> | <code>default</code> | <code>deriving</code> | <code>do</code> | <code>else</code></td></tr>
<tr><td> </td><td>|</td><td> <code>foreign</code> | <code>if</code> | <code>import</code> | <code>in</code> | <code>infix</code> | <code>infixl</code></td></tr>
<tr><td> </td><td>|</td><td> <code>infixr</code> | <code>instance</code> | <code>let</code> | <code>module</code> | <code>newtype</code> | <code>of</code></td></tr>
<tr><td> </td><td>|</td><td> <code>then</code> | <code>type</code> | <code>where</code> | <code>_</code></td></tr>
</tbody></table>
<p>識別子は0個以上の文字、数字、アンダースコア、およびシングルクォートで構成される。識別子は字句的に小文字で始まる字句(変数識別子)と大文字から始まる字句(コンストラクタ識別子)の二つの名前空間に区別される。(セクション<a href="chapters/./chapter1-introduction.html">1.4</a>)これらの識別子は大文字と小文字を区別する。<code>name</code>、<code>naMe</code>、<code>Name</code>は3つの判然たる識別子である。(初め2つは変数識別子で、最後のはコンストラクタ識別子である。)</p>
<p>アンダースコア(<code>&quot;_&quot;</code>)は小文字として扱われ、小文字が許されるところならどこでも使用可能だ。しかしながら、全て<code>&quot;_&quot;</code>なものはパターンのワイルドカードのように使われる識別子として予約されている。未使用の識別子に対して警告を出すコンパイラーはアンダースコアで始まる識別子に対しては警告を抑制することが推奨される。これはプログラマーが未使用であると予想されるパラメータに<code>&quot;_foo&quot;</code>を使うことを許可している。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>varsym</em> </td><td> → </td><td> ( <em>symbol</em><sub>⟨:⟩</sub> {<em>symbol</em>} )<sub>⟨<em>reservedop</em> | <em>dashes</em>⟩</sub></td></tr>
<tr><td><em>consym</em> </td><td> → </td><td> ( <code>:</code> {<em>symbol</em>})<sub>⟨<em>reservedop</em>⟩</sub></td></tr>
<tr><td><em>reservedop&gt;</em> </td><td> → </td><td> <code>..</code> | <code>:</code> | <code>::</code> | <code>=</code> | <code>\</code> | <code>|</code> | <code>&lt;-</code> | <code>-&gt;</code> | <code>@</code> | <code>~</code> | <code>=&gt;</code></td></tr>
</tbody></table>
<p>演算子シンボルは上で定義したように、1つ以上の記号文字から形成され、2つの名前空間に字句的に区別される。(セクション<a href="chapters/./chapters/1-introduction.html">1.4</a>)</p>
<ul>
<li>コロンから始まる演算子シンボルはコンストラクタである。</li>
<li>他の文字から始まる演算子シンボルは普通の識別子である。</li>
</ul>
<p>コロン(<code>&quot;:&quot;</code>)はHaskellリストのコンストラクタとして使用されるためだけに予約されている。これにより、<code>&quot;[]&quot;</code>や<code>&quot;[a,b]&quot;</code>のようなリスト構文の他の部分との扱いが統一される。</p>
<p>接頭辞否定の特殊な構文を除き、全ての演算子は中置である。ただし、各中置演算子をセクション内で使用して、部分的に適応される演算子を生成することができる。(セクション<a href="chapters/./chapters/3-expressions.html">3.5</a>を参照)標準の中置演算子はすべて定義済みのシンボルであり、リバウンドすることがある。</p>
<p>レポートの残りの部分では、6種類の名前が使用される。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>varid</em> </td><td> </td><td>   </td><td> (variables)</td></tr>
<tr><td><em>conid</em> </td><td> </td><td>   </td><td> (constructors)</td></tr>
<tr><td><em>tyvar</em> </td><td> → </td><td> <em>varid</em> </td><td>           (type variables)</td></tr>
<tr><td><em>tycon</em> </td><td> → </td><td> <em>conid</em> </td><td>           (type constructors)</td></tr>
<tr><td><em>tycls</em> </td><td> → </td><td> <em>conid</em> </td><td>           (type classes)</td></tr>
<tr><td><em>modid</em> </td><td> → </td><td> {<em>conid</em> <code>.</code>} <em>conid</em> </td><td> (modules)</td></tr>
</tbody></table>
<p>変数と型変数は小文字で始まる識別子によって表され、そのほかは大文字で始まる識別子によって表される。また、変数とコンストラクタには中置形式があるが、他の4つにはない。モジュール名はドットで区切られた一連の<em>conid</em>である。名前空間についてはセクション<a href="chapters/./chapters/1-introduction.html">1.4</a>でも説明している。</p>
<p>特定の状況では、名前の前にモジュール識別子を付けることで、名前をオプションで修飾できる。これは変数、コンストラクタ、型コンストラクタ、型クラス、型クラス名に適応されるが、型変数やモジュール名には適応されない。修飾名については、チャプター<a href="chapters/./chapters/5-modules.html">5</a>で詳しく説明する。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>qvarid</em>    </td><td> → </td><td> [modid <code>.</code>] <em>varid</em></td></tr>
<tr><td><em>qconid</em>    </td><td> → </td><td> [modid <code>.</code>] <em>conid</em></td></tr>
<tr><td><em>qtycon</em>    </td><td> → </td><td> [modid <code>.</code>] <em>tycon</em></td></tr>
<tr><td><em>qtycls</em>    </td><td> → </td><td> [modid <code>.</code>] <em>tycls</em></td></tr>
<tr><td><em>qvarsym</em>   </td><td> → </td><td> [modid <code>.</code>] <em>varsym</em></td></tr>
<tr><td><em>qconsym</em>   </td><td> → </td><td> [modid <code>.</code>] <em>consym</em></td></tr>
</tbody></table>
<p>修飾名は語彙素なので、修飾子と名前の間には空白を入れることはできない。サンプルの語彙解析を以下に示す。</p>
<table><thead><tr><th> これは </th><th> このような語彙 </th></tr></thead><tbody>
<tr><td> <code>f.g</code> </td><td> <code>f . g</code> (3トークン)</td></tr>
<tr><td> <code>F.g</code> </td><td> <code>F.g</code> (修飾された'g')</td></tr>
<tr><td> <code>f..</code> </td><td> <code>f ..</code> (2トークン)</td></tr>
<tr><td> <code>F..</code> </td><td> <code>F..</code> (修飾された'.') </td></tr>
<tr><td> <code>F.</code>  </td><td> <code>F .</code> (2トークン) </td></tr>
</tbody></table>
<p>修飾子は名前の構文上の扱いを変更しない。例えば、<code>Prelude.+</code>はPrelude(セクション<a href="chapters/./chapters/4-declarations-and-bindings.html">4.4.2</a>)での<code>+</code>の定義と同じ固定性を持つ中置演算子である。</p>
<a class="header" href="#数値リテラル" id="数値リテラル"><h2>数値リテラル</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>decimal</em> </td><td> → </td><td> <em>digit</em>{<em>digit</em>}</td></tr>
<tr><td><em>octal</em> </td><td> → </td><td> <em>octit</em>{<em>octit</em>}</td></tr>
<tr><td><em>hexadecimal</em> </td><td> → </td><td> <em>hexit</em>{<em>hexit</em>}</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>integer</em> </td><td> → </td><td> <em>decimal</em></td></tr>
<tr><td> </td><td>|</td><td> <code>0o</code> <em>octal</em> | <code>0O</code> <em>octal</em></td></tr>
<tr><td> </td><td>|</td><td> <code>0x</code> <em>hexadecimal</em> | <code>0X</code> <em>hexadecimal</em></td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>float</em> </td><td> → </td><td> <em>decimal</em> . <em>decimal</em> [<em>exponent</em>]</td></tr>
<tr><td> </td><td>|</td><td> <em>decimal</em> <em>exponent</em></td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>exponent</em> </td><td> → </td><td> (<code>e</code> | <code>E</code>) [<code>+</code> | <code>-</code>] <em>decimal</em></td></tr>
</tbody></table>
<p>数値リテラルには整数と浮動小数点の2種類ある。整数リテラルは10進数(デフォルト)、8進数(<code>0o</code>または<code>0O</code>を先頭に付ける)、16進数表記(<code>0x</code>か<code>0X</code>を先頭に付ける)で指定できる。浮動小数点リテラルは常に10進数である。浮動小数点リテラルは小数点の前後に数値を含まなければいけない。これは小数点が他のドット文字の使い方に誤って認識されないことを保証するためだ。負数リテラルはセクション<a href="chapters/./chapters/3-expressions.html">3.4</a>で論じられる。数値リテラルの型はセクション<a href="chapters/./chapters/6-predefined-types-and-classes.html">6.4.1</a>で論じられる。</p>
<a class="header" href="#文字と文字列リテラル" id="文字と文字列リテラル"><h2>文字と文字列リテラル</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>char</em>  </td><td> → </td><td>   <code>'</code> (<em>graphic<sub>⟨' | \⟩</sub></em> | <em>space</em> | <em>escape<sub>⟨\&amp;⟩</sub></em>) <code>'</code></td></tr>
<tr><td><em>string</em>    </td><td> → </td><td>   <code>&quot;</code> {<em>graphic<sub>⟨&quot; | \⟩</sub></em> | <em>space</em> | <em>escape</em> | <em>gap</em>} <code>&quot;</code></td></tr>
<tr><td><em>escape</em>    </td><td> → </td><td>   <code>\</code> ( <em>charesc</em> | <em>ascii</em> | <em>decimal</em> | <code>o</code> <em>octal</em> | <code>x</code> <em>hexadecimal</em> )</td></tr>
<tr><td><em>charesc</em>   </td><td> → </td><td>   <code>a</code> | <code>b</code> | <code>f</code> | <code>n</code> | <code>r</code> | <code>t</code> | <code>v</code> | <sub>\</sub> | <sub>&quot;</sub> | <sub>'</sub> | <sub>&amp;</sub></td></tr>
<tr><td><em>ascii</em> </td><td> → </td><td>   <em>^cntrl</em> | <code>NUL</code> | <code>SOH</code> | <code>STX</code> | <code>ETX</code> | <code>EOT</code> | <code>ENQ</code> | <code>ACK</code></td></tr>
<tr><td> </td><td>|</td><td>  <code>BEL</code> | <code>BS</code> | <code>HT</code> | <code>LF</code> | <code>VT</code> | <code>FF</code> | <code>CR</code> | <code>SO</code> | <code>SI</code> | <code>DLE</code></td></tr>
<tr><td> </td><td>|</td><td>  <code>DC1</code> | <code>DC2</code> | <code>DC3</code> | <code>DC4</code> | <code>NAK</code> | <code>SYN</code> | <code>ETB</code> | <code>CAN</code></td></tr>
<tr><td> </td><td>|</td><td> <code>EM</code> | <code>SUB</code> | <code>ESC</code> | <code>FS</code> | <code>GS</code> | <code>RS</code> | <code>US</code> | <code>SP</code> | <code>DEL</code></td></tr>
<tr><td><em>cntrl</em> </td><td> → </td><td>   <em>ascLarge</em> | <code>@</code> | <code>[</code> | <code>\</code> | <code>]</code> | <code>^</code> | <code>_</code></td></tr>
<tr><td><em>gap</em>   </td><td> → </td><td>   <code>\</code> <em>whitechar</em> {<em>whitechar</em>} <code>\</code></td></tr>
</tbody></table>
<p>文字リテラルは<code>'a'</code>のようにシングルクォーテーションで囲まれたものであり、文字列リテラルは<code>&quot;Hello&quot;</code>のようにダブルクォーテーションで囲まれたものである。</p>
<p>エスケープコードは特殊文字の表現のために文字と文字列で使われる。注意すべきことはシングルクォーテーション(')は文字列においても使われるが、文字でエスケープする必要があることだ。同様に、ダブルクォーテーションは文字の中で使われるが、その際は文字列でエスケープする必要がある。<code>\</code>は常にエスケープしないといけない。<em>charesc</em>カテゴリには&quot;アラート&quot;(<code>\a</code>)、&quot;バックスペース&quot;(<code>\b</code>)、&quot;改ページ&quot;(<code>\f</code>)、&quot;改行&quot;(<code>\n</code>)、&quot;キャリッジ・リターン&quot;(<code>\r</code>)、&quot;水平タブ&quot;(<code>\t</code>)、&quot;垂直タブ&quot;(<code>\v</code>)といった文字のポータブル表現も含まれている。</p>
<p><code>\^X</code>のような制御文字を含むUnicode文字セットのエスケープ文字も用意している。<code>\137</code>のような数値エスケープは10進数表現の137で文字を指定するために使用され、同様に8進数(例:<code>\o137</code>)や16進数(例:<code>\x37</code>)の表現も可能である。</p>
<p>“maximal munch”に従って、文字列内の数字のエスケープ文字は全て連続した数字で構成され、任意の長さにすることができる。同様に、<code>&quot;\SOH&quot;</code>のような奇妙なASCIIエスケープコードは長さ1の文字列としてパ－スされる。<code>'\&amp;'</code>エスケープ文字は<code>&quot;\137\&amp;9&quot;</code>や<code>&quot;SO\&amp;H&quot;</code>のような文字列(共に長さは2)が構成できるように&quot;ヌル文字&quot;として提供される。その代わり<code>&quot;\&amp;&quot;</code>は<code>&quot;&quot;</code>に等しく、<code>'\&amp;'</code>文字は許されない。文字の等価性はセクション<a href="chapters/./chapters/6-predefined-types-and-classes.html">6.1.2</a>で定義されている。</p>
<p>文字列は無視される&quot;ギャップ&quot;(白い文字を囲む2つのバックスラント)を含むかもしれない。これにより1行の終わりと次の行の始めにバックスラントを書くことによって、複数の行に長い文字列を書くことが可能だ。例としては以下のものになる。</p>
<pre><code class="language-hs">&quot;Here is a backslant \\ as well as \137, \  
    \a numeric escape character, and \^X, a control character.&quot;
</code></pre>
<p>文字列リテラルは実際には文字のリストの略記である。(セクション<a href="chapters/./chapters/3-expressions.html">3.7</a>を参照)</p>
<a class="header" href="#レイアウト" id="レイアウト"><h2>レイアウト</h2></a>
<p>Haskellはレイアウトを使用して同じ情報を伝えることによって、いくつかの文法で使用されている中括弧とセミコロンの省略を許可している。これによりレイアウトに依存するもの、しないものの両方のコーディングスタイルが可能になり、1つのプログラム内で自由に混在させることができる。レイアウトが必要ではないため、Haskellプログラムは他のプログラムによって簡単に作成することができる。</p>
<p>レイアウトがHaskellプログラムの意味に与える影響は、レイアウトによって決定される場所に中括弧とセミコロンを追加することによって完全に指定できる。この拡張プログラムの意味はレイアウトに影響されなくなった。</p>
<p>非公式には中括弧とセミコロンは次のように挿入される。キーワードの<code>where</code>、<code>let</code>、<code>do</code>、または<code>of</code>の後に開き括弧が省略されると、レイアウト(または&quot;オフサイド&quot;)規則が有効になる。これが起こると、次の語彙素のインデントが(新しい行にあるかどうかにかかわらず)記録され、省略された開き括弧が挿入される(語彙素の前の空白にはコメントが含まれる場合がある)。後続の行について、空白のみが含まれている場合、またはそれ以上のインデントされている場合は、前の項目が続行される。(何も挿入されない)同じ量だけインデントされている場合は新しい項目が始まる(セミコロンが挿入される)。またインデントが小さくなると、レイアウトリストは終了する(閉じ括弧が挿入される)。<code>where</code>、<code>let</code>、<code>do</code>または<code>of</code>の直後のノンブレース語彙素のインデントが現在のインデントレベル以下である場合は、レイアウトを開始する代わりに、空のリスト<code>&quot;{}&quot;</code>が挿入され、現在のレベルでレイアウト処理が発生する(つまり、セミコロンまたは閉じ括弧を挿入する)。レイアウトリストを含む構文カテゴリが終了するたびに、閉じ括弧も挿入される。つまり、閉じ括弧が合法となる点で違法な語彙素が検出された場合は閉じ括弧が挿入される。レイアウトルールはそれが挿入した開いている中括弧にだけ一致する。明示的な開き括弧は、明示的に閉じ括弧と一致しなければならない。これらの明示的な開き括弧内では、たとえ行が以前の暗黙の開き括弧の左側に字下げされていても、括弧の外側の構成要素に対してレイアウト処理は実行されない。</p>
<p>セクション<a href="chapters/./chapters/10-syntax-reference.html#3">10.3</a>ではレイアウトルールのより正確な定義を示す。</p>
<p>これらの規則を考えると、1つの改行で実際に複数のレイアウトリストを終了させることができる。
これらの規則は以下のコードを許す。</p>
<pre><code class="language-hs">f x = let a = 1; b = 2  
          g y = exp2  
       in exp1
</code></pre>
<p>生成した<code>a</code>, <code>b</code>, <code>g</code>は全て同じレイアウトリストの一部である。</p>
<p>例として、図<a href="#figure2.1">2.1</a>は(ややわざとらしい)モジュールを示し、図<a href="#figure2.2">2.2</a>はそのレイアウトルールを適応した結果を示している。次の部分に注意: (a) <code>}};pop</code>で行が開始している個所において、前の行が終了すると、ネストした<code>where</code>区の深さ(3)に対応する3つレイアウトルールの利用が呼び出される。(b)<code>where</code>句の閉じ括弧はタプルと<code>case</code>式にネストされており、タプルの終了を検出されたため挿入された。(c)一番最後の閉じ括弧は、Eofトークンの0列のインデントにより挿入された。</p>
<pre><code class="language-hs">module AStack( Stack, push, pop, top, size ) where  
data Stack a = Empty  
             | MkStack a (Stack a)  

push :: a -&gt; Stack a -&gt; Stack a  
push x s = MkStack x s  

size :: Stack a -&gt; Int  
size s = length (stkToLst s)  where  
           stkToLst  Empty         = []  
           stkToLst (MkStack x s)  = x:xs where xs = stkToLst s  

pop :: Stack a -&gt; (a, Stack a)  
pop (MkStack x s)  
  = (x, case s of r -&gt; i r where i x = x) -- (pop Empty) is an error  

top :: Stack a -&gt; a  
top (MkStack x s) = x                     -- (top Empty) is an error
</code></pre>
<p><a name="figure2.1">図2.1:</a> サンプルプログラム</p>
<pre><code class="language-hs">module AStack( Stack, push, pop, top, size ) where  
{data Stack a = Empty  
             | MkStack a (Stack a)  

;push :: a -&gt; Stack a -&gt; Stack a  
;push x s = MkStack x s  

;size :: Stack a -&gt; Int  
;size s = length (stkToLst s)  where  
           {stkToLst  Empty         = []  
           ;stkToLst (MkStack x s)  = x:xs where {xs = stkToLst s  

}};pop :: Stack a -&gt; (a, Stack a)  
;pop (MkStack x s)  
  = (x, case s of {r -&gt; i r where {i x = x}}) -- (pop Empty) is an error  

;top :: Stack a -&gt; a  
;top (MkStack x s) = x                        -- (top Empty) is an error  
}
</code></pre>
<p><a name="figure2.2">図2.2:</a> レイアウトを展開したサンプルプログラム</p>
<a class="header" href="#式" id="式"><h1>式</h1></a>
<p>この章では、私たちはHaskellの式の構文と非形式的な意味論を説明する。また必要であらばHaskellカーネルへの変換についても説明する。<code>let</code>式の場合を除いて、これらの変換は静的、動的な意味論の両方を保存する。これらの変換を使った束縛されていない変数とコンストラクタは常に<code>Prelude</code>によって定義された実体を参照する。例えば、リスト内包表記の変換(セクション[3.11])で使われる<code>&quot;concatMap&quot;</code>は<code>Prelude</code>によって定義された<code>concatMap</code>を意味する。これは識別子<code>&quot;concatMap&quot;</code>がリスト内包表記で使われているスコープ内にあるかないかは関係なく、また、(もしスコープ内にあったとしても)束縛されていても関係はない。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>exp</em></td><td>→</td><td><em>infixexp</em> :: [context =&gt;] type</td><td>(expression type signature)</td></tr>
<tr><td>       </td><td>|</td><td><em>infixexp</em></td><td>(expression type signature)</td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td><em>infixexp</em></td><td>→</td><td><em>lexp</em> qop <em>infixexp</em></td><td>(infix operator application)</td></tr>
<tr><td>            </td><td>|</td><td>- <em>infixexp</em></td><td>(prefix negation)</td></tr>
<tr><td>            </td><td>|</td><td><em>lexp</em></td><td> </td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td><em>lexp</em></td><td>→</td><td>\ <em>apat<sub>1</sub></em> … <em>apat<sub>n</sub></em> -&gt; <em>exp</em></td><td>(lambda abstraction, <em>n</em> ≥ 1)</td></tr>
<tr><td>        </td><td>|</td><td><code>let</code> <em>decls</em> <code>in</code> <em>exp</em></td><td>(let expression)</td></tr>
<tr><td>        </td><td>|</td><td><code>if</code> <em>exp</em> [;] <code>then</code> <em>exp</em> [;] <code>else</code> <em>exp</em></td><td>(conditional)</td></tr>
<tr><td>          </td><td>|</td><td><code>case</code> <em>exp</em> of { <em>alts</em> }</td><td>(case expression)</td></tr>
<tr><td>        </td><td>|</td><td><code>do</code> { <em>stmts</em> }</td><td>(do expression)</td></tr>
<tr><td>        </td><td>|</td><td><em>fexp</em></td><td> </td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td><em>fexp</em></td><td>→</td><td>[<em>fexp</em>] <em>aexp</em></td><td>(function application)</td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td><em>aexp</em></td><td>→</td><td><em>qvar</em></td><td>(variable)</td></tr>
<tr><td>        </td><td>|</td><td><em>gcon</em></td><td>(general constructor)</td></tr>
<tr><td>        </td><td>|</td><td><em>literal</em></td><td> </td></tr>
<tr><td>        </td><td>|</td><td>( <em>exp</em> )</td><td>(parenthesized expression)</td></tr>
<tr><td>        </td><td>|</td><td>( <em>exp<sub>1</sub></em> , … , <em>exp<sub>k</sub></em> )</td><td>(tuple, <em>k</em> ≥ 2)</td></tr>
<tr><td>        </td><td>|</td><td>[ <em>exp<sub>1</sub></em> , … , <em>exp<sub>k</sub></em> ]</td><td>(list, <em>k</em> ≥ 1)</td></tr>
<tr><td>        </td><td>|</td><td>[ <em>exp<sub>1</sub></em> [, <em>exp<sub>2</sub></em>] .. [<em>exp<sub>3</sub></em>] ]</td><td>(arithmetic sequence)</td></tr>
<tr><td>        </td><td>|</td><td>[ <em>exp</em> | <em>qual<sub>1</sub></em> , … , <em>qual<sub>n</sub></em> ]</td><td>(list comprehension, <em>n</em> ≥ 1)</td></tr>
<tr><td>        </td><td>|</td><td>( <em>infixexp</em> <em>qop</em> )</td><td>(left section)</td></tr>
<tr><td>        </td><td>|</td><td>( <em>qop<sub>⟨-⟩</sub></em> <em>infixexp</em> )</td><td>(right section)</td></tr>
<tr><td>        </td><td>|</td><td><em>qcon</em> { <em>fbind<sub>1</sub></em> , … , <em>fbind<sub>n</sub></em> }</td><td>(labeled construction, <em>n</em> ≥ 0)</td></tr>
<tr><td>        </td><td>|</td><td><em>aexp<sub>⟨qcon⟩</sub></em> { <em>fbind<sub>1</sub></em> , … , <em>fbind<sub>n</sub></em> }</td><td>(labeled update, <em>n</em>  ≥  1)</td></tr>
</tbody></table>
<p>中置演算子を含む式は演算子の結合性によって曖昧さを排除されている(セクション<a href="chapters/./4-declarations-and-bindings.html">4.4.2</a>参照)。同じ優先度をもつ連続した括弧を持たない演算子は構文エラーを避けるためにどちらも左または右のどちらかに結合しなければならない。括弧を持たない式<em>&quot;x qop<sup>(a,i)</sup> y qop<sup>(b,j)</sup> z&quot;</em> ( <em>qop<sup>(a,i)</sup></em>は<em>a</em>と優先順位<em>i</em>に関連付いた演算子を意味する)が与えられた場合、括弧は<em>i = j</em>でかつ<em>a = b = l</em>か<em>a = b = r</em>でない時は、<em>&quot;x qop<sup>(a,i)</sup> y&quot;</em>か<em>&quot;y qop<sup>(b,i)</sup> z&quot;</em>のどちらかを囲むよう追加されなければいけない。</p>
<p>中置演算子を含む式の解決するためのアルゴリズムの例はセクション<a href="chapters/./10-syntax-reference.html">10.6</a>にある。</p>
<p>符号反転演算子はHaskellにおいて唯一の接頭語になる。中置と同じ優先順位を持ち、演算子はPreludeの中に定義されている(セクション<a href="chapters/./4-declarations-and-bindings.html">4.4.2</a>, 図<a href="chapters/./4-declarations-and-bindings.html">4.1</a>)。</p>
<p>この文法は条件式、let式、ラムダ抽象の拡張については曖昧だ。その曖昧さは各構成ができるだけ右へ拡張されるメタ規則により解決される。</p>
<p>構文解析の例を以下に示す。</p>
<table><thead><tr><th>これが</th><th> このように解析される</th></tr></thead><tbody>
<tr><td> f x + g y </td><td> (f x) + (g y) </td></tr>
<tr><td> - f x + y </td><td> (- (f x)) + y </td></tr>
<tr><td> let { ... } in x + y </td><td> let { ... } in (x + y) </td></tr>
<tr><td> z + let { ... } in x + y </td><td> z + (let { ... } in (x + y)) </td></tr>
<tr><td> f x y :: Int </td><td> (f x y) :: Int </td></tr>
<tr><td> \ x -&gt; a+b :: Int </td><td> \ x -&gt; ((a+b) :: Int) </td></tr>
</tbody></table>
<p>わかりやすくするため、以後このセクションでは中置演算子を含む式が演算子の結合性に従って解決されているということにする。</p>
<a class="header" href="#エラー" id="エラー"><h2>エラー</h2></a>
<p>式の評価中のエラーは、<code>⊥(&quot;bottom&quot;)</code>と表記されるが、停止しないことからHaskellプログラムには区別できない。Haskellは非正格評価の言語なことから、全てのHaskellの型は<code>⊥</code>を含む。つまり、いかなる型の値もユーザーが望めばエラーを返す計算になる可能性がある。評価されたときエラーは直ちにプログラムを停止させ、ユーザーが捕捉されることはできない。Preludeは直接そのようなエラーを引き起こす二つの関数を提供している。</p>
<pre><code class="language-hs">error     :: String -&gt; a
undefined :: a
</code></pre>
<p><code>error</code>の呼び出しはプログラムの実行を終了させ、OSに適切なエラー表示を返す。そのエラー表示にはシステム依存の方法で文字列を画面に表示するべきである。<code>undefined</code>が使われたとき、そのエラーメッセージはコンパイラーによって作成される。</p>
<p>Haskellの式の変換は実行時エラーが発生したことを明示的に表示するため<code>error</code>と<code>undefined</code>を使用する。エラーが発生した際の実際のプログラムの振舞は実装次第である。そのメッセージはこれらの変換のみ提案するため<code>error</code>関数へ渡される。エラー発生時、詳しい情報または乏しい情報を表示することを実装側は選択するかもしれない。</p>
<a class="header" href="#変数コンストラクタ演算子リテラル" id="変数コンストラクタ演算子リテラル"><h2>変数、コンストラクタ、演算子、リテラル</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>aexp</em></td><td>→</td><td><em>qvar</em></td><td>(variable)</td></tr>
<tr><td>        </td><td>|</td><td><em>gcon</em></td><td>(general constructor)</td></tr>
<tr><td>        </td><td>|</td><td><em>literal</em></td><td> </td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td><em>gcon</em></td><td>→</td><td>()</td><td> </td></tr>
<tr><td>          </td><td>|</td><td>[]</td><td> </td></tr>
<tr><td>          </td><td>|</td><td>(,{,})</td><td> </td></tr>
<tr><td>          </td><td>|</td><td><em>qcon</em></td><td> </td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td>    <em>var</em></td><td>→</td><td><em>varid</em> | ( <em>varsym</em> )</td><td>(variable)</td></tr>
<tr><td>   <em>qvar</em></td><td>→</td><td><em>qvarid</em> | ( <em>qvarsym</em> )</td><td>(qualified variable)</td></tr>
<tr><td>    <em>con</em></td><td>→</td><td><em>conid</em> | ( <em>consym</em> )</td><td>(constructor)</td></tr>
<tr><td>   <em>qcon</em></td><td>→</td><td><em>qconid</em> | ( <em>gconsym</em> )</td><td>(qualified constructor)</td></tr>
<tr><td>  <em>varop</em></td><td>→</td><td><em>varsym</em> | `  <em>varid</em> `</td><td>(variable operator)</td></tr>
<tr><td> <em>qvarop</em></td><td>→</td><td><em>qvarsym</em> | `  <em>qvarid</em> `</td><td>(qualified variable operator)</td></tr>
<tr><td>  <em>conop</em></td><td>→</td><td><em>consym</em> | `  <em>conid</em> `</td><td>(constructor operator)</td></tr>
<tr><td> <em>qconop</em></td><td>→</td><td><em>gconsym</em> | `  <em>qconid</em> `</td><td>(qualified constructor operator)</td></tr>
<tr><td>     <em>op</em></td><td>→</td><td><em>varop</em> | <em>conop</em></td><td>(operator)</td></tr>
<tr><td>    <em>qop</em></td><td>→</td><td><em>qvarop</em> | <em>qconop</em></td><td>(qualified operator)</td></tr>
<tr><td><em>gconsym</em></td><td>→</td><td>: | <em>qconsym</em></td></tr>
</tbody></table>
<p>Haskellは中置記法に対応するため特別な構文を提供している。 <strong>演算子</strong>  は中置構文を用いて適用が可能である(セクション<a href="%22#3.4%22">3.4</a>)か、 <strong>セクション</strong>  (セクション<a href="%22#3.5%22">3.5</a>)を用いて部分的に適用が可能な関数のことである。</p>
<p><strong>演算子</strong>  は、<code>+</code>や<code>$$</code>といった  <strong>演算子シンボル</strong>  か、<code>` op `</code>のようにグレイブ・アクセント(バッククォート)で囲まれた通常の識別子かのいずれかである。例えば、<code>op x y</code>という前置適用を書く代わりに、<code>x `op` y</code>という中置適用を書くことができる。もし、<code>` op `</code>に対して結合性が宣言されていない場合には、優先順位は最高で左結合をデフォルトとする。(セクション<a href="chapters/./4-declarations-andbindings.html">4.4.2</a>参照)。</p>
<p>対照的に、演算子シンボルは括弧で閉じられた普通の識別子へ変換可能である。例として、<code>(+) x y</code>は<code>x + y</code>に等しく、<code>foldr (⋆) 1 xs</code>は<code>foldr (\x y -&gt; x⋆y) 1 xs</code>に等しくなる。</p>
<p>一部の組み込み型のコンストラクタの名前をつけるのに特別な構文がつかわれているものがあり、実際に<em>gcon</em>や<em>literal</em>で見ることができる。これらについてはセクション<a href="chapters/./6-predefined-types-and-classes.html">6.1</a>で説明される。</p>
<p>整数リテラルは<code>fromInteger</code>関数を<code>Integer</code>型の適した値への適用を表す。同様に、浮動小数点リテラルは<code>Rational</code>型(つまり、<code>Ratio Integer</code>)の値に<code>fromRational</code>を適用することを表す。</p>
<div class="column">
<p><strong>変換:</strong> 整数リテラル<em>i</em>は<code>fromInteger <em>i</em></code>に等しく、<code>fromInteger</code>は<code>Num</code>クラスのメソッドである。(セクション<a href="./6-predefined-types-and-classes,md">6.4.1</a>)</p>
<p>浮動小数点リテラル<em>f</em>は<code>fromRational (<em>n</em> Ratio.% <em>d</em>)</code>に等しく、<code>fromRational</code>は<code>Fractional</code>クラスのメソッドで、<code>Ratio.%</code>は<code>Ratio</code>ライブラリで定義されており、2つの整数から有理数を構築する。整数<em>n</em>と<em>d</em>は<em>n/d = f</em>を満たすものとして選ばれる。</p>
</div>
<a class="header" href="#カリー化された適用とラムダ抽象" id="カリー化された適用とラムダ抽象"><h2>カリー化された適用とラムダ抽象</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>fexp</em></td><td>→</td><td>[<em>fexp</em>] <em>aexp</em></td><td>(function application)</td></tr>
<tr><td><em>lexp</em></td><td>→</td><td>\ <em>apat<sub>1</sub></em> … <em>apat<sub>n</sub></em> -&gt; <em>exp</em></td><td>(lambda abstraction, <em>n</em> ≥ 1)</td></tr>
</tbody></table>
<p>関数適用は<em>e<sub>1</sub></em> <em>e<sub>2</sub></em>と書く。適用は左結合性をもつので、<code>(f x) y</code>の括弧は省略することができる。<em>e<sub>1</sub></em>はデータ構成子である可能性もあるため、データ構成子の部分的な適用は許されている。</p>
<p><strong>ラムダ抽象</strong> は<code>\ <em>p<sub>1</sub></em> … <em>p<sub>n</sub></em> -&gt; e</code>と書き、<code><em>p<sub>i</sub></em></code>はパターンである。<code>\x:xs-&gt;x</code>のような式は構文的に正しくない。<code>(x:xs)-&gt;x</code>と書くのが正しい。</p>
<p>パターンの集合は <strong>線形</strong> でなければならない。つまり、変数は集合の中で2回以上出現してはいけない。</p>
<div class="column">
<p><strong>変換:</strong> 以下の等式が成り立つ。</p>
<pre><code><em>p<sub>1</sub></em> … <em>p<sub>n</sub></em> -> e = \ X<sub>1</sub> … X<sub>n</sub> -> case (X<sub>1</sub>, …, X<sub>n</sub>) of (<em>p<sub>1</sub></em>, …, <em>p<sub>n</sub></em>) -> e</code></pre>
<p><em>X<sub>i</sub></em>は新しい識別子である。</p>
</div>
<p>この変換がセクション<a href="%22#3.17.3%22">3.17.3</a>で説明するcase式とパターンマッチの意味論と組み合わさって与えられたとき、もしもパターンマッチに失敗すれば結果は<code>⊥</code>となる。</p>
<a class="header" href="#演算子適用" id="演算子適用"><h2>演算子適用</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>infixexp</em></td><td>→</td><td><em>lexp</em> <em>qop</em> <em>infixexp</em></td><td> </td></tr>
<tr><td>            </td><td>|</td><td>- <em>infixexp</em></td><td>(prefix negation)</td></tr>
<tr><td>            </td><td>|</td><td><em>lexp</em></td><td> </td></tr>
<tr><td><em>qop</em></td><td>→</td><td><em>qvarop</em> | <em>qconop</em></td><td>(qualified operator)</td></tr>
</tbody></table>
<p><em>e<sub>1</sub> qop e<sub>2</sub></em>という形式は二項演算子<em>qop</em>の式<em>e<sub>1</sub></em>と<em>e<sub>2</sub></em>への中置適用である。</p>
<p>特殊な形式<em>-e</em>は前置の符号反転演算子を表す。この演算子はHaskellにおける唯一の前置演算子であり、<code>negate (<em>e</em>)</code>という意味の構文である。二項演算子<code>-</code>はPrelude内の<code>-</code>の定義への参照を必要とせず、モジュールシステムによって再束縛されるかもしれない。しかしながら、単項演算子<code>-</code>はPrelude内で定義された<code>negate</code>関数を常に参照する。<code>-</code>演算子の局所的な意味と単項の符号反転演算との間には何の関連もない。</p>
<p>前置の符号反転演算子はPrelude内(表<a href="chapters/./4-declarations-and-bindings.html">4.1</a>を参照)で定義された中置演算子<code>-</code>と同じ優先順位を持つ。<code>e1-e2</code>は二項演算子<code>-</code>の中置表現解析されるため、前置の符号反転演算子を使うには構文解析に代わって<code>e1(-e2)</code>と書かなければいけない。同様に、<code>(-)</code>は中置演算子と同様に<code>(\ x y -&gt; x-y)</code>のための構文であるが、<code>(\ x -&gt; -x)</code>を表せず、そのためには<code>negate</code>を使う必要がある。</p>
<div class="column">
<p><strong>変換：</strong> 以下の等式が成り立つ。</p>
<pre>
<code><em>e<sub>1</sub></em> op <em>e<sub>2</sub></em>  =	(op) <em>e<sub>1</sub></em> <em>e<sub>2</sub></em>
-e        =	<em>negate</em> (e)
</code></pre>
</div>
<a class="header" href="#セクション" id="セクション"><h2>セクション</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>aexp</em></td><td>→</td><td> ( <em>infixexp</em> <em>qop</em> )              </td><td>(left section)</td></tr>
<tr><td>        </td><td>|</td><td> ( <em>qop<sub>⟨-⟩</sub></em> <em>infixexp</em> )</td><td>(right section)</td></tr>
</tbody></table>
<p><strong>セクション</strong> は( <em>op</em> <em>e</em> )や( <em>e</em> <em>op</em> )のように書かれる。このときの<em>op</em>は二項演算子で<em>e</em>は式である。セクションは二項演算子を部分的に適用する便利な構文である。</p>
<p>シンタックスの先行ルールは次のとおりのセクションへ適用する。<em>(op e)</em>は<em>(x op e)</em>が<em>(x op (e))</em>と同じ方法でパースする場合に限り正当であり、<em>(e op)</em>も同様である。例えば、<code>(⋆a+b)</code>は構文的に不当であるが、<code>(+a⋆b)</code>と<code>(⋆(a+b))</code>は有効である。なぜなら<code>(+)</code>は左結合であり、<code>(a+b+)</code>は構文的に正しいが、<code>(+a+b)</code>はそうではない。後者は<code>(+(a+b))</code>のように書かれるのが正当である。他の例として、次の式は</p>
<pre><code class="language-hs">(let n = 10 in n +)
</code></pre>
<p>セクション<a href="chapters/./3-expressions.html">3</a>にあるように、let/ラムダに関するメタルールにより誤りである。次の式は</p>
<pre><code class="language-hs">(let n = 10 in n + x)
</code></pre>
<p>以下のように解析され</p>
<pre><code class="language-hs">(let n = 10 in (n + x))
</code></pre>
<p>次のようにはならない</p>
<pre><code class="language-hs">((let n = 10 in n) + x)
</code></pre>
<p>なぜなら、<code>-</code>は文法内で特別に扱われるからだ。前のセクションで説明したように、(- <em>exp</em>)はセクションではなく、前置の符号反転演算子の適用である。しかしながら、Prelude名で定義された<code>subtract</code>関数があり、それによって<code>(subtract <em>exp</em>)</code>が不正なセクション(<strong>訳注</strong>: (- <em>exp</em>)のこと)と同じ意味となる。式(+ (- <em>exp</em>))は同じ用途で役立つことができる。</p>
<div class="column">
<p><strong>変換:</strong> 以下の等式が成り立つ。</p>
<pre><code class="language-hs">(op e)  =       \ x -&gt; x op e
(e op)  =       \ X -&gt; e op x
</code></pre>
<p><em>op</em>は二項演算子で、<em>e</em>は式であり、<em>x</em>は<em>e</em>の中で自由出現ではない変数である。</p>
</div>
<a class="header" href="#条件文" id="条件文"><h2>条件文</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>lexp</em></td><td>→</td><td><code>if</code> <em>exp</em> [;] <code>then</code> <em>exp</em> [;] <code>else</code> <em>exp</em></td><td> </td></tr>
</tbody></table>
<p>条件式は<code>if <em>e<sub>1</sub></em> then <em>e<sub>2</sub></em> else <em>e<sub>3</sub></em></code>の形式をとり、もし<em>e<sub>1</sub></em>が<code>True</code>なら、<em>e<sub>2</sub></em>を返し、<em>e<sub>1</sub></em>が<code>False</code>なら<em>e<sub>3</sub></em>を返し、それ以外なら<code>⊥</code>を返す。</p>
<div class="column">
<p><strong>変換:</strong> 以下の等式が成り立つ。</p>
<pre><code>if <em>e<sub>1</sub></em> then <em>e<sub>2</sub></em> else <em>e<sub>3</sub></em>(op e) = case <em>e<sub>1</sub></em> of { True -> <em>e<sub>2</sub></em> ; False -> <em>e<sub>3</sub></em> }
</code></pre>
<p><code>True</code>と<code>False</code>はPrelude内で定義されている<code>Bool</code>型の2つの引数のないコンストラクタである。<em>e<sub>1</sub></em>は<code>Bool</code>型でなければならず、<em>e<sub>2</sub></em>と<em>e<sub>3</sub></em>も同じ型でなければならない。条件式全体の型も同様である。</p>
</div>
<a class="header" href="#リスト" id="リスト"><h2>リスト</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>infixexp</em></td><td>→</td><td><em>exp<sub>1</sub></em> <em>qop</em> <em>exp<sub>2</sub></em></td><td> </td></tr>
<tr><td>    <em>aexp</em></td><td>→</td><td>[ <em>exp<sub>1</sub></em> , … , <em>exp<sub>k</sub></em> ]</td><td>(<em>k</em> ≥ 1)</td></tr>
<tr><td>            </td><td>|</td><td><em>gcon</em></td><td> </td></tr>
<tr><td>    <em>gcon</em></td><td>→</td><td><code>[]</code></td><td> </td></tr>
<tr><td>            </td><td>|</td><td><em>qcon</em></td><td> </td></tr>
<tr><td>    <em>qcon</em></td><td>→</td><td>( <em>gconsym</em> )</td><td> </td></tr>
<tr><td>     <em>qop</em></td><td>→</td><td><em>qconop</em></td><td> </td></tr>
<tr><td>  <em>qconop</em></td><td>→</td><td><em>gconsym</em></td><td> </td></tr>
<tr><td> <em>gconsym</em></td><td>→</td><td><code>:</code></td><td> </td></tr>
</tbody></table>
<p><em>List</em> は<em>k</em> ≥ 1として、[<em>e<sub>1</sub></em>, …, <em>e<sub>k</sub></em>]のように書く。リストコンストラクタは <code>:</code>であり、空リストは<code>[]</code>で表記される。リストの標準操作はPrelude内で与えられる(セクション<a href="chapters/./6-predefined-types-and-classes.html">6.1.3</a>と<a href="chapters/./9-standard-prelude.html">9章</a>の特にセクション<a href="chapters/./9-standard-prelude.html">9.1</a>を参照)。</p>
<div class="column">
<p><strong>変換:</strong> 以下の等式が成り立つ。</p>
<pre>
<code>[<em>e<sub>1</sub></em>, …, <em>e<sub>k</sub></em>] = <em>e<sub>1</sub></em> : (<em>e<sub>2</sub></em> : ( … (<em>e<sub>k</sub></em> : [])))</code></pre>
<p><code>:</code>と<code>[]</code>はPredule内(セクション<a href="chapters/./6-predefined-types-and-classes.html">6.1.3</a>)で定義されたリストのコンストラクタである。<em>e<sub>1</sub></em>から<em>e<sub>k</sub></em>までの型は同じでなければならない(それを<em>t</em>と呼ぶ)。式全体の型は<em>[t]</em>になる(セクション<a href="chapters/./4-declarations-and-bindings.html">4.1.2</a>)。</p>
</div>
<p>コンストラクタ<code>&quot;:&quot;</code>は<code>[]</code>のようにリストコンストラクタとしてのみ予約されており、言語構文の一部と見做されている。また、それは隠すことも再定義することもできない。<code>:</code>は優先順位レベル5の右結合演算子である(セクション<a href="chapters/./4-declarations-and-bindings.html">4.4.2</a>)。</p>
<a class="header" href="#タプル" id="タプル"><h2>タプル</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>aexp</em></td><td>→</td><td>( <em>exp<sub>1</sub></em> , … , <em>exp<sub>k</sub></em> )</td><td>(<em>k</em> ≥ 2)</td></tr>
<tr><td>        </td><td>|</td><td><em>qcon</em></td><td> </td></tr>
<tr><td><em>qcon</em></td><td>→</td><td>(,{,})</td><td> </td></tr>
</tbody></table>
<p><strong>タプル</strong>  は<em>k</em> ≥ 2以上の(<em>e<sub>1</sub></em>, …, <em>e<sub>k</sub></em>)のように書く。<em>n-tuple</em>のコンストラクタは<code>(,…,)</code>と表記され、<em>n</em> - 1のコンマがある。従って、<code>(a,b,c)</code>と<code>(,,) a b c</code>は同じ値を表す。タプルの標準操作はPrelude内で定義されている(セクション<a href="chapters/./6-predefined-types-and-classes.html">6.1.4</a>と<a href="chapters/./9-standard-prelude.html">9章</a>)。</p>
<div class="column">
<p><strong>変換:</strong> <em>k</em> ≥ 2のときの(<em>e<sub>1</sub></em>, …, <em>e<sub>k</sub></em>)はPrelude内で定義された<em>k</em>-tupleのインスタンスになり、変換は要求されない。もし、<em>t<sub>1</sub></em>から<em>t<sub>k</sub></em>はそれぞれ<em>e<sub>1</sub></em>から<em>e<sub>k</sub></em>の型があり、最終的なタプルの型は(<em>t<sub>1</sub></em>,…,<em>t<sub>k</sub></em>)になる(セクション<a href="chapters/./4-declarations-and-bindings.html">4.1.2</a>)。</p>
</div>
<a class="header" href="#単位式と括弧付き式" id="単位式と括弧付き式"><h2>単位式と括弧付き式</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>aexp</em></td><td>→</td><td><em>gcon</em></td><td> </td></tr>
<tr><td>        </td><td>|</td><td><code>(</code> <em>exp</em> <code>)</code></td><td> </td></tr>
<tr><td><em>gcon</em></td><td>→</td><td><code>()</code></td><td> </td></tr>
</tbody></table>
<p><em>(e)</em>の形式はシンプルに <strong>括弧付き式</strong> であり、<em>e</em>と等しい。<em>ユニット(unit)</em>式<code>()</code>は<code>()</code>型を持つ(セクション<a href="chapters/./4-declarations-and-bindings.html">4.1.2</a>を参照)。それは<code>⊥</code>以外の型のメンバのみで、&quot;引数のないタプル&quot;のように考えられる(セクション<a href="chapters/./6-predefined-types-and-classes.html">6.1.5</a>を参照)。</p>
<div class="column">
<p><strong>変換:</strong> <em>(e)</em>は<em>e</em>と等しい。</p>
</div>
<a class="header" href="#数列" id="数列"><h2>数列</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>aexp</em></td><td>→</td><td><code>[</code> <em>exp<sub>1</sub></em> <code>[</code>, <em>exp<sub>2</sub></em><code>]</code> .. <code>[</code><em>exp<sub>3</sub></em><code>]</code> <code>]</code></td><td> </td></tr>
</tbody></table>
<p><strong>数列</strong> [<em>e<sub>1</sub></em>,<em>e<sub>2</sub></em> .. <em>e<sub>3</sub></em>]は型<em>t</em>の値のリストを表し、各<em>e<sub>i</sub></em>は型<em>t</em>を持ち、<em>t</em>は<code>Enum</code>クラスのインスタンスである。</p>
<div class="column">
<p><strong>変換:</strong> 数列はこれらの等式を満たす。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td>[ <em>e<sub>1</sub></em>.. ]                                              </td><td>=</td><td> <code>enumFrom</code> <em>e<sub>1</sub></em></td></tr>
<tr><td>[ <em>e<sub>1</sub></em>,<em>e<sub>2</sub></em>.. ]                       </td><td>=</td><td> <code>enumFromThen</code> <em>e<sub>1</sub></em> <em>e<sub>2</sub></em></td></tr>
<tr><td>[ <em>e<sub>1</sub></em>..<em>e<sub>3</sub></em> ]                        </td><td>=</td><td>  <code>enumFromTo</code> <em>e<sub>1</sub></em> <em>e<sub>3</sub></em></td></tr>
<tr><td>[ <em>e<sub>1</sub></em>,<em>e<sub>2</sub></em>..<em>e<sub>3</sub></em> ] </td><td>=</td><td> <code>enumFromThenTo</code> <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> <em>e<sub>3</sub></em></td></tr>
</tbody></table>
<p><code>enumForm</code>、<code>enumFormThen</code>、<code>enumFormTo</code>、<code>enumFormThenTo</code>はPrelude内で定義されている<code>Enum</code>クラスのクラスメソッドになる。</p>
</div>
<p>故に数列の意味論は型<em>t</em>のインスタンス宣言に完全に依存している。どの<code>Prelude</code>型が<code>Enum</code>型にあるか、そしてそれらの意味論についてのより詳しいことについてはセクション<a href="chapters/./6-predefined-types-and-classes.html">6.3.4</a>を参照すること。</p>
<a class="header" href="#リスト内包表記" id="リスト内包表記"><h2>リスト内包表記</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>aexp</em></td><td>→</td><td>[ <em>exp</em> | <em>qual<sub>1</sub></em> , … , <em>qual<sub>n</sub></em> ]</td><td>(list comprehension, <em>n</em> ≥ 1)</td></tr>
<tr><td><em>qual</em></td><td>→</td><td><em>pat</em> &lt;- <em>exp</em></td><td>(generator)</td></tr>
<tr><td>        </td><td>|</td><td><code>let</code> <em>decls</em></td><td>(local declaration)</td></tr>
<tr><td>        </td><td>|</td><td><em>exp</em></td><td>(boolean guard)</td></tr>
</tbody></table>
<p><strong>リスト内包表記</strong> は[ <em>e</em> | q<sub>1</sub>, …, q<sub>n</sub> ]、<em>n</em> ≥ 1形式を持ち、<em>q<sub>i</sub></em>修飾子は次のいずれかである。</p>
<ul>
<li>形式<em>p &lt;- e</em>の <strong>ジェネレータ</strong>  。<em>p</em>は型<em>t</em>のパターン(セクション<a href="#3.17">3.17</a>)であり、<em>e</em>は型<code>[t]</code>の式である。</li>
<li>生成された式eで、あるいは後方のブーリアンガードとジェネレータで使われる新しい定義を提供する <strong>ローカル束縛</strong> 。</li>
<li><strong>ブーリアンガード</strong>  。<code>Bool</code>型の任意の式を表すことができる。</li>
</ul>
<p>このようなリスト内包表記は修飾子リスト内のジェネレータのネストされた深さ優先探索の評価によって作成された連続した環境で<em>e</em>を評価することによって生成された要素のリストを返す。変数の束縛は通常のパターンマッチングルール(セクション<a href="%22#3.17%22">3.17</a>)に従って発生し、もし一致に失敗したら、その時はそのリストの要素は単純にスキップされる。従って、</p>
<pre><code class="language-hs">[ x |  xs   &lt;- [ [(1,2),(3,4)], [(5,4),(3,2)] ],  
      (3,x) &lt;- xs ]
</code></pre>
<p>リスト<code>[4,2]</code>を返す。もし修飾子がブーリアンガードなら、成功した前のパターンマッチのために<code>True</code>と評価しなけれないけない。通常通り、リスト内法表記における束縛は外部スコープの束縛をシャドーイングできる。例えば以下のようになる。</p>
<pre><code class="language-hs">[ x | x &lt;- x, x &lt;- x ] = [ z | y &lt;- x, z &lt;- y]
</code></pre>
<div class="column">
<p><strong>変換:</strong> リスト内包表記はこれらの等式を満たし、これらの等式はカーネルへの変換として使われる可能性がある。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td>[  <em>e</em> | <code>True</code> ]                      </td><td>=</td><td>[<em>e</em>]</td></tr>
<tr><td>[  <em>e</em> | <em>q</em> ]                           </td><td>=</td><td>[  <em>e</em> | <em>q</em>, <code>True</code> ]</td></tr>
<tr><td>[  <em>e</em> | <em>b</em>,  <em>Q</em>  ]             </td><td>=</td><td><code>if</code> <em>b</em> <code>then</code> [  <em>e</em> | <em>Q</em> ] <code>else</code> []</td></tr>
<tr><td>[  <em>e</em> | <em>p</em> &lt;- <em>l</em>,  <em>Q</em> ]</td><td>=</td><td><code>let</code> <code>ok</code> <em>p</em> = [  <em>e</em> | <em>Q</em> ]</td></tr>
<tr><td>                                                            </td><td> </td><td>     <code>ok</code> _ = []</td></tr>
<tr><td>                                                            </td><td> </td><td><code>in</code> <code>concatMap</code> <code>ok</code>  <em>l</em></td></tr>
<tr><td>[  <em>e</em> | <code>let</code> <em>decls</em>,  Q ]  </td><td>=</td><td><code>let</code> <em>decls</em> <code>in</code> [  <em>e</em> | <em>Q</em> ]</td></tr>
</tbody></table>
<p><em>e</em>は式にわたる範囲で、<em>p</em>はパターンにわたり、<em>l</em>はリスト値式にわたり、<em>b</em>はブーリアン式にわたり、<em>decls</em> は宣言リストにわたり、<em>q</em>は修飾子にわたり、<em>Q</em>は修飾子の列にわたる範囲をもつ。<code>ok</code>は新しい変数である。関数<code>concatMap</code>とブーリアン値<code>True</code>はPrelude内で定義されている。</p>
</div>
<p>リスト内法表記の変換で示した通り、letによって束縛された変数は最大限多相的な型を持つ一方で&lt;-によって束縛されたものはラムダ束縛であり、よって単相的になる。 (セクション<a href="chapters/./4-declarations-and-bindings.html">4.5.4</a>を参照).</p>
<a class="header" href="#let式" id="let式"><h2>Let式</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>lexp</em></td><td>→</td><td><code>let</code> <em>decls</em> <code>in</code> <em>exp</em></td><td> </td></tr>
</tbody></table>
<p><strong>let</strong> 式は一般的な形式<code><code>let</code> { <em>d<sub>1</sub></em> ; … ; <em>d<sub>n</sub></em> } <code>in</code> <em>e</em></code>を持ち、ネストされたレキシカルスコープをもつ相互再帰的な宣言のリストを導入する(<code>let</code>は他の言語で<code>letrc</code>としばしば呼ばれる)。宣言の範囲は式<em>e</em>と宣言の右側である。宣言は<a href="chapters/./4-declarations-and-bindings.html">4章</a>で説明される。パターン束縛のマッチは遅延され、暗黙的な<code>~</code>がこれらのパターンを反駁不可にする。 例えば、</p>
<pre><code class="language-hs">let (x,y) = undefined in e
</code></pre>
<p>は<code>x</code>または<code>y</code>が評価されるまでランタイムエラーをもたらさない。</p>
<div class="column">
<p><strong>変換:</strong> 式<code><code>let</code> { <em>d<sub>1</sub></em> ; … ; <em>d<sub>n</sub></em>} in <em>e<sub>0</sub></em></code>の動的な意味論は次の変換によって捕捉される。全ての型シグネチャを取り除いた後、それぞれの宣言<em>d<sub>i</sub></em>は<code><em>p<sub>i</sub></em> = <em>e<sub>i</sub></em></code>の形の等式へと変換される。<code>p<sub>i</sub></code>と<code><em>e<sub>i</sub></em></code>はセクション<a href="chapters/./4-declarations-and-bindings.html">4.4.3</a>での変換を使用する、各々のパターンと式である。一度この変換が終われば、次のような等式が成り立つ。この等式はカーネルへの変換として使われる場合がある。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td><code>let</code> {<em>p<sub>1</sub></em> = <em>e<sub>1</sub></em>;  ... ; <em>p<sub>n</sub></em> = <em>e<sub>n</sub></em>} <code>in</code> <em>e<sub>0</sub></em> </td><td>=</td><td> <code>let</code> (<code>~</code><em>p<sub>1</sub></em>, ... ,<code>~</code><em>p<sub>n</sub></em>) = (<em>e<sub>1</sub></em>, ... ,<em>e<sub>n</sub></em>) in <em>e<sub>0</sub></em></td></tr>
<tr><td><code>let</code> <em>p</em> = <em>e<sub>1</sub></em>  <code>in</code>  e<sub>0</sub>                                                                              </td><td>=</td><td> <code>case</code> <em>e<sub>1</sub></em> of <code>~</code><em>p</em> -&gt; <em>e<sub>0</sub></em></td></tr>
<tr><td>                                                                                                                                                          </td><td> </td><td>where no variable in <em>p</em> appears free in <em>e<sub>1</sub></em></td></tr>
<tr><td><code>let</code> <em>p</em> = <em>e<sub>1</sub></em>  <code>in</code>  <em>e<sub>0</sub></em>                                                                     </td><td>=</td><td><code>let</code> <em>p</em> = <code>fix</code> ( \ <code>~</code><em>p</em> -&gt; <em>e<sub>1</sub></em>) in <em>e<sub>0</sub></em></td></tr>
</tbody></table>
<p><code>fix</code>は最小不動点演算子である。反駁不可パターン<em>~p</em>の使用は注意すべきだ。この変換は静的な意味論を保存しない。なぜなら、<code>case</code>を使用すると束縛変数が完全な多相型へ型付けされなくなるからである。<code>let</code>式で束縛された静的な意味論はセクション<a href="chapters/./4-declarations-and-bindings.html">4.4.3</a>で説明される。</p>
</div>
<a class="header" href="#case式" id="case式"><h2>Case式</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>lexp</em></td><td>→</td><td><code>case</code> <em>exp</em> <code>of</code> { <em>alts</em> }</td><td> </td></tr>
<tr><td><em>alts</em></td><td>→</td><td><em>alt<sub>1</sub></em> ; … ; <em>alt<sub>n</sub></em></td><td>(<em>n</em> ≥ 1)</td></tr>
<tr><td> <em>alt</em></td><td>→</td><td><em>pat</em> -&gt; <em>exp</em> [<code>where</code> <em>decls</em>]</td><td> </td></tr>
<tr><td>        </td><td>|</td><td>   <em>pat</em> <em>gdpat</em> [<code>where</code> <em>decls</em>]</td></tr>
<tr><td>        </td><td>|</td><td>                </td><td>(empty alternative)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td> <em>gdpat</em></td><td>→</td><td><em>guards</em> -&gt; <em>exp</em> [ <em>gdpat</em> ]</td><td> </td></tr>
<tr><td><em>guards</em></td><td>→</td><td> <code>|</code> <em>guard<sub>1</sub></em>, …, <em>guard<sub>n</sub></em></td><td>(<em>n</em> ≥ 1)</td></tr>
<tr><td> <em>guard</em></td><td>→</td><td><em>pat</em> &lt;- <em>infixexp</em></td><td>(pattern guard)</td></tr>
<tr><td>          </td><td>|</td><td> <code>let</code> <em>decls</em>            </td><td>(local declaration)</td></tr>
<tr><td>          </td><td>|</td><td> <em>infixexp</em>               </td><td>(boolean guard)</td></tr>
</tbody></table>
<p><em>case</em> 式は一般的な形式<code>case <em>e</em> of { <em>p<sub>1</sub></em> <em>match<sub>1</sub></em> ; … ; <em>p<sub>n</sub></em> <em>match<sub>n</sub></em> }</code>を持つ。各<em>match<sub>i</sub></em>は一般的な形式</p>
<pre>
<code>| <em>gs<sub>i1</sub></em>    -> <em>e<sub>i1</sub></em>
…
| <em>gs<sub>imi</sub></em>   -> <em>e<sub>imi</sub></em>
where <em>decls<sub>i</sub></em>
</code></pre>
<p>( <strong>ガード</strong>  の構文ルールについて注目して欲しい。<code>|</code>は区切りを表す構文的なメタシンボルではなく終端記号である。)各選択子<em>p<sub>i</sub> match<sub>i</sub></em>はパターン<em>p<sub>i</sub></em>から成り、<em>match<sub>i</sub></em>と一致する。各マッチは順繰りにガード<em>gs<sub>ij</sub></em>と本体<em>e<sub>ij</sub></em>のペアの列から成り、代替となる全てのガードと式上の範囲での付加的な束縛(<em>decls<sub>i</sub></em>)に従う。</p>
<p><strong>ガード</strong>  は次の形式をの一つを持つ。</p>
<ul>
<li><strong>パターンガード</strong>  は形式<em>p</em> &lt;- <em>e</em>で、<em>p</em>は型<em>t</em>のパターンで、<em>e</em>は式の種類<em>t</em>である。もし、式<em>e</em>がパターン<em>p</em>に一致するなら成功し、パターンの束縛をその環境にもたらす。</li>
<li><strong>局地的束縛</strong>  は形式<code>let <em>decls</em></code>である。それらは常に成功し、その環境に<em>decls</em>と定義した名前をもたらす。</li>
<li><strong>ブーリアンガード</strong>  は<code>Bool</code>型の数式である。もし、式が<code>True</code>と評価するなら成功し、その環境に新しい名前をもたらさない。ブーリアンガード<em>g</em>はパターンガード<code>True &lt;- <em>g</em></code>に意味的に等しい。</li>
</ul>
<p>形式<code><em>pat</em> -&gt; <em>exp</em> where <em>decls</em></code>の代わりの以下の簡略記法が扱われる。</p>
<pre><code class="language-hs">pat | True -&gt; exp
where decls
</code></pre>
<p>ケース式は少なくとも1つの選択句を持たなければならず、各選択句は一つの実体を持たないといけない。各実体は同じ型を持たなければならず、式全体の型はその型になる。</p>
<p>ケース式は式<em>e</em>が個々の選択句に反するパターンマッチングによって評価される。その選択子は上から下へ連続的に試される。もし、<em>e</em>が選択句のパターンと一致したら、そのとき選択句のガード式は始めにパターンの一致の間に生成された束縛によって展開されたケース式の環境内で上から下へ連続的に試される。その時、<code>where</code>句内の<em>decls<sub>i</sub></em>によって、その選択句は関連付けられる。</p>
<p>各ガード式のためにコンマ区切りのガードは左から右へ連続的に試される。もしそのすべてに成功したなら、そのときは対応する式はガードによって生成された束縛で展開された環境で評価される。すなわち、(let句かパターンガードのいずれかを使った)ガードによって生成された束縛は続くガードと対応する式のスコープ内にある。もしあらゆるガードが失敗したら、その時はこのガード式は失敗し次のガード式を試す。</p>
<p>もし与えられた選択句のどのガード式も成功しなかったら、その時マッチングは次の選択句へ継続する。もしどの選択句も成功しなければ、そのときの結果は<code>⊥</code>となる。パターンマッチングはセクション<a href="%22#%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%83%9E%E3%83%83%E3%83%81%E3%83%B3%E3%82%B0%22">3.17</a>で説明され、ケース式の正式な意味論はセクション<a href="%22#%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%83%9E%E3%83%83%E3%83%81%E3%83%B3%E3%82%B0%E3%81%AE%E6%AD%A3%E5%BC%8F%E3%81%AA%E6%84%8F%E5%91%B3%E8%AB%96%22">3.17.3</a>で説明される。</p>
<p><strong>パースについての注意点</strong>  。以下の式は</p>
<pre><code class="language-hs">case x of { (a,_) | let b = not a in b :: Bool -&gt; a }
</code></pre>
<p>これを正しく構文解析するには用心しなければならない。ただ一つの曖昧さのない構文解析は、すなわち次のようにすることである。</p>
<pre><code class="language-hs">case x of { (a,_) | (let b = not a in b :: Bool) -&gt; a }
</code></pre>
<p>しかしながら、<code>Bool -&gt; a</code>というフレーズは型として構文的に正当であり、先読みが制限されているパーサーはこの選択に誤ってコミットする可能性があり、それゆえプログラムは拒否する。故に、プログラマーは型シグネチャで終わるガードを避けるように勧められる。これは実際に <strong>ガード</strong> が<em>exp</em>ではなく<em>infixexp</em>を含んでいる理由になる。</p>
<a class="header" href="#do式" id="do式"><h2>Do式</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td> <em>lexp</em></td><td>→</td><td><code>do</code> { <em>stmts</em> }</td><td>(do expression)</td></tr>
<tr><td><em>stmts</em></td><td>→</td><td><em>stmt<sub>1</sub></em> … <em>stmt<sub>n</sub></em> <em>exp</em> [<code>;</code>]</td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td> <em>stmt</em></td><td>→</td><td><em>exp</em> ;</td><td> </td></tr>
<tr><td>           </td><td>|</td><td><em>pat</em> &lt;- <em>exp</em> ;</td><td> </td></tr>
<tr><td>         </td><td>|</td><td><code>let</code> <em>decls</em> ;</td><td> </td></tr>
<tr><td>         </td><td>|</td><td><code>;</code>                       </td><td>(empty statement)</td></tr>
</tbody></table>
<p><em>do式</em>はモナドのプログラミングのためのより従来的な構文を提供する。それは以下のような式を許す。</p>
<pre><code class="language-hs">putStr &quot;x: &quot;    &gt;&gt;  
getLine         &gt;&gt;= \l -&gt;  
return (words l)
</code></pre>
<p>より、旧来の方法による書き方は次のものになる。</p>
<pre><code class="language-hs">do putStr &quot;x: &quot;  
   l &lt;- getLine  
   return (words l)
</code></pre>
<div class="column">
<p><strong>変換：</strong> Do式はこれらの等式を満たし、排除した空の<em>stmts</em>の後にカーネルの中への変換のように使われるかもしれない。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td><code>do</code> {<em>e</em>}                                     </td><td>=</td><td><em>e</em></td></tr>
<tr><td><code>do</code> {<em>e</em>;<em>stmts</em>}                      </td><td>=</td><td><em>e</em> &gt;&gt; <code>do</code> {<em>stmts</em>}</td></tr>
<tr><td><code>do</code> {<em>p</em> &lt;- e; <em>stmts</em>}                </td><td>=</td><td><code>let</code> <code>ok</code> <em>p</em> = <code>do</code> {<em>stmts</em>}</td></tr>
<tr><td>                                                                 </td><td> </td><td>  <code>ok</code> _ = <code>fail</code> &quot;...&quot;</td></tr>
<tr><td>                                                                 </td><td> </td><td> <code>in</code> <em>e<em> &gt;&gt;= <code>ok</code></td></tr>
<tr><td><code>do</code> {<code>let</code> <em>decls</em>; <em>stmts</em>}</td><td>=</td><td><code>let</code> <em>decls</em> <code>in</code> <code>do</code> {<em>stmts</em>}</td></tr>
</tbody></table>
<p>コンパイラが生成したエラーメッセージを表す省略記号<code>&quot;...&quot;</code>の部分は<code>fail</code>へ渡され、そして可能であればパターンマッチに失敗した場所を表示する。関数<code>&gt;&gt;</code>,<code>&gt;&gt;=</code>と<code>fail</code>はPreludeで定義されたクラス<code>Monad</code>の操作であり、<code>ok</code>は新しい識別子である。</p>
</div>
<p><code>do</code>の変換でも示したように、<code>let</code>に束縛された変数は完全に多相的な型をもつ一方で<code>&lt;-</code>によって定義された変数はラムダ束縛であり、ゆえに単相的である。</p>
<a class="header" href="#フィールドラベル付きのデータ型" id="フィールドラベル付きのデータ型"><h2>フィールドラベル付きのデータ型</h2></a>
<p>データ型の宣言はフィールドラベルを必要に応じて定義してもよい。(セクション<a href="chapters/./4-declarations-and-bindings.html">4.2.1</a>を参照)これらのフィールドラベルは構築、形式の選択、データ型全体の構造に依存した方法でのフィールドの更新することに使用される。</p>
<p>異なるデータ型は同じスコープの共通のフィールドラベルを共有することはできない。フィールドラベルはコンストラクタ内で高々一度だけ、使用することができる。しかしながら、データ型の中で、あるフィールドがすべてのコンストラクタ内で同じ型を持つときに限り1つのフィールドを複数のコンストラクタで使用することができる。最後の点については次が良い例である:</p>
<pre><code class="language-hs">data S = S1 { x :: Int } | S2 { x :: Int }   -- OK  
data T = T1 { y :: Int } | T2 { y :: Bool }  -- BAD
</code></pre>
<p>ここでの<code>s</code>は正当であるが<code>T</code>はそうではない。また<code>y</code>は後者では矛盾する型付けが与えられている。</p>
<a class="header" href="#フィールドセレクション" id="フィールドセレクション"><h3>フィールドセレクション</h3></a>
<table><thead><tr></tr></thead><tbody>
<tr><td>aexp</td><td>→</td><td>qvar</td></tr>
</tbody></table>
<p>フィールドラベルはセレクタ関数のように使用される。変数のように使われる際は、フィールドラベルはオブジェクトからフィールドを抽出する関数のように振る舞う。セレクタはトップレベルの束縛であり、よってローカル変数によってシャドーイングされる場合があるが、しかし他のトップレベルの束縛で同じ名前のものと衝突してはならない。この覆いはセレクタ関数にのみ影響を及ぼし、レコード作成(セクション<a href="%22#3.15.2%22">3.15.2</a>)及びに更新(セクション<a href="%22#3.15.3%22">3.15.3</a>)、フィールドラベルは通常の変数と混合されることはない。</p>
<div class="column">
<p><strong>変換:</strong> フィールドラベル<em>f</em>は次のようなセレクタ関数を生成する。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td>f x</td><td>=</td><td><code>case</code> x <code>of</code> { <em>C<sub>1</sub></em> <em>p<sub>11</sub></em> … <em>p<sub>1k</sub></em>  -&gt;  <em>e<sub>1</sub></em> ;… ; <em>C<sub>n</sub> p<sub>n1</sub></em> … <em>p<sub>nk</sub></em>  -&gt;  <em>e<sub>n</sub></em> }</td></tr>
</tbody></table>
<p><em>C<sub>1</sub> ... C<sub>n</sub></em>は全て<em>f</em>とラベルされたフィールドを含むデータ型のコンストラクタで、<em>p<sub>ij</sub></em>は<em>f</em>が<em>C<sub>i</sub></em>の要素の<em>j</em>番目、または<code>_</code>をラベルした時の<code>y</code>であり、<em>e<sub>i</sub></em>は<em>C<sub>i</sub></em>のフィールドが<em>f</em>または<code>undefined</code>のラベルを持つ時の<code>y</code>である。</p>
</div>
<a class="header" href="#フィールドラベルを用いた生成" id="フィールドラベルを用いた生成"><h3>フィールドラベルを用いた生成</h3></a>
<table><thead><tr></tr></thead><tbody>
<tr><td> <em>aexp</em></td><td>→</td><td><em>qcon</em> { <em>fbind<sub>1</sub></em> , … , <em>fbind<sub>n</sub></em> }</td><td>(labeled construction, <em>n</em> ≥ 0)</td></tr>
<tr><td><em>fbind</em></td><td>→</td><td><em>qvar</em> = <em>exp</em></td><td> </td></tr>
</tbody></table>
<p>ラベル付けされたフィールドを使うコンストラクタが値の生成に使われる場合があるが、その時には各コンポーネントは位置ではなく名前によって指定する。宣言リストの中で使われる中括弧とは異なりレイアウトの対象にならない。<code>{</code>と<code>}</code>の文字は明示しなければならない。(これはフィールドの更新、フィールドパターンにおいても正しい。)フィールドラベルを使用する構築は次の制約に応じる。</p>
<ul>
<li>指定されたコンストラクタで宣言されたフィールドラベルのみ言及してよい。</li>
<li>フィールドラベルは複数回言及してはならない。</li>
<li>言及されないフィールドは<code>⊥</code>で初期化される。</li>
<li>正格なフィールド(宣言された型のフィールドの接頭語に<code>!</code>が付けられている)が生成の際に省略された時はコンパイルエラーが発生する。厳格なフィールドはセクション<a href="chapters/./4-declarations-and-bindings.html">4.2.1</a>で説明される。</li>
</ul>
<p>式<code>F {}</code>は、<code>F</code>はデータコンストラクタであり、<em><code>F</code>がレコード構文により宣言されたかどうかに関わらず</em>、正当である(ただし<code>F</code>が正格フィールドを持たない時に限る。上の4番目の箇条書きを参照)。それは<code>F ⊥<sub>1</sub> … ⊥<sub>n</sub></code>を表し、<em>n</em>は<code>F</code>の引数の数である。</p>
<div class="column">
<p><strong>変換：</strong> <em>f = v</em>の束縛で、フィールド<em>f</em>は<em>v</em>でラベルする。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>C</em> { <em>bs</em> }</td><td>=</td><td><em>C</em> (<em>pick<sub>1</sub><sup>C</sup></em> <em>bs</em> <em><sub>undefined</sub></em>) … (<em>pick<sub>k</sub><sup>C</sup></em> <em>bs</em> <em>undefined</em>)</td></tr>
</tbody></table>
<p><em>k</em>は<em>C</em>の引数の数である。</p>
<p>補助関数<em>pick<sub>i</sub><sup>C</sup> bs d</em>は次にように定義される。</p>
<p>
もし、コンストラクタ<em>C</em>の<em>i</em>番目の要素がフィールドラベル<em>f</em>を持ち、<em>if f=v</em>は束縛された<em>bs</em>に表示されるなら、その時は<em>pick<sub>i</sub><sup>C</sup> bs d</em>は<em>v</em>である。言い換えると<em>pick<sub>i</sub><sup>C</sup> bs d</em>はデフォルト値<em>d</em>である。
</p>
</div>
<a class="header" href="#フィールドラベルを使用した更新" id="フィールドラベルを使用した更新"><h3>フィールドラベルを使用した更新</h3></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>aexp</em></td><td>→</td><td><em>aexp<sub>⟨qcon⟩</sub></em> { <em>fbind<sub>1</sub></em> , … , <em>fbind<sub>n</sub></em> }</td><td>(labeled update, <em>n</em> ≥ 1)</td></tr>
</tbody></table>
<p>フィールドラベルを使ったデータ型に所属する値は非破壊的に更新されるかもしれない。これは元々存在していた値を指定されたフィールドの値で書き換えた新しい値を生成する。更新は次の方法に制限される。</p>
<ul>
<li>全てのラベルは同じデータ型から取られなければいけない。</li>
<li>少なくともあるコンストラクタは更新の中で全ての言及されたラベルを定義しなければいけない。</li>
<li>2回以上言及されるラベルがあってはならない。</li>
<li>実行エラーは更新された値が全ての明記されたラベルを含まない時に発生する。</li>
</ul>
<div class="column">
<p><strong>変換:</strong> 以下は以前の<em>pick</em>の定義を使用する。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td>e { bs }</td><td>=</td><td><code>case</code> <em>e</em> <code>of</code></td></tr>
<tr><td>            </td><td> </td><td>    <em>C<sub>1</sub></em> <em>v<sub>1</sub></em> … <em>v<sub>k1</sub></em> -&gt; <em>C<sub>1</sub></em> (<em>pick<sub>1</sub><sup>C1</sup></em> <em>bs</em> <em>v<sub>1</sub></em>) … (<em>pick<sub>k 1</sub><sup>C1</sup></em> <em>bs</em> <em>v <sub>k1</sub></em>)</td></tr>
<tr><td>            </td><td> </td><td>      ...</td></tr>
<tr><td>            </td><td> </td><td>    <em>C<sub>j</sub></em> <em>v<sub>1</sub></em> … <em>v<sub>kj</sub></em> -&gt; <em>C<sub>j</sub></em> (<em>pick<sub>1</sub><sup>Cj</sup></em> <em>bs</em> <em>v<sub>1</sub></em>) … (<em>pick<sub>k j</sub><sup>Cj</sup></em> <em>bs</em> <em>v <sub>k<sub>j</sub></sub></em>)</td></tr>
<tr><td>            </td><td> </td><td>    _ -&gt; <code>error</code> &quot;Update error&quot;</td></tr>
</tbody></table>
<p><em>{ C<sub>1</sub>,...,C<sub>j</sub>}</em>は<em>bs</em>内の全てのラベルを含むコンストラクタの集合で、<em>ｋ<sub>i</sub></em>は<em>C<sub>i</sub></em>の引数の数である。</p>
</div>
<p>これはラベル付けされたフィールドを使用している例である。</p>
<pre><code class="language-hs">data T    = C1 {f1,f2 :: Int}  
          | C2 {f1 :: Int,  
                f3,f4 :: Char}
</code></pre>
<table><thead><tr><th>式</th><th>変換</th></tr></thead><tbody>
<tr><td> C1 {f1 = 3} </td><td> C1 3 <code>undefined</code> </td></tr>
<tr><td>  C2 {f1 = 1, f4 = 'A', f3 = 'B'} </td><td> C2 1 'B' 'A' </td></tr>
<tr><td> x {f1 = 1} </td><td> <code>case</code> x <code>of</code> C1 _ f2   -&gt; C1 1 f2</td></tr>
<tr><td>            </td><td>           C2 _ f3 f4 -&gt; C2 1 f3 f4 </td></tr>
</tbody></table>
<p>フィールド<code>f1</code>は両方の<code>T</code>のコンストラクタに共通である。この例では、フィールドラベル表記でコンストラクタを使った式をフィールドラベルを使わない同じコンストラクタを使った同値な式へと変換している。もし、<code>x {f2 = 1, f3 = 'x'}</code>のように、どのコンストラクタも、更新で使われたフィールドラベルの集合を定義していないのであれば、コンパイル時エラーという結果になるだろう。</p>
<a class="header" href="#式の型シグネチャ" id="式の型シグネチャ"><h2>式の型シグネチャ</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>exp</em></td><td>→</td><td><em>exp</em> <code>::</code> [<em>context</em> =&gt;] <em>type</em></td></tr>
</tbody></table>
<p><strong>式の型シグネチャ</strong> は形式<em>e :: t</em>を持つ。<em>e</em>は式で、<em>t</em>は型(セクション<a href="chapters/./4-declarations-and-bindings.html">4.1.2</a>)であり、それらは明示的に式を分類することに使用され、オーバーロード(セクション<a href="chapters/%E2%80%9D./4-declarations-and-bindings.html">4.1.2</a>を参照)するために曖昧な型付けを解決することに使われるかもしれない。式の値は<em>exp</em>の値である。通常の型シグネチャと同様に(セクション<a href="chapters/%E2%80%9D./4-declarations-and-bindings.html">4.4.1</a>を参照)、宣言された型は<em>exp</em>から導出可能な主要な型より具体的になるかもしれないが、主要な型より一般的なまたは同程度な型を与えることはエラーである。</p>
<div class="column">
<p><strong>変換：</strong></p>
<pre><code class="language-hs">e :: t = let { v :: t;  v = e } in v
</code></pre>
</div>
<a class="header" href="#パターンマッチング" id="パターンマッチング"><h2>パターンマッチング</h2></a>
<p><strong>パターン</strong>  はラムダ抽象や関数定義、パターン束縛、リスト内包表記、do式、case式内で現れる。しかしながら、はじめの5つは最終的にcase式に変換されるので、パターンマッチの意味論はcase式のときのみ定めれば十分である。</p>
<a class="header" href="#パターン" id="パターン"><h3>パターン</h3></a>
<p>パターンはこの構文を持つ。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>pat</em></td><td>→</td><td><em>lpat</em> <em>qconop</em> <em>pat</em></td><td>(infix constructor)</td></tr>
<tr><td>         </td><td>|</td><td><em>lpat</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>lpat</em></td><td>→</td><td><em>apat</em></td><td> </td></tr>
<tr><td>          </td><td>|</td><td><code>-</code> (<em>integer</em> | <em>float</em>)</td><td>(negative literal)</td></tr>
<tr><td>          </td><td>|</td><td><em>gcon</em> <em>apat<sub>1</sub></em> … <em>apat<sub>k</sub></em></td><td>(arity gcon  =  <em>k</em>, <em>k</em> ≥ 1)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>apat</em></td><td>→</td><td><em>var</em> [ <code>@</code> <em>apat</em>]</td><td>(as pattern)</td></tr>
<tr><td>          </td><td>|</td><td><em>gcon</em></td><td>(arity gcon  =  0)</td></tr>
<tr><td>          </td><td>|</td><td><em>qcon</em> { <em>fpat1</em> , … , <em>fpatk</em> }</td><td>(labeled pattern, <em>k</em> ≥ 0)</td></tr>
<tr><td>          </td><td>|</td><td><em>literal</em></td><td> </td></tr>
<tr><td>          </td><td>|</td><td><code>_</code>                       </td><td>(wildcard)</td></tr>
<tr><td>          </td><td>|</td><td>( <em>pat</em> )                     </td><td>(parenthesized pattern)</td></tr>
<tr><td>          </td><td>|</td><td>( <em>pat<sub>1</sub></em> , … , <em>pat<sub>k</sub></em> )</td><td>(tuple pattern, <em>k</em> ≥ 2)</td></tr>
<tr><td>          </td><td>|</td><td>[ <em>pat<sub>1</sub></em> , … , <em>pat<sub>k</sub></em> ]</td><td>(list pattern, <em>k</em> ≥ 1)</td></tr>
<tr><td>          </td><td>|</td><td><code>~</code> <em>apat</em></td><td>(irrefutable pattern)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>fpat</em></td><td>→</td><td><em>qvar</em> <code>=</code> <em>pat</em></td><td> </td></tr>
</tbody></table>
<p>コンストラクタの引数の数はそれに関係するサブパターンの数と一致しなければいけない。部分的に適用されるコンストラクタに反して一致することはできない。</p>
<p>全てのパターンは <strong>線形</strong> でなければならない。変数は2回以上現れないかもしれない。例として、この定義は不正である。</p>
<pre><code class="language-hs">f (x,x) = x     -- ILLEGAL; x used twice in pattern
</code></pre>
<p>形式<em>var@pat</em>のパターンは<em>as-patterns</em>と呼ばれ、<em>var</em>を<em>pat</em>によってマッチされた値に付ける名前として使うことができる。例えば以下のものは、</p>
<pre><code class="language-hs">case e of { xs@(x:rest) -&gt; if x==0 then rest else xs }
</code></pre>
<p>は次のものと等しい。</p>
<pre><code class="language-hs">let { xs = e } in  
  case xs of { (x:rest) -&gt; if x==0 then rest else xs }
</code></pre>
<p>形式<code>_</code>のパターンは <strong>ワイルドカード</strong> であり、パターンのいくつかの部分が右手側で参照されない時に便利である。それは他の場所で使われない識別子がその場所に置かれているかのようである。例えば、以下は、</p>
<pre><code class="language-hs">case e of { [x,_,_]  -&gt;  if x==0 then True else False }
</code></pre>
<p>は次のものと等しい。</p>
<pre><code class="language-hs">case e of { [x,y,z]  -&gt;  if x==0 then True else False }
</code></pre>
<a class="header" href="#パターンマッチングの非形式的の意味論" id="パターンマッチングの非形式的の意味論"><h3>パターンマッチングの非形式的の意味論</h3></a>
<p>パターンは値に対してマッチが行われる。パターンマッチを行おうとした場合、次の3つのいずれかの結果を得る。 <strong>失敗</strong> かもしれない、 <strong>成功</strong> かもしれず、その時はパターン内の各変数に束縛を返す、 <strong>分岐する</strong> かもしれない(例:<code>⊥</code>を返す)。パターンマッチングは次のルールによって外から内へ、左から右へ進行する。</p>
<ol>
<li>
<p>値<em>v</em>に対してマッチするパターン<em>var</em>のマッチングは常に成功し、<em>var</em>を<em>v</em>に束縛する。</p>
</li>
<li>
<p>値<em>v</em>に対してマッチするパターン<em>~apat</em>のマッチングは常に成功する。もし<em>v</em>に対してマッチする<em>apat</em>のマッチングが別の方法で成功するならば、<em>apat</em>内の束縛されていない変数は適切な値に束縛される。<em>v</em>に対してマッチする<em>apat</em>のマッチングが失敗または分岐するなら<em>⊥ </em>に束縛される(束縛は評価を <strong>ほのめかさない</strong> )。
<br><br>
運用上、これはある<em>apat</em>内の変数が使われるまで、パターン<em>~apat</em>が何とも一致しないことを意味する。その時点でパターン全体はその値に対してマッチし、もし一致が失敗または分岐するなら、全体の計算を行う。</p>
</li>
<li>
<p>あらゆる値に対してマッチするワイルドパターン<code>_</code>のマッチングは常に成功し、束縛は行われない。</p>
</li>
<li>
<p>値に対してマッチするパターン<em>con pat</em>のマッチングは、<em>con</em>は<code>newtype</code>によって定義されたコンストラクタである、以下の項目でその値に依存する。</p>
<ul>
<li>もし値が形式<em>con v</em>であるなら、その時<em>pat</em>は<em>v</em>に対してマッチされる。</li>
<li>もし値が<code>⊥</code>なら、その時<em>pat</em>は<code>⊥</code>に対してマッチする。</li>
</ul>
<p>すなわち<code>newtype</code>と関連するコンストラクタが値の型を変更することのみに務める。</p>
</li>
<li>
<p>値に対しての<em>con pat<sub>1</sub> ... pat<sub>n</sub></em>のマッチングは、<em>con</em>は<code>data</code>によって定義されるコンストラクタである、依存するその値に依存する。</p>
<ul>
<li>もし値が形式<em>con pat<sub>1</sub> ... pat<sub>n</sub></em>であるなら、サブパターンはそのデータ値の要素に対して左から右へ一致される。もし、全てのマッチングが成功したなら、マッチング全体は成功し、はじめの失敗または分岐はマッチング全体を各々、失敗または分岐へともたらす。</li>
<li>もし値が形式<em>con' v<sub>1</sub> ... v<sub>m</sub></em>であるなら、<em>con</em>は<em>con'</em>への異なるコンストラクタである、そのマッチングは失敗する。</li>
<li>もし値が<code>⊥</code>なら、そのマッチングは分岐する。</li>
</ul>
</li>
<li>
<p>ラベル付きフィールドを使ったコンストラクタに対してのマッチングはそのフィールドがフィールドリスト内で指定された順序で照合されることを除いて、通常のコンストラクタパターンのマッチングと同じである。全てのリストされたフィールドはコンストラクタによって宣言されなければならず、フィールドは2回以上指定されないかもしれない。パターンによって指定されたフィールドは無視される(<code>_</code>に対して一致する)。</p>
</li>
<li>
<p>値<em>v</em>対する数値、文字、文字列リテラルパターン<em>k</em>のマッチングはもし、<em>v == k</em>なら成功する。<code>==</code>はパターンの型を元にオーバロードされる。マッチングはもしこのテストが分岐するなら分岐する。
<br><br>
数値リテラルの解釈はまさにセクション<a href="%22#3.2%22">3.2</a>で記載のとおりである。即ち、オーバロードされた関数<code>fromInteger</code>または<code>fromRational</code>は(それぞれ)適切な型へ変換することによって<code>Integer</code>または<code>Rational</code>リテラルに適用される。</p>
</li>
</ol>
<p>静的型の制約(例えば、文字とbooleanを一致させる静的なエラー)は別として、次の静的クラスの制約は保持する。</p>
<ul>
<li>整数リテラルパターンはクラス<code>Num</code>の値とのみ照合できる。</li>
<li>浮動小数点リテラルパターンはクラス<code>Factional</code>の値とのみ照合できる。</li>
</ul>
<p>2種類のパターンの区別することはしばしば有用である。 <strong>反駁できない</strong> パターンの照合は厳密ではなく、そのパターンはもし、照合された値が<code>⊥</code>なら一致する。 <strong>反駁できる</strong> パターンは厳密であり、その一致される値が<code>⊥</code>なら分岐する。反駁できないパターンは次のものである。変数やワイルドカード、<em>N</em>が<code>newtype</code>と<em>apat</em>によって定義されたコンストラクタ<em>N apat</em>は反駁できず(セクション<a href="chapters/./4-declarations-and-bindings.html">4.2.3</a>)、<em>var@apat</em>の<em>apat</em>は反駁できない、または形式<em>~apat</em>(<em>apat</em>が反駁できないかどうか)である。他の全てのパターンは反駁できる。</p>
<p>ここにいくつかの例をだす。</p>
<ol>
<li>
<p>もし、パターン<code>['a','b']</code>が<code>['x',⊥]</code>と一致されるなら、その時、<code>'a'</code>は<code>x</code>との一致に <strong>失敗し</strong>  、その結果は失敗と一致する。しかし、もし<code>['a','b']</code>が<code>[⊥,'x']</code>と一致されるなら、その時、<code>'a'</code>と<code>⊥</code>を一致するよう試みることは <strong>分岐</strong> と一致することをもたらす。</p>
</li>
<li>
<p>これらの例は反駁できるものとできないもののマッチングの実演である。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td>(\ ~(x,y) -&gt; 0) ⊥</td><td>⇒</td><td>0</td></tr>
<tr><td>(\  (x,y) -&gt; 0) ⊥</td><td>⇒</td><td>⊥</td></tr>
<tr><td> </td><td> </td><td> </td></tr>
<tr><td>(\ ~[x] -&gt; 0) []</td><td>⇒</td><td>0</td></tr>
<tr><td>(\ ~[x] -&gt; x) []</td><td>⇒</td><td>⊥</td></tr>
<tr><td> </td><td> </td><td> </td></tr>
<tr><td>(\ ~[x,~(a,b)] -&gt; x) [(0,1),⊥]</td><td>⇒</td><td>(0,1)</td></tr>
<tr><td>(\ ~[x, (a,b)] -&gt; x) [(0,1),⊥]</td><td>⇒</td><td>⊥</td></tr>
<tr><td> </td><td> </td><td> </td></tr>
<tr><td>(\  (x:xs) -&gt; x:x:xs) ⊥</td><td>⇒</td><td>⊥</td></tr>
<tr><td>(\ ~(x:xs) -&gt; x:x:xs) ⊥</td><td>⇒</td><td>⊥:⊥:⊥</td></tr>
</tbody></table>
</li>
<li>
<p>次の宣言を考えてほしい。</p>
<pre><code class="language-hs">newtype N = N Bool  
data    D = D !Bool
</code></pre>
<p>これらの例は<code>data</code>と<code>newtype</code>によって定義された型においてのパターンマッチングの違いを説明する。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td>(\  (N True) -&gt; True) ⊥</td><td>⇒</td><td>⊥</td></tr>
<tr><td>(\  (D True) -&gt; True) ⊥</td><td>⇒</td><td>⊥</td></tr>
<tr><td>(\ ~(D True) -&gt; True) ⊥</td><td>⇒</td><td>True</td></tr>
</tbody></table>
<p>追加の例はセクション<a href="chapters/./4-declarations-and-bindings.html">4.2.3</a>で見つかるだろう。</p>
</li>
</ol>
<p>関数内のcase式内の最上位パターンと最上位パターンの集合またはパターン束縛は0以上の <strong>ガード</strong> に関係する持つかもしれない。ガードの構文と意味論についてはセクション<a href="%22#3.13%22">3.13</a>を参照してもらいたい。</p>
<p>ガード意味論は関数またはcase式の厳密な特徴への影響を持つ。特に、他の反駁できないパターンがガードのために評価されるかもしれない。例えば、次の</p>
<pre><code class="language-hs">f :: (Int,Int,Int) -&gt; [Int] -&gt; Int  
f ~(x,y,z) [a] | (a == y) = 1
</code></pre>
<p><code>a</code>と<code>y</code>の両方はガードの<code>==</code>によって評価される。</p>
<a class="header" href="#パターンマッチングの正式な意味論" id="パターンマッチングの正式な意味論"><h3>パターンマッチングの正式な意味論</h3></a>
<p>case式を除くすべてのパターンマッチの意味論は、パターンマッチの構成と<code>case</code>式との間を関連付ける等式を与えることで定められる( <strong>訳注</strong> : パターンマッチの意味論は一旦case式を使って定義し、そのあとcase式の意味論に従って処理を行う)。<code>case</code>式の意味論自体は図<a href="%22#figure-3.1%22">3.1</a>、<a href="#figure-3.3">3.3</a>の、一連の識別子のように順番に与えられる。どんな実装でもこれらの識別子を保持するために振る舞わなければならず、かなり非効率的なコードを生成することから、それはそれらを直接使用することは期待されない。</p>
<p><a name="figure-3.1"></a></p>
<table class="fbox">
<tbody>
 <tr>
  <td class="code-number">(a)</td>
  <td><pre>
<code>case <em>e</em> of { alts } = (\v -> case <em>v</em> of { alts }) <em>e</em>
where <em>v</em> is a new variable</code></pre>
 </td>
 </tr>
 <tr>
  <td class="code-number">(b)</td>
  <td><pre>
<code>case  <em>v</em> of {  <em>p</em> <sub>1</sub>  match<sub>1</sub>;  … ; <em>p<sub>n</sub></em>  match<sub>n</sub> }
=  case <em>v</em> of { <em>p<sub>1</sub></em>  match<sub>1</sub> ;
               _  -> … case <em>v</em> of {
                         <em>p<sub>n</sub></em>  match<sub>n</sub> ;
                         _  -> error "No match" }…}
where each match<sub>i</sub> has the form:
 | <em>gs<sub>i,1</sub></em>  -> <em>e<sub>i,1</sub></em> ; … ; | <em>gs<sub>i,m<sub>i</sub></sub></em> -> <em>e<sub>i,m<sub>i</sub></sub></em> where { <em>decls</em><sub>i</sub> } </code></pre>
 </td>
 </tr>
 <tr>
  <td class="code-number">(c)</td>
  <td><pre>
<code>case <em>v</em> of { <em>p</em> | <em>gs<sub>1</sub></em> -> <em>e<sub>1</sub></em> ; …
             | <em>gs<sub>n</sub></em> -> <em>e<sub>n</sub></em> where { <em>decls</em> }
            _     -> <em>e′</em> }
= case <em>e′</em> of { <em>y</em> ->
   case <em>v</em> of {
     <em>p</em> -> let { <em>decls</em> } in
          case () of {
            () | <em>gs<sub>1</sub></em> -> <em>e<sub>1</sub></em>;
            _ -> … case () of {
                       () | <em>gs<sub>n</sub><em> -> <em>e<sub>n</sub></em>;
                       _  -> <em>y</em> } … }
     _ -> <em>y</em> }}
where <em>y</em> is a new variable</code></pre>
 </td>
 </tr>
 <tr>
 <td class="code-number">(d)</td>
 <td><pre>
<code>case <em>v</em> of { ~p -> <em>e</em>; _ -> <em>e′</em> }
= (\x<sub>1</sub> … x<sub>n</sub> -> <em>e</em> ) (case <em>v</em> of { p-> x<sub>1</sub> })… (case <em>v</em> of { <em>p</em> -> x<sub>n</sub>})
where x<sub>1</sub>,…,x<sub>n</sub> are all the variables in p</code></pre>
 </td>
 </tr>
 <tr>
 <td class="code-number">(<em>e</em>)</td>
 <td><pre>
<code>case <em>v</em> of { x@<em>p</em> -> <em>e</em>; _ -> <em>e′</em> }
=  case <em>v</em> of { <em>p</em> -> ( \ x -> <em>e</em> ) <em>v</em> ; _ -> <em>e′</em> }</code></pre>
 </td>
 </tr>
 <tr>
 <td class="code-number">(f)</td>
 <td><pre>
<code>case <em>v</em> of { _ -> <em>e</em>; _ -> <em>e′</em> } = <em>e</em> </code></pre>
 </td>
 </tr>
</tbody>
</table>
<p><strong>図 3.1:</strong> case式の意味論、パート1</p>
<div class="separator"></div>
<div class="separator"></div>
<p><a name="figure-3.2"></a></p>
<table class="fbox">
<tbody>
 <tr>
  <td class="code-number">(g)</td>
  <td><pre><code>case <em>v</em> of { <em>K</em> p<sub>1</sub>…p<sub>n</sub> -> <em>e</em>; _ -> <em>e′</em> }
    = case <em>v</em> of {
         <em>K</em> x<sub>1</sub>…x<sub>n</sub> -> case x<sub>1</sub> of {
                        <em>p<sub>1</sub></em> -> … case xn of { <em>p<sub>n</sub></em> -> <em>e</em> ; _ -> <em>e′</em> } …
                        _  -> <em>e′</em> }
         _ -> <em>e′</em> }
    at least one of <em>p<sub>1</sub></em>,…,<em>p<sub>n</sub></em> is not a variable; x<sub>1</sub>,…,x<sub>n</sub> are new variables</code></pre>
 </td>
 </tr>
 <tr>
  <td class="code-number">(h)</td>
  <td><pre><code>case <em>v</em> of { <em>k</em> -> <em>e</em>; _ -> <em>e′</em> } = if (v==k) then <em>e</em> else <em>e′</em>
    where <em>k</em> is a numeric, character, or string literal</code></pre>
 </td>
 </tr>
 <tr>
  <td class="code-number">(i)</td>
  <td><pre><code>case <em>v</em> of { x -> <em>e</em>; _ -> <em>e′</em> } = case <em>v</em> of { x -> <em>e</em> }</code></pre>
 </td>
 </tr>
 <tr>
 <td class="code-number">(j)</td>
 <td><pre><code>case <em>v</em> of { x -> <em>e</em> } = ( \ x -> <em>e</em> ) <em>v</em> </code></pre>
 </td>
 </tr>
 <tr>
 <td class="code-number">(k)</td>
 <td><pre><code>case <em>N</em> <em>v</em> of { <em>N</em> <em>p</em> -> <em>e</em>; _ -> <em>e′</em> }
    = case <em>v</em> of { <em>p</em> -> <em>e</em>; _ -> <em>e′</em> }
    where <em>N</em> is a newtype constructor </code></pre>
 </td>
 </tr>
 <tr>
 <td class="code-number">(l)</td>
 <td><pre><code>case ⊥ of { <em>N</em> <em>p</em> -> <em>e</em>; _ -> <em>e′</em> } = case ⊥ of { <em>p</em> -> <em>e</em> }
    where <em>N</em> is a newtype constructor </code></pre>
 </td>
 </tr>
 <tr>
 <td class="code-number">(m)</td>
 <td><pre><code>case  <em>v</em>  of {  <em>K</em>  { <em>f<sub>1</sub></em>  =  <em>p<sub>1</sub></em>  ,  <em>f<sub>2</sub></em>  =  <em>p<sub>2</sub></em>  , … } ->  <em>e</em> ; _ ->  <em>e′</em> }
    =  case <em>e′</em> of {
        <em>y</em> ->
        case  <em>v</em>  of {
          <em>K</em>  {  <em>f<sub>1</sub></em>  =  <em>p<sub>1</sub></em>  } ->
                case  <em>v</em>  of { <em>K</em>  { <em>f<sub>2</sub></em>  =  <em>p<sub>2</sub></em>  , …  } ->  <em>e</em> ; _ ->  <em>y</em>  };
                _ ->  <em>y</em>  }}
    where <em>f<sub>1</sub></em>, <em>f<sub>2</sub></em>, … are fields of constructor <em>K</em>; <em>y</em> is a new variable </code></pre>
 </td>
 </tr>
 <tr>
 <td class="code-number">(n)</td>
 <td><pre><code>case  <em>v</em>  of {  <em>K</em>  { f  =  <em>p</em> } ->  <em>e</em> ; _ ->  <em>e′</em> }
  = case  <em>v</em>  of {
       <em>K</em> <em>p<sub>1</sub></em> … <em>p<sub>n</sub></em>  ->  <em>e</em> ; _ ->  <em>e′</em> }
  where <em>p<sub>i</sub></em> is <em>p</em> if f labels the ith component of <em>K</em>, _ otherwise </code></pre>
 </td>
 </tr>
 <tr>
 <td class="code-number">(o)</td>
 <td><pre><code>case  <em>v</em>  of {  <em>K</em>  {} ->  <em>e</em> ; _ ->  <em>e′</em> }
  = case  <em>v</em>  of {
       <em>K</em> _ … _ ->  <em>e</em> ; _ ->  <em>e′</em> }</code></pre>
 </td>
 </tr>
 <tr>
 <td class="code-number">(p)</td>
 <td><pre><code>case (K′ <em>e<sub>1</sub></em> … <em>e<sub>m</sub></em>) of { <em>K</em> x<sub>1</sub> … x<sub>n</sub> -> <em>e</em>; _ -> <em>e′</em> } = <em>e′</em>
  where <em>K</em> and <em>K′</em> are distinct data constructors of arity <em>n</em> and m, respectively</code></pre>
 </td>
 </tr>
 <tr>
 <td class="code-number">(q)</td>
 <td><pre><code>case (K <em>e<sub>1</sub></em> … <em>e<sub>n</sub></em>) of { <em>K</em> x<sub>1</sub> … x<sub>n</sub> -> <em>e</em>; _ -> <em>e′</em> }
  = (\x<sub>1</sub> … x<sub>n</sub> -> <em>e</em>) <em>e<sub>1</sub></em> … <em>e<sub>n</sub></em>
  where <em>K</em> is a data constructor of arity <em>n</em> </code></pre>
 </td>
 </tr>
 <tr>
 <td class="code-number">(r)</td>
 <td><pre><code>case ⊥ of { <em>K</em> x<sub>1</sub> … x<sub>n</sub> -> <em>e</em>; _ -> <em>e′</em> } =  ⊥
  where <em>K</em> is a data constructor of arity <em>n</em></code></pre>
 </td>
 </tr>
</tbody>
</table>
<p><strong>図 3.2:</strong> case式の意味論、パート2</p>
<div class="separator"></div>
<div class="separator"></div>
<p><a name="figure-3.3"></a></p>
<table class="fbox">
<tbody>
<tr>
 <td class="code-number">(s)</td>
 <td><pre><code>case () of { () | <em>g<sub>1</sub></em>, …, <em>g<sub>n</sub></em> -> <em>e</em>; _ -> <em>e′</em> }
= case () of {
     () | <em>g<sub>1</sub></em> -> … case () of {
                    () | <em>g<sub>n</sub></em> -> <em>e</em>;
                    _ -> <em>e′</em> } …
     _ -> <em>e′</em> }
 where <em>y</em> is a new variable </code></pre>
</td>
</tr>
 <td class="code-number">(t)</td>
 <td><pre><code>case() of { () | <em>p</em> <- <em>e<sub>0</sub></em> -> <em>e</em>; _ -> <em>e′</em> }
= case <em>e</em><sub>0</sub> of { <em>p</em> -> <em>e</em>; _ -> <em>e′</em> }</code></pre>
</td>
</tr>
<tr>
<td class="code-number">(u)</td>
<td><pre><code>case () of { () | let <em>decls</em> -> <em>e</em>; _ -> <em>e′</em> }
= let <em>decls</em> in <em>e</em> </code></pre>
</td>
</tr>
<tr>
 <td class="code-number">(v)</td>
 <td><pre><code>case () of { () | <em>e<sub>0</sub></em> -> <em>e</em>; _ -> <em>e′</em> }
  = if <em>e<sub>0</sub></em> then <em>e</em> else <em>e′</em> </code></pre>
</td>
</tr>
</tbody>
</table>
<p><strong>図 3.3:</strong> case式の意味論、パート3</p>
<div class="separator"></div>
<p>図<a href="%22#figure-3.1%22">3.1</a>-<a href="%22#figure-3.3%22">3.3</a>の<em>e, e'</em>と<em>e<sub>i</sub></em>は式で、<em>g<sub>i</sub></em>と<em>gs<sub>i</sub></em>はガードと各々のガードの並びであり、<em>p</em>と<em>p<sub>i</sub></em>はパターン、<em>v, x, x<sub>i</sub></em>は変数、<em>K,K'</em>は代数的データ型<code>(data)</code>コンストラクタ(タプルコンストラクタを含む)で、<em>N</em>は<code>newtype</code>コンストラクタである。</p>
<p>ルール(b)は実際にガードを含むかどうかにはかかわらず、一般的な表層ソース言語の<code>case</code>式に適合するものである。もしガードが書かれていなければ、その時、<code>True</code>が形式<em>match<sub>i</sub></em>内のガード<em>gs<sub>i,j</sub></em>に代用される。各々の識別子はもっと簡単な形式へと<code>case</code>式の結果を操作する。</p>
<p>図<a href="%22#figure-3.2%22">3.2</a>のルール(h)はオーバロードされた<code>==</code>演算子を起動し、パターンマッチングの意味をオーバーロードされた定数に対して定義するというルールである。</p>
<p>これらの識別子は静的な意味論を全て保存する。ルール(d)、(e)、(j)、(q)は<code>let</code>ではなくラムダを使っていて、これは<code>case</code>によって束縛された変数が単相型ということを示す(セクション<a href="chapters/./4-declarations-and-bindings.html">4.1.4</a>を参照)。</p>
<a class="header" href="#宣言と束縛" id="宣言と束縛"><h1>宣言と束縛</h1></a>
<p>この章では、Haskellの <strong>宣言</strong> の構文と簡略した意味論を説明する。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>module</em></td><td> → </td><td><code>module</code> <em>modid</em> [<em>exports</em>] <code>where</code> <em>body</em></td><td> </td></tr>
<tr><td>      </td><td>|</td><td><em>body</em></td><td> </td></tr>
<tr><td>  <em>body</em></td><td> → </td><td>{ <em>impdecls</em> ; <em>topdecls</em> }</td><td> </td></tr>
<tr><td>      </td><td>|</td><td>{ <em>impdecls</em> }</td><td> </td></tr>
<tr><td>      </td><td>|</td><td>{ <em>topdecls</em> }</td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>topdecls</em></td><td> → </td><td><em>topdecl<sub>1</sub></em> ; … ; <em>topdecl<sub>n</sub></em></td><td>(<em>n</em> ≥ 1)</td></tr>
<tr><td> <em>topdecl</em></td><td> → </td><td><code>type</code> <em>simpletype</em> = <em>type</em></td><td> </td></tr>
<tr><td>        </td><td>|</td><td><code>data</code> [<em>context</em> =&gt;] <em>simpletype</em> [= <em>constrs</em>] [<em>deriving</em>]</td><td> </td></tr>
<tr><td>        </td><td>|</td><td><code>newtype</code> [<em>context</em> =&gt;] <em>simpletype</em> = <em>newconstr</em> [<em>deriving</em>]</td><td> </td></tr>
<tr><td>        </td><td>|</td><td><code>class</code> [<em>scontext</em> =&gt;] <em>tycls</em> <em>tyvar</em> [<code>where</code> <em>cdecls</em>]</td><td> </td></tr>
<tr><td>        </td><td>|</td><td><code>instance</code> [<em>scontext</em> =&gt;] <em>qtycls</em> <em>inst</em> [<code>where</code> <em>idecls</em>]</td><td> </td></tr>
<tr><td>        </td><td>|</td><td><code>default</code> (<em>type<sub>1</sub></em> , … , <em>type<sub>n</sub></em>)</td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td>        </td><td>|</td><td><code>foreign</code> <em>fdecl</em></td><td> </td></tr>
<tr><td>        </td><td>|</td><td><em>decl</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td>  <em>decls</em></td><td> → </td><td>{ <em>decl<sub>1</sub></em> ; … ; <em>decl<sub>n</sub></em> }</td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td>   <em>decl</em></td><td> → </td><td><em>gendecl</em></td><td> </td></tr>
<tr><td>       </td><td>|</td><td>(<em>funlhs</em> | <em>pat</em>) <em>rhs</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td> <em>cdecls</em></td><td> → </td><td>{ <em>cdecl<sub>1</sub></em> ; … ; <em>cdecl<sub>n</sub></em> }</td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td>  <em>cdecl</em></td><td> → </td><td><em>gendecl</em></td><td> </td></tr>
<tr><td>       </td><td>|</td><td>(<em>funlhs</em> | <em>var</em>) <em>rhs</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td> <em>idecls</em></td><td> → </td><td>{ <em>idecl<sub>1</sub></em> ; … ; <em>idecl<sub>n</sub></em> }</td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td>  <em>idecl</em></td><td> → </td><td>(<em>funlhs</em> | <em>var</em>) <em>rhs</em></td><td> </td></tr>
<tr><td>       </td><td>|</td><td>  </td><td>(empty)</td></tr>
<tr><td><em>gendecl</em></td><td>→</td><td><em>vars</em> :: [<em>context</em> <code>=&gt;</code>] <em>type</em></td><td>(type signature)</td></tr>
<tr><td>       </td><td>|</td><td><em>fixity</em> [<em>integer</em>] <em>ops</em></td><td>(fixity declaration)</td></tr>
<tr><td>       </td><td>|</td><td>  </td><td>(empty declaration)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td>    <em>ops</em></td><td>→</td><td><em>op<sub>1</sub></em> , … , <em>op<sub>n</sub></em></td><td>(<em>n</em> ≥ 1)</td></tr>
<tr><td>   <em>vars</em></td><td>→</td><td><em>var<sub>1</sub></em> , … , <em>var<sub>n</sub></em></td><td>(<em>n</em> ≥ 1)</td></tr>
<tr><td> <em>fixity</em></td><td>→</td><td><code>infixl</code> | <code>infixr</code> | <code>infix</code></td><td> </td></tr>
</tbody></table>
<p>構文的カテゴリ<em>topdecls</em>に属する宣言はHaskellモジュール(<a href="chapters/./5-modules.html">5章</a>)の最上位のみ許す一方で <em>decls</em>は最上位またはネストされたスコープのいずれかで使ってもよい(例えば、<code>let</code>か<code>where</code>の内で<em>topdecls</em>を構築する)。</p>
<p>説明のため、<code>type</code>と<code>newtype</code>、<code>data</code>宣言からなるユーザー定義のデータ型(セクション<a href="#a%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E5%AE%9A%E7%BE%A9%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B">4.2</a>)と<code>class</code>と<code>instance</code>、<code>default</code>宣言からなる型クラスとオーバーロード(セクション<a href="#a%E5%9E%8B%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%A8%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AD%E3%83%BC%E3%83%89">4.3</a>)、値束縛と型シグネチャ、固定の宣言からなるネストされた宣言(セクション<a href="#a%E3%83%8D%E3%82%B9%E3%83%88%E3%81%95%E3%82%8C%E3%81%9F%E5%AE%A3%E8%A8%80">4.4</a>)の3つのグループに宣言を分割する。</p>
<p>haskellは(整数や浮動小数点数のような)&quot;ハードウェアで実現された&quot;であるいくつかのプリミティブなデータ型を持つ。しかし、多くの&quot;ビルドイン&quot;なデータ型は通常のHaskellコードによって定義されていて、通常<code>type</code>や<code>data</code>宣言に使われる。これらの&quot;ビルドイン&quot;のデータ型はセクション<a href="chapters/./6-predefined-types-and-classes.html#a%E6%A8%99%E6%BA%96Haskell%E5%9E%8B">6.1</a>で詳細に説明される。</p>
<a class="header" href="#型とクラスの概要" id="型とクラスの概要"><h2>型とクラスの概要</h2></a>
<p>Haskellは静的型意味論<a href="chapters/../bibliography.html">4</a>,<a href="chapters/../bibliography.html">6</a>を提供するために伝統的なHindley-Milner多相型システムを使用するが、その型システムは構造化された手法にオーバーロード関数を導入するために提供する <strong>型クラス</strong> (または <strong>クラス</strong> )で拡張されている。</p>
<p><code>class</code>宣言(セクション<a href="#a%E3%82%AF%E3%83%A9%E3%82%B9%E5%AE%A3%E8%A8%80">4.3.1</a>)は新しい <strong>型クラス</strong> とあらゆるそのクラスのインスタンスの型によってもサポートされなければいけないオーバーロードされた操作を導入する。<code>instance</code>宣言(セクション<a href="#%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9%E5%AE%A3%E8%A8%80">4.3.2</a>)は型がクラスの <strong>インスタンス</strong> であり、名付けられた型でインスタンス化されるオーバーロードされたオペレーション、クラスメソッドと呼ばれる、の定義を含むということを宣言する。</p>
<p>例えば、型<code>Int</code>と<code>Float</code>で操作<code>(+)</code>と<code>negate</code>をオーバーロードしたいと考えたとしよう。<code>Num</code>と呼ばれる新しい型クラスを導入する。</p>
<pre><code class="language-hs">class Num a  where          -- Numの単純化されたクラス宣言
  (+)    :: a -&gt; a -&gt; a     -- (NumはPreludeで定義されている)  
  negate :: a -&gt; a
</code></pre>
<p>この宣言は「型<code>a</code>がもし与えられた型で定義されたクラスメソッド<code>(+)</code>と<code>negate</code>があるならクラス<code>Num</code>のインスタンスである」と読めるであろう。</p>
<p>このクラスのインスタンス化のときに<code>Int</code>と<code>Float</code>をその際に宣言できる。</p>
<pre><code class="language-hs">instance Num Int  where     -- Num Intの単純化されたインスタンス
   x + y       =  addInt x y  
   negate x    =  negateInt x  

 instance Num Float  where   -- Num Floatの単純化されたインスタンス
   x + y       =  addFloat x y  
   negate x    =  negateFloat x
</code></pre>
<p><code>addInt</code>や<code>negateInt</code>、<code>addFloat</code>、<code>negateFloat</code>はこのケースでプリミティブ関数で想定されるが、一般的にはユーザー定義関数になり得る。
上のはじめの宣言は「<code>Int</code>はクラス<code>Num</code>のインスタンスであり、その証拠として(クラスメソッド)<code>(+)</code>と<code>negate</code>が定義されている」と読まれる。</p>
<p>型クラスのより多くの例はJones<a href="chapters/../bibliography.html">8</a>かWadlerとBlott<a href="chapters/../bibliography.html">13</a>による論文で見つけられる。用語'型クラス'はオリジナルのHaskell1.0型システムを記述するために使われてあって、'コンストラクタクラス'はオリジナルの型クラスへ拡張を記述することに使われていた。ふたつの異なる用語を使う理由はもはやなく、この規格書において、'型クラス'という単語は元々のHaskell型クラスとJonesによって導入されたコンストラクタクラスの両方を含んでいる。</p>
<a class="header" href="#カインド" id="カインド"><h3>カインド</h3></a>
<p>型の表現が有効である確証を得るために、型の表現を異なる<em>カインド(カインド, kind)</em>へと分類され、以下の2つの可能な形式の内、1つを取る。</p>
<ul>
<li>シンボル<code>*</code>は全ての引数のない型コンストラクタのカインドを意味する。</li>
<li>もし<em>K<sub>1</sub></em>と<em>K<sub>2</sub></em>がカインドならば、<em>K<sub>1</sub> → K<sub>2</sub></em>はカインド<em>K<sub>1</sub></em>の型を取り、<em>K<sub>2</sub></em>の型を返す型のカインドである。</li>
</ul>
<p>型推論が値の表現の正当性をチェックするのと同様にして、カインド推論は型の表現の正当性をチェックする。しかしながら、型とは違い、カインドは完全に暗黙的であり、言語の見て分かる部分には存在しない。カインドの推論はセクション<a href="#a%E3%82%AB%E3%82%A4%E3%83%B3%E3%83%89%E3%81%AE%E6%8E%A8%E8%AB%96">4.6</a>で議論される。</p>
<a class="header" href="#型の構文" id="型の構文"><h3>型の構文</h3></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>type</em></td><td> → </td><td><em>btype</em> [-&gt; <em>type</em>]</td><td>(function type)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>btype</em></td><td>→</td><td>[<em>btype</em>] <em>atype</em></td><td>(type application)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>atype</em></td><td>→</td><td><em>gtycon</em></td><td> </td></tr>
<tr><td>  </td><td>|</td><td><em>tyvar</em></td><td> </td></tr>
<tr><td>  </td><td>|</td><td>( <em>type<sub>1</sub></em> , … , <em>type<sub>k</sub></em> )</td><td>(tuple type, <em>k</em> ≥ 2)</td></tr>
<tr><td>  </td><td>|</td><td>[ <em>type</em> ]</td><td>(list type)</td></tr>
<tr><td>  </td><td>|</td><td>( <em>type</em> )</td><td>(parenthesised constructor)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>gtycon</em></td><td>→</td><td><em>qtycon</em></td><td> </td></tr>
<tr><td>  </td><td>|</td><td>()</td><td>(unit type)</td></tr>
<tr><td>  </td><td>|</td><td>[]</td><td>(list constructor)</td></tr>
<tr><td>  </td><td>|</td><td>(-&gt;)</td><td>(function constructor)</td></tr>
<tr><td>  </td><td>|</td><td>(,{,})</td><td>(tupling constructors)</td></tr>
</tbody></table>
<p>Haskellの型の表現のための構文は上に与えられる。データ値と同じようにデータコンストラクタを使って作られ、型の値(訳注: 型の表現でそれ以上簡約出来ないもののこと)は <strong>型コンストラクタ</strong> から作られる。データコンストラクタと同様に、型コンストラクタの名前は大文字で始められる。データコンストラクタとは違い、中置型コンストラクタは許されない(<code>(-&gt;)</code>以外)。</p>
<p>型の表現の主要な形式は次のものになる。</p>
<ol>
<li>
<p>小文字で始まる識別子のように書かれた型変数。変数のカインドは現れた文脈によって暗黙的に決定される。</p>
</li>
<li>
<p>型コンストラクタ。多くの型コンストラクタは大文字から始まる識別子のように書かれている。
例えば、</p>
<ul>
<li><code>Char</code>や<code>Int</code>,<code>Float</code>,<code>Double</code>、<code>Bool</code>はカインド<code>*</code>で構築される型である。</li>
<li><code>Maybe</code>と<code>IO</code>は単項型コンストラクタで、カインド<code>*→*</code>をもつ型として扱われる。</li>
<li>宣言<code>data T ...</code>または<code>newtype T ...</code>は型のボキャブラリーに型コンストラクタ<code>T</code>を追加する。<code>T</code>のカインドはカインドの推論によって決定される。</li>
</ul>
<p>特殊な構文は特定のビルドインの型コンストラクタに提供される。</p>
<ul>
<li><strong>自明型</strong> は<code>()</code>のように書かれ、カインド<code>*</code>を持つ。それは&quot;引数のないタプル&quot;型を示し、<code>()</code>と書かれるが、値をちゃんと持つ(セクション<a href="chapters/./3-expressions.html#a%E5%8D%98%E4%BD%8D%E5%BC%8F%E3%81%A8%E6%8B%AC%E5%BC%A7%E4%BB%98%E3%81%8D%E5%BC%8F">3.9</a>と<a href="chapters/./6-predefined-types-and-classes.html#a">6.1.5</a>を参照)。</li>
<li><strong>関数型</strong> は<code>(-&gt;)</code>のように書かれ、カインド<code>∗→∗→∗</code>を持つ。</li>
<li><strong>リスト型</strong> は<code>[]</code>のように書かれ、カインド<code>∗→∗</code>を持つ。</li>
<li><strong>タプル型</strong> は<code>(,), (,,)</code>等のように書かれる。それらのカインドは<code>∗→∗→∗, ∗→∗→∗→ ∗</code>などである。</li>
</ul>
<p><code>(-&gt;)</code>と<code>[]</code>の定数の使用は下でより詳しく説明される。</p>
</li>
<li>
<p>型適用。もし、<em>t<sub>1</sub></em>がカインド<em>K<sub>1</sub> → K<sub>2</sub></em>の型で<em>t<sub>2</sub></em>がカインド<em>K<sub>1</sub></em>の型であるなら、その時<em>t<sub>1</sub>, t<sub>2</sub></em>はカインド<em>K<sub>2</sub></em>の型の表現である。</p>
</li>
<li>
<p><strong>括弧つき型</strong> 、形式<em>(t)</em>を持つ、型<em>t</em>と同一である。</p>
</li>
</ol>
<p>例えば、型の表現<code>IO a</code>は変数<code>a</code>に定数<code>IO</code>への適用のように理解されることが可能だ。<code>IO</code>型コンストラクタはカインド<code>∗→∗</code>を持ち、変数<code>a</code>と式全体の両方を従え、式<code>IO a</code>はカインド<code>*</code>を持たなければならない。一般的に <strong>型の推論</strong> (セクション<a href="#a%E3%82%AB%E3%82%A4%E3%83%B3%E3%83%89%E3%81%AE%E6%8E%A8%E8%AB%96">4.6</a>)の処理は適切なカインドをユーザー定義のデータ型や型のシノニム、クラスへ決定することを必要とされる。</p>
<p>特別な構文は特定の型の表現がより伝統的なスタイルで書かれることを許すために提供される。</p>
<ol>
<li><strong>関数型</strong> は形式<em>t<sub>1</sub> -&gt; t<sub>2</sub></em>を持ち、型<em>(-&gt;) t<sub>1</sub> t<sub>2</sub></em>に等しい。アロー関数は左に関連づける。例えば、<code>Int -&gt; Int -&gt; Float</code>は<code>Int -&gt; (Int -&gt; Float)</code>を意味する。</li>
<li><strong>タプル型</strong> は<em>K</em> ≥ 2である形式<em>t<sub>1</sub>, ..., t<sub>k</sub></em>を持ち、括弧の間に<em>k-1</em>個のカンマがある型<em>(,…,) t<sub>1</sub> … t<sub>k</sub></em>と等しい。それは型<em>t<sub>1</sub></em>をはじめの要素に、型<em>t<sub>2</sub></em>を2番目の要素に持つなど、<em>k</em>要素のタプルの型を示す(セクション<a href="chapters/./3-expressions.html#a%E3%82%BF%E3%83%97%E3%83%AB">3.8</a>と<a href="chapters/./6-predefined-types-and-classes.html#a">6.1.4</a>を参照)。</li>
<li><strong>リスト型</strong> は形式<em>[t]</em>を持ち、型<em>[] t</em>と等しい。それは型<em>t</em>の要素を伴うリストの型を示す(セクション<a href="chapters/./3-expressions.html#a%E3%83%AA%E3%82%B9%E3%83%88">3.7</a>と<a href="chapters/./6-predefined-types-and-classes.html#a">6.1.3</a>を参照)。</li>
</ol>
<p>これらの特別な構文的形式は何がスコープに入っているかにかかわらず関数、タプル、リストのビルドイン型のコンストラクタを常に示す。同様な方法で、プリフィックスな型コンストラクタ<code>(-&gt;), [], (), (,)</code>等はビルドインの型コンストラクタを常に示す。それらは修飾子を付けることはできず、そしてまたリストのimport/exportするもののリストに入れることもできない(<a href="chapters/./5-modules.html#a">5章</a>)。(上述の特定の生成規則、&quot;gtycon&quot;から)</p>
<p>リストとタプル型が特別な構文を持つのだが、それらの意味論はユーザー定義された代数データ型と同じである。</p>
<p>式と型は一貫した構文を持つことに注意すること。もし、<em>t<sub>i</sub></em>は式またはパターン<em>e<sub>i</sub></em>の型ならその時、式<em>(\ e<sub>1</sub> -&gt; e<sub>2</sub>), [e<sub>1</sub>]</em>と<em>(e<sub>1</sub>,e<sub>2</sub>)</em>は各々、型<em>(t<sub>1</sub> -&gt; t<sub>2</sub>), [t<sub>1</sub>]</em>と<em>(t<sub>1</sub>,t<sub>2</sub>)</em>を持つ。</p>
<p>ひとつの例外(クラス宣言内の区別された型変数のこと(セクション<a href="#a%E3%82%AF%E3%83%A9%E3%82%B9%E5%AE%A3%E8%A8%80">4.3.1</a>))を除いて、Haskellの型の表現内の型変数は一般に全て全称量化されていると仮定され、全称量化のための明示的な文法はない<a href="chapters/./../bibliography.html">4</a>。例えば、型の表現<code>a -&gt; a</code>は型<code>∀ a. a → a</code>を示す。明確にするために、しかしながら、Haskellプログラムの型を議論する時に明示的な個々の区分をしばしば書く。明示的に個々に区分された型を書く時、<code>∀</code>のスコープは可能な限り左側へ拡張する。例として、<code>∀ a. a → a</code>は<code>∀ a. (a → a)</code>を意味する。</p>
<a class="header" href="#クラス表明と文脈の構文" id="クラス表明と文脈の構文"><h3>クラス表明と文脈の構文</h3></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>context</em></td><td> → </td><td><em>class</em></td><td> </td></tr>
<tr><td>       </td><td> | </td><td>( <em>class<sub>1</sub></em> , … , <em>class<sub>n</sub></em> )</td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td> <em>class</em> </td><td> → </td><td><em>qtycls</em> <em>tyvar</em></td><td> </td></tr>
<tr><td>       </td><td> | </td><td><em>qtycls</em> ( <em>tyvar</em> <em>atype<sub>1</sub></em> … <em>atype<sub>n</sub></em> )</td><td>(<em>n</em> ≥ 1)</td></tr>
<tr><td> <em>qtycls</em></td><td> → </td><td>[ <em>modid</em> . ] <em>tycls</em></td><td> </td></tr>
<tr><td>  <em>tycls</em></td><td> → </td><td><em>conid</em></td><td> </td></tr>
<tr><td>  <em>tyvar</em></td><td> → </td><td><em>varid</em></td><td> </td></tr>
</tbody></table>
<p><strong>クラス表明</strong> は形式<em>qtycls tyvar</em>を持ち、クラス<em>qtycls</em>の型<em>tyvar</em>のメンバを示す。クラス識別子は大文字で始める。 <strong>文脈</strong> は0個以上のクラス表明からなり、一般に<em>( C<sub>1</sub> u<sub>1</sub>, …, C<sub>n</sub> u<sub>n</sub> )</em>の形式をもつ。ここで<em>C<sub>1</sub>, …, C<sub>n</sub></em>はクラス識別子であり、<em>( u<sub>1</sub>, …, u<sub>n</sub>)</em>はそれぞれ変数型または一つ以上の型への変数型の適用のいずれかである。<em>n = 1</em>のとき括弧の外側は省かれるであろう。一般的に、文脈を示すために<em>cx</em>を使用し、<em>cx =&gt; t</em>を文脈<em>cx</em>によって制限された型<em>t</em>を示すために書く。文脈<em>cx</em>は<em>t</em>によって参照される変数型のみを含まなければいけない。利便性のために、文脈<em>cx</em>が空であっても、具体的な構文は<em>=&gt;</em>を含まないケースであるが、<em>cx =&gt; t</em>を書く。</p>
<a class="header" href="#型とクラスの意味論" id="型とクラスの意味論"><h3>型とクラスの意味論</h3></a>
<p>このセクションは、型システムの簡略的な詳細を提供する。(WadlerとBlott<a href="chapters/../bibliography.html">[13]</a>、Jones<a href="chapters/../bibliography.html">[8]</a>は各々より詳細に型とコンストラクタクラスを議論している。)</p>
<p>Haskellの型システムは <strong>型</strong> をプログラム内の各式に割り当てる。一般的に、型は形式<code>∀ <em><span class="overline">u</span>. cx  ⇒  t</em></code>である。<em><span class="overline">u</span></em>は変数型の集合<em>u<sub>1</sub>, ..., u<sub>n</sub></em>である。どのような型であっても、<em>cx</em>に束縛がない一般的な個々に区別された変数型<em>u<sub>i</sub></em>は<em>t</em>でも束縛がないものでなければならない。その上、内容<em>cx</em>はセクション<a href="#a%E3%82%AF%E3%83%A9%E3%82%B9%E8%A1%A8%E6%98%8E%E3%81%A8%E6%96%87%E8%84%88%E3%81%AE%E6%A7%8B%E6%96%87">4.1.3</a>上で与えられた形式でなければならない。例として、ここにいくつかの正常な型がある。</p>
<pre><code class="language-hs">Eq a =&gt; a -&gt; a  
(Eq a, Show a, Eq b) =&gt; [a] -&gt; [b] -&gt; String  
(Eq (f a), Functor f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b -&gt; Bool
</code></pre>
<p>3つの型で、制約<code>Eq (f a)</code>は<code>f</code>が全称量化されているためもっと単純にはできない。</p>
<p>式<em>e</em>の型は型を<em>e</em>に束縛のない変数へ与えるため <strong>型環境</strong> に依存し、いずれかの型を宣言する <strong>クラス環境</strong> はいずれかのクラスのインスタンスである。(型は<code>インスタンス</code>宣言または<code>派生</code>節の存在によってのみクラスのインスタンスになる。)</p>
<p>型は一般化による半順序集合(下に明記される)で関連する。多くの一般的な型は、一般化の先行順によって同等まで導かれ、(与えられた環境の)個々の式は <strong>主要な型</strong> と呼ばれるものに割り当てられる。Haskellの拡張されたHindley-Milner型システムは全式の主要な型を推論でき、オーバーロードされたクラスメソッドの妥当な使用を含んでいる(セクション<a href="#a%E6%9B%96%E6%98%A7%E3%81%AA%E5%9E%8B%E3%81%A8%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AD%E3%83%BC%E3%83%89%E3%81%95%E3%82%8C%E3%81%9F%E6%95%B0%E5%80%A4%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E6%97%A2%E5%AE%9A%E5%80%A4">4.3.4</a>で説明するように、確実に曖昧なオーバーロードが起こり得るのだが)。したがって、明示的な型付け(型シグネチャと呼ぶ)は通常、オプションである(セクション<a href="./3-expressions,md#a%E5%BC%8F%E3%81%AE%E5%9E%8B%E3%82%B7%E3%82%B0%E3%83%8D%E3%83%81%E3%83%A3">3.16</a>と<a href="#a%E5%9E%8B%E3%82%B7%E3%82%B0%E3%83%8D%E3%83%81%E3%83%A3">4.4.1</a>を参照)。</p>
<p>型<code>∀ <em><span class="overline">u</span>. cx<sub>1</sub>  ⇒  t<sub>1</sub></em></code>は領域が以下のような<em><span class="overline">u</span></em>の代用<em>S</em>がある場合に限り、型<code>∀ <em><span class="overline">w</span>. cx<sub>2</sub>  ⇒  t<sub>2</sub></em></code> <strong>より一般的</strong> である。</p>
<ul>
<li><em>t<sub>2</sub></em>は<em>S(t<sub>1</sub>)</em>と同じである。</li>
<li><em>cx<sub>2</sub></em>はそのクラスの環境を保持し、<em>S(cx<sub>1</sub>)</em>も保持する。</li>
</ul>
<p>型<code>∀ <em><span class="overline">u</span>. cx  ⇒  t</em></code>の値は内容<em>cx[<span class="overline">s</span>;/<span class="overline">u</span>]</em>を保持する場合に限り型<em><span class="overline">s</span></em>でインスタンス化されるかもしれない。例えば、関数<code>double</code>について考えてみる。</p>
<pre><code class="language-hs">double x = x + x
</code></pre>
<p><code>double</code>の最も一般的な型は<code>∀ <em>a. Num a⇒  a  →  a</em></code>である。<code>double</code>は(<code>Int</code>にインスタンス化する)型<code>Int</code>の値に適用されるかもしれない、なぜなら<code>Num Int</code>が成り立つ、すなわち<code>Int</code>はクラス<code>Num</code>のインスタンスだからである。しかしながら、<code>double</code>が型<code>Char</code>の値に通常の意味で適用されることはないであろう。なぜなら、<code>Char</code>は通常クラス<code>Num</code>のインスタンスではないからだ。ユーザーはインスタンスのような宣言を選択するかもしれない。その場合、<code>double</code>が型<code>Char</code>の値に通常の意味で適用されることはないであろう。</p>
<a class="header" href="#ユーザー定義のデータ型" id="ユーザー定義のデータ型"><h2>ユーザー定義のデータ型</h2></a>
<p>このセクションでは、代数のデータ型(<code>data</code>宣言)や新たに命名するデータ型(<code>newtype</code>宣言)、型のシノニム(<code>type</code>宣言)を説明する。これらの宣言はモジュールのトップレベルでのみ現れてよい。</p>
<a class="header" href="#代数データ型宣言" id="代数データ型宣言"><h3>代数データ型宣言</h3></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>topdecl</em></td><td>→</td><td><code>data</code> [<em>context</em> =&gt;] <em>simpletype</em> [= <em>constrs</em>] [<em>deriving</em>]</td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>simpletype</em></td><td>→</td><td><em>tycon</em> <em>tyvar<sub>1</sub></em> … <em>tyvar<sub>k</sub></em></td><td>(<em>k</em> ≥ 0)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>constrs</em></td><td>→</td><td><em>constr<sub>1</sub></em> | … | <em>constr<sub>n</sub></em></td><td>(<em>n</em> ≥ 1)</td></tr>
<tr><td> <em>constr</em></td><td>→</td><td><em>con</em> [<code>!</code>] <em>atype<sub>1</sub></em> … [<code>!</code>] <em>atype<sub>k</sub></em></td><td>(arity <em>con</em> = <em>k</em>, <em>k</em> ≥ 0)</td></tr>
<tr><td>  </td><td>|</td><td>(<em>btype</em> | <code>!</code> <em>atype</em>) <em>conop</em> (<em>btype</em> | <code>!</code> <em>atype</em>)</td><td>(infix <em>conop</em>)</td></tr>
<tr><td>  </td><td>|</td><td><em>con</em> { <em>fielddecl<sub>1</sub></em> , … , <em>fielddecl<sub>n</sub></em> }</td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td><em>fielddecl</em></td><td>→</td><td><em>vars</em> <code>::</code> (<em>type</em> | <code>!</code> <em>atype</em>)</td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td> <em>deriving</em></td><td>→</td><td><code>deriving</code> (<em>dclass</em> | (<em>dclass<sub>1</sub></em>, … , <em>dclass<sub>n</sub></em>))</td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td><em>dclass</em></td><td>→</td><td><em>qtycls</em></td><td> </td></tr>
</tbody></table>
<p><em>constr</em>の優先順位は式と同じである。通常のコンストラクタの適用が中置コンストラクタの適用より高い優先順位を持つ(そのため<code>a : Foo a</code>は<code>a : (Foo a)</code>のように解析する)。</p>
<p>代数的なデータ型の宣言は、<em>cx</em>が内容である形式<code>data <em>cs =&gt; T u<sub>1</sub> ... u<sub>k</sub> = K<sub>1</sub> t<sub>1 1</sub> ... t<sub>1k<sub>1</sub></sub> | ... | K<sub>n</sub> t<sub>n1</sub> ... t<sub>nk<sub>n</sub></sub></em></code>を持つ。
この宣言は0個以上の構成要素である<em>データコンストラクタ K<sub>1</sub>, …, K<sub>n</sub></code></em>をもつような新しい<em>型コンストラクタT</em>を導入する。
このリポートで、修飾されていない用語&quot;コンストラクタ&quot;は&quot;データコンストラクタ&quot;を常に意味する。</p>
<p>データコンストラクタの型は<code><em>K<sub>i</sub></em>  ::  ∀ <em>u<sub>1</sub> … u<sub>k</sub>.  cx<sub>i</sub>  ⇒  t<sub>i1</sub>  →  ⋅⋅⋅  →  t<sub>ik<sub>i</sub></sub>  →  (T u<sub>1</sub> … u<sub>k</sub>)</em></code>によって与えられる。
ここで<em>cx<sub>i</sub></em>は、<em>t<sub>i1</sub>, …, t<sub>ik<sub>i</sub></sub></em>の型に自由に出現する型変数たちのみを含むような<em>cx</em>の部分集合の中で最大なものである。
型変数<em>u<sub>1</sub></em>から<em>u<sub>k</sub></em>は互いに異なるものでなければならず、<em>cx</em>と<em>t<sub>ij</sub></em>に出現してもよい。
また、他の型変数が<em>cx</em>やそれより右側に出現すると静的なエラーとなる。
新しい型定数<em>T</em>は引数の変数<em>u<sub>i</sub></em>のカインド<em>κ<sub>i</sub></em>がセクション<a href="#a%E3%82%AB%E3%82%A4%E3%83%B3%E3%83%89%E3%81%AE%E6%8E%A8%E8%AB%96">4.6</a>で説明されるカインド推論によって決定される形式<em>κ<sub>1</sub> →… → κ<sub>k</sub> →∗</em>のカインドを持つ。
これは<em>T</em>が0から<em>k</em>引数のどこでも型の表現に使われるかもしれないということを意味する。</p>
<p>例えば、以下の宣言は</p>
<pre><code class="language-hs">data Eq a =&gt; Set a = NilSet | ConsSet a (Set a)
</code></pre>
<p>カインド<code>∗→∗</code>の型コンストラクタ<code>Set</code>を導入し、型ありのコンストラクタ<code>NilSet</code>と<code>ConsSet</code>は以下のものである。</p>
<pre><code class="language-hs">NilSet  ::  ∀ a.  Set  a
ConsSet ::  ∀ a.  Eq   a  ⇒  a  →  Set   a  →  Set   a
</code></pre>
<p>与えられた例では、<code>ConsSet</code>にオーバーロードされた型は<code>ConsSet</code>は型がクラス<code>Eq</code>のインスタンスである値に提供されることのみ可能であることを保証する。<code>ConsSet</code>に対照したパターンマッチングは<code>Eq a</code>拘束にも発生する。例えば、</p>
<pre><code class="language-hs">f (ConsSet a s) = a
</code></pre>
<p>関数<code>f</code>は推論された型<code>Eq a =&gt; Set a -&gt; a</code>を持つ。<code>data</code>宣言の内容は他に何も効果を持たない。</p>
<p>データ型のコンストラクタの可視性(すなわちデータ型の&quot;抽象度&quot;)は、それが定義されたモジュールの外では、セクション<a href="chapters/./5-modules.html#a">5.8</a>で説明されるエクスポートリスト内のデータ型の名前の形式によって制御される。</p>
<p><code>data</code>宣言の内容は他に何も効果を持たない付加的な<code>deriving</code>の部分は <strong>派生されたインスタンス</strong> と関係しており、セクション<a href="#a%E6%B4%BE%E7%94%9F%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9">4.3.3</a>で説明される。</p>
<p><strong>ラベル付けされたフィールド</strong> 引数<em>k</em>個とるデータコンストラクタは<em>k</em>要素のオブジェクトを作成する。これらの要素は通常、式またはパターンの中のコンストラクタへの引数のように位置付けして呼び出される。巨大なデータ型のために、データオブジェクトの要素に <strong>フィールドラベル</strong> を割り当てることは便利である。これはコンストラクタ内でその位置を独立して参照されるために明記するフィールドを許す。</p>
<p><code>data</code>宣言のコンストラクタ定義はラベルを記録構文<code>(C { ... })</code>を使用するコンストラクタのフィールドに割り当てられるだろう。フィールドラベルを使用するコンストラクタはそれらなしにコンストラクタを自由に組み合わされるかもしれない。フィールドラベルに関係するコンストラクタは通常のコンストラクタのようにまだ使われるだろう。ラベルを使う機能は基礎となる位置上のコンストラクタを使う操作のための単純な簡略記法である。その位置上のコンストラクタの引数はラベル付けされたフィールドのように同じ順序で発生する。例えば、以下の宣言は</p>
<pre><code class="language-hs">data C = F { f1,f2 :: Int, f3 :: Bool }
</code></pre>
<p>下のように生成されるものと同一な型とコンストラクタを定義する。</p>
<pre><code class="language-hs">data C = F Int Int Bool
</code></pre>
<p>フィールドラベルを使用する操作はセクション<a href="chapters/./3-expressions.html#a%E3%83%95%E3%82%A3%E3%83%BC%E3%83%AB%E3%83%89%E3%83%A9%E3%83%99%E3%83%AB%E4%BB%98%E3%81%8D%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B">3.15</a>で説明される。<code>data</code>宣言においては、型シノニムを展開した後にそのフィールドが使われている場所すべてで同じ型がつく場合に限り、同じフィールドラベルを複数のコンストラクタで使ってもよい。ラベルはスコープ内の型以上で共有されることはできない。フィールド名は通常の変数とクラスメソッドを使う最上位の名前空間を共有し、スコープ内の他の最上位の名前と衝突してはいけない。</p>
<p>パターン<code>F {}</code>はコンストラクタ<code>F</code>が <strong>記録構文を使って宣言されているかどうかにかかわらず</strong> 、<code>F</code>によって構築された任意の値と一致する。</p>
<p><strong>正格なフラグ</strong> データコンストラクタが適用されるたびに、代数的データ型の宣言に対応する型が感嘆符<code>!</code>で表される正格なフラグを持つ場合に限り、コンストラクタの各引数は評価される。
<code>&quot;!&quot;</code>は通常のvarsymであって、<em>reservedop</em>としては字句解析されない。
それはデータ宣言の引数の型の内容にのみ特別な意味を持つ。</p>
<div class="column">
<p><strong>変換:</strong> 各<em>s<sub>i</sub></em>が形式<em>!t<sub>i</sub></em>か<em>t<sub>i</sub></em>のいずれかである形式<code>data <em>cx =&gt; T u<sub>1</sub> … u<sub>k</sub> = … | K s<sub>1</sub> … s<sub>n</sub> | …</em></code>の宣言は<em>(\ x<sub>1</sub> … x<sub>n</sub> -&gt; ( ((K op<sub>1</sub> x<sub>1</sub>) op<sub>2</sub> x<sub>2</sub>) … ) op<sub>n</sub> x<sub>n</sub>)</em>という式の中の<em>K</em>の全ての発生を置き換える。
<em>op<sub>i</sub></em>はもし<em>s<sub>i</sub></em>が形式<em>t<sub>i</sub></em>なら、正格ではない適用関数<code>$</code>であり、<em>op<sub>i</sub></em>はもし<em>s<sub>i</sub></em>が形式<code>！ <em>t<sub>i</sub></em></code>であるなら正格に適用する関数<code>$!</code>である(セクション<a href="chapters/./6-predefined-types-and-classes.html#a">6.2</a>を参照)。
<em>K</em>上のパターンマッチングは正格なフラグによる影響を受けられない。</p>
</div>
<a class="header" href="#型シノニムの宣言" id="型シノニムの宣言"><h3>型シノニムの宣言</h3></a>
<table><thead><tr></tr></thead><tbody>
<tr><td>   <em>topdecl</em></td><td>→</td><td><code>type</code> <em>simpletype</em> <code>=</code> <em>type</em></td><td> </td></tr>
<tr><td><em>simpletype</em></td><td>→</td><td><em>tycon</em> <em>tyvar<sub>1</sub></em> … <em>tyvar<sub>k</sub></em></td><td>(<em>k</em> ≥ 0)</td></tr>
</tbody></table>
<p>型シノニムの宣言は古い型と等しい新しい型を生成する。
それは新しいコンストラクタ<em>T</em>を生成する形式<code>type</code> <em>T u<sub>1</sub> ... u<sub>k</sub> = t</em>を持つ。
型<em>(T t<sub>1</sub> …t<sub>k</sub>)</em>は型<em>t[t<sub>1</sub>∕u<sub>1</sub>, …, t<sub>k</sub>∕u<sub>k</sub>]</em>に等しい。
型変数<em>u<sub>1</sub></em>から<em>u<sub>k</sub></em>は互いに異なるものでなければならず、<em>t</em>上のみにスコープされる。
そしてその<em>t</em>の中に他の型変数が現れたら静的エラーになる。
新しい型コンストラクタ<em>T</em>のカインドは引数<em>u<sub>i</sub></em>のカインド<em>κ<sub>i</sub></em>は形式<em>κ<sub>1</sub> →… → κ<sub>k</sub> → κ</em>であり、<em>t</em>の右側の<em>κ</em>はセクション<a href="#a%E3%82%AB%E3%82%A4%E3%83%B3%E3%83%89%E3%81%AE%E6%8E%A8%E8%AB%96">4.6</a>で説明されるカインドの推論によって決定される。
例えば、次の定義はリスト型のコンストラクタを書く方法の代替案を提供することに使用されることができる。</p>
<pre><code class="language-hs">type List = []
</code></pre>
<p>型シノニムの宣言によって生成された型コンストラクタのシンボル<em>T</em>は一部のみを提供されることはできない。十分な数の引数なしに<em>T</em>を使うことは静的エラーになる。</p>
<p>再帰的と相互再帰的なデータ型は許されるのだが、 <strong>代数的データ型</strong>  が入り込む限り、型シノニムではそうではない。例えば、</p>
<pre><code class="language-hs">type Rec a   =  [Circ a]  
data Circ a  =  Tag [Rec a]
</code></pre>
<p>は許されるが、それに反して、</p>
<pre><code class="language-hs">type Rec a   =  [Circ a]        -- invalid  
type Circ a  =  [Rec a]         -- invalid
</code></pre>
<p>はそうではない。似たもので、<code>type Rec a = [Rec a]</code>も許されない。</p>
<p>型シノニムはより読みやすい型シグネチャを作る便利な、しかし厳密な構文的仕組みである。同義語とその定義は<code>instance</code>宣言のインスタンス型を除いて、完全に置き換えできる(セクション<a href="#a%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9%E5%AE%A3%E8%A8%80">4.3.2</a>を参照)。</p>
<a class="header" href="#データ型の改名" id="データ型の改名"><h3>データ型の改名</h3></a>
<table><thead><tr></tr></thead><tbody>
<tr><td> <em>topdecl</em></td><td>→</td><td><code>newtype</code> [<em>context</em> =&gt;] <em>simpletype</em> = <em>newconstr</em> [<em>deriving</em>]</td><td> </td></tr>
<tr><td> <em>newconstr</em></td><td>→</td><td><em>con</em> <em>atype</em></td><td> </td></tr>
<tr><td>  </td><td>|</td><td><em>con</em> { <em>var</em> :: <em>type</em> }</td><td> </td></tr>
<tr><td><em>simpletype</em></td><td>→</td><td><em>tycon</em> <em>tyvar<sub>1</sub></em> … <em>tyvar<sub>k</sub></em></td><td>(<em>k</em> ≥ 0)</td></tr>
</tbody></table>
<p><code>newtype <em>cs =&gt; T u<sub>1</sub> ... u<sub>k</sub> = N t</em></code>の形の宣言は新しい型を導入し、その表現はすでに存在している型と同じである(<strong>訳注</strong>: TはNから新たに作られた型であるが、実行時表現が等しい)。
型<em>(T u<sub>1</sub>… u<sub>k</sub>)</em>はデータ型<em>t</em>を改名する。
それは型シノニムからオリジナルな型からまたはその型へ明示的に強制されなければならない厳密な型を作成することとは異なる。
また型シノニムと異なり、<code>newtype</code>は再帰的な型を定義することに使用されるかもしれない。
式の中のコンストラクタ<em>N</em>は型<em>t</em>から型<em>(T u<sub>1</sub> … u<sub>k</sub>)</em>へ値を強制する。
パターンの中の<em>N</em>は型<em>(T u<sub>1</sub> … u<sub>k</sub>)</em>から型<em>t</em>へ値を強制する。
これらの強制は実行時のオーバーヘッドなしに実装されるかもしれない。
<code>newtype</code>はオブジェクトの根底にある表現を変更しない。</p>
<p>新しいインスタンス(セクション<a href="#a%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9%E5%AE%A3%E8%A8%80">4.3.2</a>を参照)は<code>newtype</code>によって定義された型に定義されることができるが、型シノニムに定義されることはないかもしれない。
<code>newtype</code>によって作成された型は代数的データ型が追加の間接レベルを持つ表現内の代数的データ型とは異なる。
この差は効率が悪い表現にアクセスするかもしれない。
この差はパターンマッチングのための異なるルールに反映される(セクション<a href="chapters/./3-expressions.html#a%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%83%9E%E3%83%83%E3%83%81%E3%83%B3%E3%82%B0">3.17</a>を参照)。
代数的なデータ型とは異なり、新しい型コンストラクタ<em>N</em>は <strong>リフトしない</strong> 、そのため、<code><em>N</em> ⊥</code>は<code>⊥</code>と同じである。</p>
<p>次の例は<code>data</code>(代数的データ型)と<code>type</code>(型シノニム)、<code>newtype</code>(型の改名)との差を明確にする。以下の宣言が与えられる。</p>
<pre><code class="language-hs">data D1 = D1 Int  
data D2 = D2 !Int  
type S = Int  
newtype N = N Int  
d1 (D1 i) = 42  
d2 (D2 i) = 42  
s i = 42  
n (N i) = 42
</code></pre>
<p>式<code>(d1 ⊥)</code>と<code>(d2 ⊥)</code>、<code>(d2 (D2 ⊥))</code>は<code>⊥</code>と全て等しい。一方で、<code>(n ⊥)</code>と<code>(n (N ⊥))</code>、<code>(d1 (D1 ⊥))</code>、<code>(s ⊥)</code>は<code>42</code>と全て等しくなる。特別に、<code>(N ⊥)</code>は<code>(D1 ⊥)</code>が<code>⊥</code>と等しくないときは<code>⊥</code>と等しくなる。</p>
<p><code>newtype</code>宣言のオプション的に派生部分は<code>data</code>宣言の派生要素と同じ方法で扱われる。セクション<a href="%22#4.3.3%22">4.3.3</a>を参照すること。</p>
<p><code>newtype</code>宣言はフィールド名をつける構文を使用するかもしれず、もちろんそのフィールドしかないかもしれない。従って、</p>
<pre><code class="language-hs">newtype Age = Age { unAge :: Int }
</code></pre>
<p>はコンストラクタとデコンストラクタの両方をスコープに持ち込む。</p>
<pre><code class="language-hs">Age   :: Int -&gt; Age  
unAge :: Age -&gt; Int
</code></pre>
<a class="header" href="#型クラスとオーバーロード" id="型クラスとオーバーロード"><h2>型クラスとオーバーロード</h2></a>
<a class="header" href="#クラス宣言" id="クラス宣言"><h3>クラス宣言</h3></a>
<table><thead><tr></tr></thead><tbody>
<tr><td> <em>topdecl</em></td><td>→</td><td><code>class</code> [<em>scontext</em> =&gt;] <em>tycls</em> tyvar [<code>where</code> <em>cdecls</em>]</td><td> </td></tr>
<tr><td><em>scontext</em></td><td>→</td><td><em>simpleclass</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>( <em>simpleclass<sub>1</sub></em> <code>,</code> … <code>,</code> <em>simpleclass<sub>n</sub></em> )</td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td><em>simpleclass</em></td><td>→</td><td><em>qtycls</em> <em>tyvar</em></td><td> </td></tr>
<tr><td>  <em>cdecls</em></td><td>→</td><td>{ <em>cdecl<sub>1</sub></em> <code>;</code> … <code>;</code> <em>cdecl<sub>n</sub></em> }</td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td>   <em>cdecl</em></td><td>→</td><td><em>gendecl</em> </td></tr>
<tr><td> </td><td>|</td><td>(<em>funlhs</em> | <em>var</em>) <em>rhs</em></td><td> </td></tr>
</tbody></table>
<p><strong>クラス宣言</strong> は新しいクラスとその中のオペレーション(<strong>クラスメソッド</strong>)を生成する。クラス宣言は次の一般的な形式を持つ。</p>
<pre><code class="language-hs">class cx =&gt; C u where cdecls
</code></pre>
<p>これは新しいクラスの名前<em>C</em>を生成し、型変数<em>u</em>はそのクラスの本体のクラスメソッドシグネチャ上でのみスコープされる。内容<em>cx</em>は下で説明する<em>C</em>のスーパークラスを明記する。<em>cx</em>の中で参照されるであろう型変数のみが<em>u</em>である。</p>
<p>スーパークラスの関係は循環してはいけない。例)指示された非環式のグラフを構成しなければいけない。</p>
<p><code>class</code>宣言の<em>cdecls</em>部分は3種類の宣言を含む。</p>
<ul>
<li>クラス宣言は新しい<em>クラスメソッドv<sub>i</sub></em>を生成し、スコープは<em>class</em>宣言の外側に展開する。
クラス宣言のクラスメソッドは<em>cdecls</em>内の明示的な型シグネチャ<em>v<sub>i</sub> :: cx<sub>i</sub> =&gt; t<sub>i</sub></em>にある<em>v<sub>i</sub></em>そのものである。
クラスメソッドは変数束縛とフィールド名と一緒に最上位の名前空間を共有する。
それらはスコープの他の最上位の束縛と衝突してはならない。
そのため、クラスメソッドは最上位の定義やフィールド名、他のクラスメソッドのように同じ名前を持つことはできない。
<br><br>
トップレベルのクラスメソッド<em>v<sub>i</sub></em>の型は<em>v<sub>i</sub> :: ∀u,<span class="overline">w</span>.(Cu,cx<sub>i</sub>) ⇒ t<sub>i</sub></em>である。
<em>t<sub>i</sub></em>は<em>u</em>を言及しなければいけないし、<em>u</em>より型変数<em><span class="overline">w</span></em>を言及するかもしれない。
その場合、<em>v<sub>i</sub></em>の型は<em>u</em>と<em><span class="overline">w</span></em>の両方に多相的である。
<em>cx<sub>i</sub></em>は<em><span class="overline">w</span></em>のみ束縛するだろう。
特に、<em>cx<sub>i</sub></em>は<em>u</em>を束縛しなくともよい。
例えば、
<pre><code class="language-hs">class Foo a where
op :: Num b =&gt; a -&gt; b -&gt; a
</code></pre>
<br>
ここでの<code>op</code>型は<code>∀ <em>a</em>, <em>b</em>.(<code>Foo</code> <em>a</em>, Num <em>b</em>)   ⇒  <em>a</em>  →  <em>b</em>  →  <em>a</em>.</code>である。</li>
<li><em>cdecls</em>は(他の値ではなく)そのクラスのメソッドに対する <strong>結合性宣言</strong> を含んでもよい。
しかしながら、クラスメソッドはトップレベルの値を宣言することから、他の選択肢としてクラスメソッドの結合性宣言はクラス宣言の外側であるトップレベルに現れてもよい。</li>
<li>最後に、<em>cdecls</em>は<em>v<sub>i</sub></em>のいずれかの <strong>デフォルトクラスメソッド</strong> を含められる(セクション<a href="#a%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9%E5%AE%A3%E8%A8%80">4.3.2</a>)。
デフォルトメソッドの宣言は通常、左手側が変数か関数定義のみであろうことを除いて値の定義である。
例えば、
<pre><code class="language-hs">class Foo a where  
op1, op2 :: a -&gt; a  
(op1, op2) = ...
</code></pre>
<br>
は、許可されない。デフォルト宣言の左手側がパターンだからだ。</li>
</ul>
<p>これらのケース以外に、<em>cdecls</em>内の宣言は許されない。</p>
<p><code>where</code>部を伴わない<code>class</code>宣言はオリジナルの全てのクラスメソッドを継承する巨大なクラスのコレクションを合成することに便利かもしれない。
例えば、</p>
<pre><code class="language-hs">class  (Read a, Show a) =&gt; Textual a
</code></pre>
<p>このような場合、型が全スーパークラスのインスタンスであるなら、たとえサブクラスが直ちにクラスメソッドを持たなくても、サブクラスのインスタンスに <strong>自動的にはならず</strong> 、<code>instance</code>宣言は<code>where</code>部を伴わず明示的に与えられなければならない。</p>
<a class="header" href="#インスタンス宣言" id="インスタンス宣言"><h3>インスタンス宣言</h3></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>topdecl</em></td><td>→</td><td><code>instance</code> [<em>scontext</em> =&gt;] <em>qtycls</em> <em>inst</em> [<code>where</code> <em>idecls</em>]</td><td> </td></tr>
<tr><td>   <em>inst</em></td><td>→</td><td><em>gtycon</em></td><td> </td></tr>
<tr><td>  </td><td>|</td><td>( <em>gtycon</em> <em>tyvar<sub>1</sub></em> … <em>tyvar<sub>k</sub></em> )</td><td>(<em>k</em> ≥ 0, <em>tyvars</em>  <em>distinct</em>)</td></tr>
<tr><td>  </td><td>|</td><td>( <em>tyvar<sub>1</sub></em> , … , <em>tyvar<sub>k</sub></em> )</td><td>(<em>k</em> ≥ 2, <em>tyvars</em>  <em>distinct</em>)</td></tr>
<tr><td>  </td><td>|</td><td>[ <em>tyvar</em> ]</td><td> </td></tr>
<tr><td>  </td><td>|</td><td>( <em>tyvar<sub>1</sub></em> -&gt; <em>tyvar<sub>2</sub></em> )</td><td>(<em>tyvar<sub>1</sub></em>  <em>and</em> <em>tyvar<sub>2</sub></em>  <em>distinct</em>)</td></tr>
<tr><td> <em>idecls</em></td><td>→</td><td>{ <em>idecl<sub>1</sub></em> ; … ; <em>idecl<sub>n</sub></em> }</td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td>  <em>idecl</em></td><td>→</td><td>(<em>funlhs</em> | <em>var</em>) <em>rhs</em></td><td> </td></tr>
<tr><td>  </td><td>|</td><td> </td><td>(<em>empty</em>)</td></tr>
</tbody></table>
<p><strong>インスタンス宣言</strong> はクラスのインスタンスを生成する。クラス宣言は<code>class <em>cx</em> =&gt; <em>C u</em> where { <em>cbody</em> }</code>という風に行う。対応するインスタンス宣言の一般的な形式は次のものになる：<code>instance <em>cx′</em> =&gt; <em>C (T u<sub>1</sub> … u<sub>k</sub>)</em> where { <em>d</em> } where <em>k</em> ≥ 0</code>。型<em>(T u<sub>1</sub> … u<sub>k</sub>)</em>はシンプルな型変数<em>u<sub>1</sub>, … u<sub>k</sub></em>に提供される型コンストラクタ<em>T</em>の形式を取らなければいけない。さらに<em>T</em>は型シノニムであってはならず、<em>u<sub>i</sub></em>は全て互いに異ならなければならない。</p>
<p>以下のようなインスタンス宣言は禁止である。</p>
<pre><code class="language-hs">instance C (a,a) where ...  
instance C (Int,a) where ...  
instance C [[a]] where ...
</code></pre>
<p>宣言<em>d</em>は<em>C</em>のクラスメソッドのみの束縛を含められる。スコープにないクラスメソッドへの束縛を与えることは不正であるが、スコープ内にあるものの名前は重要ではない。特に、それは修飾子付きの名前でもよいであろう。(このルールはセクション<a href="chapters/./5-modules.html#a">5.2</a>のエクスポートリスト内に従属する名前に使われることと同一である。)例として、<code>range</code>は修飾子付きの名前<code>Data.Ix.range</code>のみがスコープ内にあるが、これは正当である。</p>
<pre><code class="language-hs">module A where  
  import qualified Data.Ix  

  instance Data.Ix.Ix T where  
    range = ...
</code></pre>
<p><code>class</code>宣言内にすでに与えられているゆえに、宣言はあらゆる型シグネチャまたは固定宣言を含めないであろう。デフォルトのクラスメソッド(セクション<a href="#a%E3%82%AF%E3%83%A9%E3%82%B9%E5%AE%A3%E8%A8%80">4.3.1</a>)の場合のように、メソッド宣言は変数または関数定義の形式を取らなければならない。</p>
<p>もし、いくつかのクラスメソッドに束縛が与えられなければ、その時、<code>class</code>宣言内の対応するデフォルトのクラスメソッドは(提供しているなら)使われる。デフォルトが存在しないなら、その時、このインスタンスのクラスメソッドは<code>undefined</code>に束縛され、コンパイル時エラーは発生しない。</p>
<p>型<em>T</em>をクラス<em>C</em>のインスタンスであるよう生成する<code>instance</code>宣言は<em>C-Tインスタンス宣言</em>と呼ばれ、以下の静的な制約に従うべきである。</p>
<ul>
<li>
<p>型はプログラム上で1回以上個々のクラスのインスタンスのように宣言されるだろう。</p>
</li>
<li>
<p>クラスと型は同じカインドを持たなければいけない。これはセクション<a href="#a%E3%82%AB%E3%82%A4%E3%83%B3%E3%83%89%E3%81%AE%E6%8E%A8%E8%AB%96">4.6</a>で説明される使用するカインドの推論を決定されることが可能だ。</p>
</li>
<li>
<p>インスタンス型<em>(T u<sub>1</sub> … u<sub>k</sub>)</em>内の型変数がインスタンス内容<em>cx'</em>に束縛を満たすということを推測するべきだ。この推測の元、次の2つの状態も満たされなければならない。</p>
<ol>
<li><em>C</em>のスーパークラスの内容<em>cx[(T u<sub>1</sub> … u<sub>k</sub>)∕u] </em>によって表現された束縛が満たされなければならない。言い換えると、<em>T</em>は<em>C</em>のスーパークラスの各インスタンスでなければならず、全スーパークラスのインスタンスの内容は<em>cx'</em>によって暗示されなければいけない。</li>
<li>正しく型付けされた<em>d</em>内のクラスメソッド宣言に要求されるインスタンス型内の型変数上の束縛も満たされなければいけない。</li>
</ol>
<p>実際に異常なケースを除いては、インスタンス宣言から上記2つの制約を満たす最も一般的なインスタンス文脈<em>cx'</em>を推論することが可能である。だが、それでも明示的なインスタンスの内容を書くことは強制される。</p>
</li>
</ul>
<p>次の例はスーパークラスインスタンスによって強いられた制限事項を説明する。</p>
<pre><code class="language-hs">class Foo a =&gt; Bar a where ...  

instance (Eq a, Show a) =&gt; Foo [a] where ...  

instance Num a =&gt; Bar [a] where ...
</code></pre>
<p>この例はHaskellにおいて正常である。<code>Foo</code>は<code>Bar</code>のスーパークラスであるため、2つ目のインスタンス宣言は<code>[a]</code>が仮定<code>Num a</code>の下で<code>Foo</code>のインスタンスである時に正常である。1つめのインスタンス宣言はこの仮定の下で<code>[a]</code>が<code>Foo</code>のインスタンスであると実際に告げる。なぜなら、<code>Eq</code>と<code>Show</code>は<code>Num</code>のスーパークラスだからだ。</p>
<p>もし2つのインスタンス宣言が代わりにこのように読むなら。</p>
<pre><code class="language-hs">instance Num a =&gt; Foo [a] where ...  

instance (Eq a, Show a) =&gt; Bar [a] where ...
</code></pre>
<p>そのとき、そのプログラムは不正である。2つ目のインスタンス宣言は<code>[a]</code>が仮定<code>(Eq a, Show a)</code>の下、<code>Foo</code>のインスタンスであるときのみ正常である。しかし、<code>[a]</code>がもっと強い仮定<code>Num a</code>の下で<code>Foo</code>のインスタンスのみであることから、これは保持しない。</p>
<p><code>instance</code>宣言のさらに進んだ例は<a href="chapters/./9-standard-prelude.html">9章</a>で見つけられるだろう。</p>
<a class="header" href="#導出されたインスタンス" id="導出されたインスタンス"><h3>導出されたインスタンス</h3></a>
<p>セクション<a href="#%E4%BB%A3%E6%95%B0%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B%E5%AE%A3%E8%A8%80">4.2.1</a>で言及したように、<code>data</code>と<code>newtype</code>の宣言は任意の<code>deriving</code>の形式を含んでいる。
もしその形式が含まれていたら、そのデータ型に対して <strong>導出されたインスタンス宣言</strong> が指定されたクラスのそれぞれについて自動的に生成される。
これらのインスタンスはユーザー定義されたインスタンスと同じ制限事項に従うべきである。
型<em>T</em>へクラス<em>C</em>を導出している時、<em>C</em>の全スーパークラスのインスタンスは<em>T</em>のために存在しなければならず、明示的な<code>instance</code>宣言を経由または<code>deriving</code>句にスーパークラスを含むことを経由するかのいずれかである。</p>
<p>導出されたインスタンスはユーザー定義のデータ型へ便利なよく使われるオペレーションを提供する。
例えば、クラス<code>Eq</code>の中のデータ型に導出されたインスタンスが<code>==</code>と<code>/=</code>オペレーションを定義すると、それらを定義する必要からプログラマーを解放する。</p>
<p>導出されたインスタンスが許されるPreludeのクラスは<code>Eq</code>と<code>Ord</code>、<code>Enum</code>、<code>Bounded</code>、<code>Show</code>、<code>Read</code>のみであり、図<a href="chapters/./6-predefined-types-and-classes.html#a">6.1</a>で全て図示される。
これらの句それぞれに生成される導出されたインスタンスの様相の精密な詳細は<a href="chapters/./11-specification-of-derived-instances.html">11</a>章に提供されており、そこにはそのような導出されたインスタンスが可能である時の仕様書を含んでいる。
標準ライブラリによって定義された句も導出可能であろう。</p>
<p>もし<code>deriving</code>の形式で名付けられたクラス上で<code>instance</code>宣言を導出することが可能でないなら、静的エラーが結果となる。
例えば、すべてのデータ型が正しく<code>Enum</code>のクラスメソッドをサポートできるわけではない。
それはまた導出されたクラスに明示的な<code>instance</code>宣言を与えるため静的エラーになる。</p>
<p>もし<code>deriving</code>形式が<code>data</code>または<code>newtype</code>宣言から省略されたなら、そのときそのデータ型への <strong>いかなる</strong> インスタンス宣言も導出されない。
すなわち、<code>deriving</code>形式を省くことは空の導出の形式<code>: deriving()</code>を含んでいることと同等である。</p>
<a class="header" href="#曖昧な型とオーバーロードされた数値演算子の既定値" id="曖昧な型とオーバーロードされた数値演算子の既定値"><h3>曖昧な型とオーバーロードされた数値演算子の既定値</h3></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>topdecl</em></td><td>→</td><td><code>default</code> (<em>type<sub>1</sub></em> <code>,</code> … <code>,</code> <em>type<sub>n</sub></em>)</td><td>(<em>n</em> ≥ 0)</td></tr>
</tbody></table>
<p>Haskellスタイルのオーバーロード固有の問題は <strong>曖昧な型</strong> の可能性があるということである。
例えば、<a href="./11-specification-of-derived-instances">11</a>章で定義された<code>read</code>と<code>show</code>関数を使い、もし単なる<code>Int</code>と<code>Bool</code>が<code>Read</code>と<code>Show</code>のメンバーなら、その時の次の式</p>
<pre><code class="language-hs">let x = read &quot;...&quot; in show x  -- invalid
</code></pre>
<p>は曖昧である。なぜなら<code>show</code>と<code>read</code>の型は、下の2つの式の</p>
<pre><code class="language-hs">show :: ∀ a. Show  a  ⇒  a  →  String
read :: ∀ a. Read  a  ⇒  String  →  a
</code></pre>
<p>両方のケースで<code>a</code>を<code>Int</code>または<code>Bool</code>のどちらでもインスタンス化で満たすことが可能だからだ。
そのような式は不適切な型付けだと考えられ、静的エラーである。</p>
<p>型<code>∀ <em><span class="overline">u</span>. cx  ⇒  t</em></code>内で、もし<em>t</em>ではなく<em>ex</em>の中に存在する<em><span class="overline">u</span></em>に型変数<em>u</em>があるなら、式<code>e</code>が <strong>曖昧な型</strong> を持つと言う。
そのような型は不正である。</p>
<p>例えば、先程の<code>show</code>と<code>read</code>を伴う式はその型が<code>∀ <em>a</em>.  Show  <em>a</em>, Read  <em>a</em>  ⇒  String</code>であるから曖昧な型を持つ。</p>
<p>曖昧な型はユーザーからの入力によってのみ回避できる。
その方法のひとつはセクション<a href="./3-expressions#a%E5%BC%8F%E3%81%AE%E5%9E%8B%E3%82%B7%E3%82%B0%E3%83%8D%E3%83%81%E3%83%A3">3.16</a>で説明された <strong>式の型シグネチャ</strong> の使用を通じてである。
例として、先程与えられた曖昧な式において、以下のように書くことで、</p>
<pre><code class="language-hs">let x = read &quot;...&quot; in show (x::Bool)
</code></pre>
<p>型から曖昧さを取り除く。</p>
<p>型シグネチャにより固定された型を与える以外にも、曖昧な式はある変数と同じ型にしなければならない場合がしばしばある。
これは関数<code>asTypeOf</code>:<code><em>x</em> <code>asTypeOf</code> <em>y</em></code>(<a href="chapters/./9-standard-prelude.html">9</a>章)の用途が<em>x</em>の値を持つということであるが、<em>x</em>と<em>y</em>は同じ型を持つように強制される。
例えば、</p>
<pre><code class="language-hs">approxSqrt x = encodeFloat 1 (exponent x ‘div‘ 2) ‘asTypeOf‘ x
</code></pre>
<p>(<code>encodeFloat</code>と<code>exponent</code>の説明についてはセクション<a href="chapters/./6-predefined-types-and-classes.html">6.4.6</a>を参照)</p>
<p><code>Num</code>クラスの曖昧さはとてもありふれているので、Haskellはこれを解決する別の方法を提供している。
それは<strong>デフォルト宣言</strong>である。
<em>n</em> ≥ 0で、各<em>t<sub>i</sub></em>が<code>Num <em>t<sub>i</sub></em></code>が保持する<code>default (<em>t<sub>1</sub></em> , … , <em>t<sub>n</sub></em>)</code>。
曖昧な型が発見された状態で、もし以下の条件を満たすなら、曖昧な型変数<code>v</code>はデフォルト可能である。</p>
<ul>
<li><em>v</em>は<code><em>C v</em></code>の形の制約の中でのみ出現し(ただし<em>C</em>はクラスである)、かつ</li>
<li>少なくともこれらのクラスの一つが数値クラス(<code>Num</code>、または<code>Num</code>のサブクラス)であり、</li>
<li>これらのクラスの全てがPreludeまたは標準ライブラリの中で定義されている(図<a href="chapters/./6-predefined-types-and-classes.html#a">6.2</a>-<a href="chapters/./6-predefined-types-and-classes.html#a">6.3</a>は数値クラスを示し、図<a href="chapters/./6-predefined-types-and-classes.html#a">6.1</a>はPrelude内で定義されたクラスを示す)。</li>
</ul>
<p>各デフォルト可能な変数は全ての曖昧な変数のクラスのインスタンスであるデフォルトリストの初めの型によって置き換えられる。
そのような型が見つからなければ、静的エラーである。</p>
<p>ひとつのデフォルト宣言のみがモジュールごとに許可され、その効果はそのモジュールに制限される。
もしデフォルト宣言がモジュール内で与えられないなら、その時は次のようなものであると仮定する。</p>
<pre><code class="language-hs">default (Integer, Double)
</code></pre>
<p>空のデフォルト宣言<code>default ()</code>はモジュール内の全てのデフォルトをオフにする。</p>
<a class="header" href="#ネストされた宣言" id="ネストされた宣言"><h2>ネストされた宣言</h2></a>
<p>次の宣言はモジュールのトップレベルを含むどんな宣言リストでも使用される。</p>
<a class="header" href="#型シグネチャ" id="型シグネチャ"><h3>型シグネチャ</h3></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>gendecl</em></td><td>→</td><td><em>vars</em> <code>::</code> [<em>context</em> <code>=&gt;</code>] </td><td><em>type</em></td></tr>
<tr><td>   <em>vars</em></td><td>→</td><td><em>var<sub>1</sub></em> <code>,</code> …<code>,</code> <em>var<sub>n</sub></em>      </td><td>(<em>n</em> ≥ 1)</td></tr>
</tbody></table>
<p>型シグネチャは可能な限り内容を尊重して変数の型を明示する。型シグネチャは<em>i</em>がそれぞれ1から<em>n</em>を取る<code><em>v<sub>i</sub> :: cx =&gt; t</em></code>を表明することと同等な形式: <code><em>v<sub>1</sub>, …, v<sub>n</sub> :: cx =&gt; t</em></code>を持つ。
各<em>v<sub>i</sub></em>は型シグネチャを含む同じ宣言リストに束縛する値を持たなければいけない。
例えば、型シグネチャをスコープ外へ束縛された変数へ与えることは不正である。
その上、たとえそのシグネチャが同一であっても、一つの変数に一つ以上の型シグネチャを与えることは不正である。</p>
<p>セクション<a href="#a%E5%9E%8B%E3%81%AE%E6%A7%8B%E6%96%87">4.1.2</a>で言及されたように、シグネチャに現れた全ての型変数はそのシグネチャ上で全称量化され、従って型変数のスコープはそれを含む型シグネチャに制限される。
例として、次の宣言、</p>
<pre><code class="language-hs">f :: a -&gt; a  
f x = x :: a                  -- invalid
</code></pre>
<p>2つの型シグネチャ内の<code>a</code>は完全に異なる。
それにまた<code>x</code>が型<code>∀ <em>a. a</em></code>を持たないことから、これらの宣言は静的エラーを含む。
(<code>x</code>の型は<code>f</code>の型次第であり、現状ではHaskellで依存型をもつ変数のシグネチャを指定する方法はない。このことはセクション<a href="#a%E5%8D%98%E7%9B%B8%E6%80%A7">4.5.4</a>で説明される)</p>
<p>もし、与えられた問題が変数<em>f</em>のシグネチャを含むなら、その時各々の<em>f</em>の使用は宣言された型を持つように扱われる。
もし同じ型が定義している<em>f</em>の実体へ推論されることもできなければ、静的エラーである。</p>
<p>もし変数<code>f</code>が対応する型シグネチャ宣言を提供しないで定義されるなら、その時それ自身の宣言グループ(セクション<a href="#a%E9%96%A2%E6%95%B0%E3%81%A8%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E6%9D%9F%E7%B8%9B%E3%81%AE%E9%9D%99%E7%9A%84%E3%81%AA%E6%84%8F%E5%91%B3%E8%AB%96">4.5</a>)の外側の各<code>f</code>の使用は対応する推論される型、または <strong>主要な</strong> 型を持つように扱われる。
しかしながら、型推論がまだ可能であることを保証するために、定義する実体とその宣言グループを伴う全ての<code>f</code>の使用が同じ単相型を持たなければいけない。(セクション<a href="#a%E4%B8%80%E8%88%AC%E5%8C%96">4.5.2</a>で述べるように、主要な型は一般化によって得られる。)</p>
<p>例えば、もし以下のように定義したら、</p>
<pre><code class="language-hs">sqr x  =  x⋆x
</code></pre>
<p>その時その主要な型は<code>sqr  ::  ∀ a.  Num  a  ⇒  a  →  a</code>であり、<code>sqr 5</code>または<code>sqr 0.1</code>のような適用を許す。
次のようにより明確に型を宣言することも正常である。</p>
<pre><code class="language-hs">sqr :: Int -&gt; Int
</code></pre>
<p>しかし、この場合<code>sqr 0.1</code>のような適用は不正である。
次のような型シグネチャは</p>
<pre><code class="language-hs">sqr :: (Num a, Num b) =&gt; a -&gt; b     -- invalid  
sqr :: a -&gt; a                       -- invalid
</code></pre>
<p>それらは<code>sqr</code>の主要な型より一般的であるが、不正である。</p>
<p>型シグネチャは <strong>多相的再帰</strong> をサポートすることにも使われることができる。
次の定義は異常であるが、型シグネチャを使って推論されるものよりも一般的な型をどのようにして指定すればよいか、ということのよい説明である。</p>
<pre><code class="language-hs">data T a  =  K (T Int) (T a)
f         :: T a -&gt; a
f (K x y) =  if f x == 1 then f y else undefined
</code></pre>
<p>もしシグネチャ宣言を取り除くなら、<code>f</code>の型は<code>f</code>への引数が<code>T Int</code>である初めの再帰的な呼び出しの結果、<code>T Int -&gt; Int</code>のように推論される。
多相的再帰はユーザーが<code>T a -&gt; a</code>のように、より一般的な型シグネチャを供給することを許可する。</p>
<a class="header" href="#結合性宣言" id="結合性宣言"><h3>結合性宣言</h3></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>gendecl</em></td><td>→</td><td><em>fixity</em> [<em>integer</em>] <em>ops</em></td><td> </td></tr>
<tr><td><em>fixity</em></td><td>→</td><td><code>infixl</code> | <code>infixr</code> | <code>infix</code></td><td> </td></tr>
<tr><td><em>ops</em></td><td>→</td><td>    <em>op<sub>1</sub></em> , … , <em>op<sub>n</sub></em> </td><td>(<em>n</em> ≥ 1)</td></tr>
<tr><td><em>op</em></td><td>→</td><td>     <em>varop</em> | <em>conop</em> </td><td> </td></tr>
</tbody></table>
<p>結合性宣言は一つ以上の演算子の結合性と束縛の優先順位を与える。
結合性宣言の中の<em>integer</em>は0から9の範囲でなければならない。
結合性宣言は型シグネチャが現れるところや、型シグネチャのように各自の演算子のプロパティを宣言する場所ならどこでも現れることができる。
また型シグネチャのように、結合性宣言は演算子の宣言と同じ宣言の列でのみ出現することができ、そして演算子に対しては高々1つの結合性宣言のみ与えてよい。
(クラスメソッドは小さな例外であり、それらの結合性宣言はクラス宣言の中またはトップレベルに出現できる。)</p>
<p>non-とleft-、right-結合(それぞれ<code>infix</code>と<code>infixl</code>、<code>infixr</code>)の3種類の結合性と、0から9を含んだ(レベル0は最も小さい結合を束縛し、レベル9は最も大きい結合を束縛する)10の優先順位のレベルがある。
もし <strong>桁</strong> が省略されるなら、レベル9と仮定される。
結合性宣言を欠いた演算子は<code>infixl 9</code>と仮定される(結合性の使い方のより詳細はセクション<a href="chapters/./3-expressions.html">3</a>を参照)。</p>
<p>テーブル<a href="#table-4.1">4.1</a>はPreduleに定義された演算子の結合性と優先順位をリストアップする。</p>
<hr />
<p><a name="table-4.1"></a></p>
<table><thead><tr><th>優先順位</th><th>                                 左結合演算子</th><th>                                               非結合演算子</th><th>               右結合演算子</th></tr></thead><tbody>
<tr><td align="right">      9</td><td align="left">                                          <code>!!</code></td><td align="left">                                                            </td><td align="left">                        <code>.</code> </td></tr>
<tr><td align="right">      8</td><td align="left">                                              </td><td align="left">                                                            </td><td align="left">             <code>^</code>, <code>^^</code>,<code>⋆⋆</code> </td></tr>
<tr><td align="right">      7</td><td align="left"> <code>⋆</code>,<code>/</code>,<code>'div'</code>,<br><code>'mod'</code>,<code>'rem'</code>, <code>'quot'</code></td><td align="left">                                                            </td><td align="left">                            </td></tr>
<tr><td align="right">      6</td><td align="left">                                         <code>+,-</code></td><td align="left">                                                            </td><td align="left">                            </td></tr>
<tr><td align="right">      5</td><td align="left">                                              </td><td align="left">                                                            </td><td align="left">                  <code>:</code>, <code>++</code> </td></tr>
<tr><td align="right">      4</td><td align="left">                                              </td><td align="left"> <code>==</code>, <code>/=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>,<br><code>'elem'</code>, <code>'notElem'</code> </td><td align="left">                            </td></tr>
<tr><td align="right">      3</td><td align="left">                                              </td><td align="left">                                                            </td><td align="left">                       <code>&amp;&amp;</code> </td></tr>
<tr><td align="right">      2</td><td align="left">                                              </td><td align="left">                                                            </td><td align="left">  <code>||</code> </td></tr>
<tr><td align="right">      1</td><td align="left">                                   <code>&gt;&gt;</code>, <code>&gt;&gt;=</code></td><td align="left">                                                            </td><td align="left">                            </td></tr>
<tr><td align="right">      0</td><td align="left">                                              </td><td align="left">                                                            </td><td align="left">          <code>$</code>, <code>$!</code>, <code>'seq'</code></td></tr>
</tbody></table>
<p><strong>テーブル4.1</strong> Prelude演算子の優先順位と結合性</p>
<hr />
<p>結合性は型と同様に特定の実体(コンストラクタまたは変数)の性質であり、実体がもつ <strong>名前</strong> のプロパティではない。
例えば、</p>
<pre><code class="language-hs">module Bar( op ) where  
  infixr 7 ‘op‘  
  op = ...  

module Foo where  
  import qualified Bar  
  infix 3 ‘op‘  

  a ‘op‘ b = (a ‘Bar.op‘ b) + 1  

  f x = let  
            p ‘op‘ q = (p ‘Foo.op‘ q) ⋆ 2  
        in ...
</code></pre>
<p>ここでの、<code>'Bar.op'</code>は<code>infixr 7</code>で、<code>‘Foo.op‘</code>は<code>infix 3</code>であり、<code>f</code>の右手側の<code>op</code>のネストされた定義は<code>infixl 9</code>のデフォルトの結合性を持つ。
(ネストされた結合性宣言を伴う<code>op</code>のネストされた定義に結合性を与えることもまた可能であろう。)</p>
<a class="header" href="#関数とパターン束縛" id="関数とパターン束縛"><h3>関数とパターン束縛</h3></a>
<table><thead><tr></tr></thead><tbody>
<tr><td>  <em>decl</em></td><td>→</td><td>(<em>funlhs</em> | <em>pat</em>) <em>rhs</em></td><td> </td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td><em>funlhs</em></td><td>→</td><td><em>var</em> <em>apat</em> <code>{</code> <em>apat</em> <code>}</code></td><td> </td></tr>
<tr><td>            </td><td>|</td><td><em>pat</em> <em>varop</em> <em>pat</em></td><td> </td></tr>
<tr><td>            </td><td>|</td><td> <code>(</code> <em>funlhs</em> <code>)</code> <em>apat</em> <code>{</code> <em>apat</em> <code>}</code></td><td> </td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td>   <em>rhs</em></td><td>→</td><td><code>=</code> <em>exp</em> [<code>where</code> <em>decls</em>]</td><td> </td></tr>
<tr><td>          </td><td>|</td><td>     <em>gdrhs</em> [<code>where</code> <em>decls</em>]</td><td> </td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td> <em>gdrhs</em></td><td>→</td><td><em>guards</em> = <em>exp</em> <code>[</code><em>gdrhs</em><code>]</code></td><td> </td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td><em>guards</em></td><td>→</td><td> | <em>guard<sub>1</sub></em>, …, <em>guard<sub>n</sub></em></td><td>(<em>n</em> ≥ 1)</td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td><em>guard</em></td><td>→</td><td><em>pat</em> <code>&lt;-</code> <em>infixexp</em>           </td><td>(pattern guard)</td></tr>
<tr><td>         </td><td>|</td><td><code>let</code> <em>decls</em>                        </td><td>(local declaration)</td></tr>
<tr><td>         </td><td>|</td><td><em>infixexp</em>                           </td><td>(boolean guard)</td></tr>
</tbody></table>
<p>この文法に置いて我々は次の2つのケースを区別する: <strong>パターンの束縛</strong> がおきているとき(そのとき左手側は<code>pat</code>である)と、それ以外の <strong>関数束縛</strong> と呼ばれる束縛がおきているときである。
どちらの束縛もモジュールのトップレベルでまたは<code>where</code>か<code>let</code>の構成物の範囲で現れることができる。</p>
<a class="header" href="#関数束縛" id="関数束縛"><h4>関数束縛</h4></a>
<p>関数束縛は関数の値に変数を束縛する。
変数<em>x</em>へ束縛する関数の一般的な形式は以下のものである。</p>
<pre><code><em>x	p<sub>11</sub> … p<sub>1k</sub>	match<sub>1</sub></em>
…
<em>x	p<sub>n1</sub> … p<sub>nk</sub>	match<sub>n</sub></em>
</code></pre>
<p>上の各<em>p<sub>ij</sub></em>はパターンで、各<em>match<sub>i</sub></em>は次の一般的形式</p>
<pre><code>= <em>e<sub>i</sub></em> where { <em>decls<sub>i</sub></em> }
</code></pre>
<p>または、</p>
<pre><code>| <em>gs<sub>i1</sub>  =  e<sub>i1</sub> </em>
…
 | <em>gs<sub>imi</sub></em>  =  <em>e<sub>im<sub>i</sub></sub></em>
            where { <em>decls<sub>i</sub></em> }
</code></pre>
<p>であり、<em>n</em> ≥ 1, 1 ≤ <em>i</em> ≤ <em>n</em>, <em>m<sub>i</sub></em> ≥ 1である。
前者は後者の特別な場合であるので、簡略記法として扱われる。
すなわち、</p>
<pre><code> | `True` = <em>e<sub>i</sub></em> `where` { <em>decls<sub>i</sub></em> } </code></pre>
<p>注意点として関数を定義している全ての句は隣接しなければならず、各句の中のパターンの数は同じでなければならない。
各適合に対応するパターンのセットは<strong>線形</strong>でなければならず、変数がその実体のセットの中に一回以上現れることは許されていない。</p>
<p>関数の値を中置演算子に束縛するための代わりの構文が与えられている。
例えば、これらの3つの関数定義は全て等しい。</p>
<pre><code class="language-hs">plus x y z = x+y+z
x ‘plus‘ y = \ z -&gt; x+y+z
(x ‘plus‘ y) z = x+y+z
</code></pre>
<p>結合性の解決は、関数の束縛を中置にしたものにも式の場合と同様に適用することに注意せよ(セクション<a href="chapters/./10-syntax-reference.html#a">10.6</a>)。
関数束縛に等しい左側に適用している結合性の解決はトップレベルで定義されている<em>varop</em>を残さなければいけない。
例えば、もし優先度6で新しい演算子<em>##</em>を定義しているなら、その時この定義は不正である。</p>
<pre><code class="language-hs">a ## b : xs = exp
</code></pre>
<p>なぜなら、<code>:</code>は優先度5を持ち、従って左手側は<code>(a <em>##</em> x) : xs</code>に解決され、この式は<code>(a <em>##</em> x)</code>が正常なパターンでないためパターン束縛にはできない</p>
<div class="column">
<p><strong>変換:</strong> 関数への一般的な束縛の形式はこの等式に構文的に等しい(すなわち:シンプルなパターン束縛)。</p>
<pre><code><em>x</em> = \ <em>x<sub>1</sub></em> … <em>x<sub>k</sub></em> -> case (<em>x<sub>1</sub></em>, …, <em>x<sub>k</sub></em>) of
(<em>p<sub>11</sub></em>, …, <em>p<sub>1k</sub></em>) <em>match<sub>1</sub></em>
…
(<em>p<sub>n1</sub></em>, …, <em>p<sub>nk</sub></em>) <em>match<sub>n</sub></em>
</code></pre>
<p><em>x<sub>i</sub></em>は新しい識別子である。</p>
</div>
<a class="header" href="#パターン束縛" id="パターン束縛"><h4>パターン束縛</h4></a>
<p>パターン束縛は値に変数を束縛する。
<strong>シンプルな</strong> パターン束縛は<em>p = e</em>の形式を持つ。
まるでその前に暗黙の<code>~</code>があるかのように、パターン<em>p</em>は反駁できないパターンとして「遅延的に」適合される。
セクション<a href="chapters/./3-expressions.html#aLet%E5%BC%8F">3.12</a>にその変換を確かめられる。</p>
<p>パターン束縛の <strong>一般的な</strong> 形式は <strong>p適合</strong> であり、<strong>適合</strong> は上記の関数束縛において同じ構造である。
言い換えると、パターン束縛は以下のものである。</p>
<pre><code><em>p</em> | <em>gs<sub>1</sub></em> = <em>e<sub>1</sub></em>
  | <em>gs<sub>2</sub></em> = <em>e<sub>2</sub></em>
    …
  | <em>gs<sub>m</sub></em> = <em>e<sub>m</sub></em>
  where { <em>decls</em> }
</code></pre>
<div class="column">
<p><strong>変換：</strong> 上記のパターン束縛はこのシンプルなパターン束縛と構文的に等しい。</p>
<pre><code><em>p</em> = let <em>decls</em> in
    case () of
      () | <em>gs<sub>1</sub></em> -> <em>e<sub>1</sub></em>
         | <em>gs<sub>2</sub></em> -> <em>e<sub>2</sub></em>
           …
         | <em>gs<sub>m</sub></em> -> <em>e<sub>m</sub></em>
       _ -> error "Unmatched pattern"
</code></pre>
</div>
<a class="header" href="#関数とパターン束縛の静的な意味論" id="関数とパターン束縛の静的な意味論"><h2>関数とパターン束縛の静的な意味論</h2></a>
<p>関数の静的意味論と<code>let</code>式または<code>where</code>句のパターン束縛はこのセクションで論じる。</p>
<a class="header" href="#依存の解析" id="依存の解析"><h3>依存の解析</h3></a>
<p>一般的に静的意味論は通常のHindley-Milner推論規則を適用することによって与えられる。
多相性を増加するために、これらの規則は <strong>依存の解析</strong> によって見分けられる束縛のグループに適用される。</p>
<p>もし次のいずれかであるなら、束縛<em>b1</em>は同じ宣言のリストの中の束縛<em>b2</em>に依存する。</p>
<ol>
<li><em>b1</em>は自由識別子で、型シグネチャを持たず<em>b2</em>によって束縛されるようなものを含む。または、</li>
<li><em>b1</em>は<em>b2</em>に依存する束縛に依存する。</li>
</ol>
<p><strong>宣言のグループ</strong> は相互依存の束縛の最小限のひと組である。
Hindley-Milner型推論は依存の順序に各宣言グループに適用される。
<code>where/let</code>の構成物の中の宣言の順序は無意味である。</p>
<a class="header" href="#一般化" id="一般化"><h3>一般化</h3></a>
<p>Hindley-Milner型システムは次の2段階でlet式に型を割り当てる。</p>
<ol>
<li>宣言グループは依存している順に考慮される。
各グループにおいて、全称量化を伴わない型がそのグループに束縛される各変数へ推論される。
その時、これらの型に現れる全ての型変数は型環境に束縛された変数を連帯されるにも限らず全称量化される。
このことを一般化と呼ばれる。</li>
<li>最後に、let式の本体は型付けされる。</li>
</ol>
<p>例えば、次の宣言を考えてほしい。</p>
<pre><code class="language-hs">f x = let g y = (y,y)  
    in ...
</code></pre>
<p><code>g</code>の定義の型は<em>a  →  (a,a)</em>である。
一般化は、<code>g</code>に対して多相型∀ <em>a. a → (a,a)</em>を紐づけ、そのあと<code>&quot;...&quot;</code>の部分の型付けが続けられる。</p>
<p>オーバーロードされた定義に型を付ける時、単一の宣言グループにおけるすべてのオーバーロードしている制約は集められる。それはグループで宣言された各変数の型の文脈を作るためである。
例えば、以下の定義において</p>
<pre><code class="language-hs">f x = let g1 x y = if x&gt;y then show x else g2 y x  
          g2 p q = g1 q p  
      in ...
</code></pre>
<p><code>g1</code>と<code>g2</code>の定義の型は両方<code><em>a</em>  →  <em>a</em>  →  String</code>であり、
累算された制約は<code>Ord <em>a</em></code>(<code>&gt;</code>の使用から発生する)と、<code>Show <em>a</em></code>(<code>show</code>の使用から発生する)である。
この制約の収集に現れる型変数は<strong>制約された型変数</strong>と呼ばれる。</p>
<p>一般化の手順は型<code>∀ <em>a</em>. (Ord <em>a</em>, Show <em>a</em>)  ⇒  <em>a</em>  →  <em>a</em>  →  String</code>という<code>g1</code>と<code>g2</code>両方に帰属する。
<code>&gt;</code>と<code>show</code>が<code>g1</code>の定義にあるのに、<code>g2</code>は<code>g1</code>と同じ方法にオーバーロードされることに注目してほしい。</p>
<p>プログラマがある宣言グループの2つ以上の変数に明示的な型シグネチャを与えたならば、それらのシグネチャの文脈は型変数の名前の取り換えを除いて一致しなければならない。</p>
<a class="header" href="#文脈の簡約エラー" id="文脈の簡約エラー"><h3>文脈の簡約エラー</h3></a>
<p>セクション<a href="#a%E5%9E%8B%E3%81%A8%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%AE%E6%84%8F%E5%91%B3%E8%AB%96">4.1.4</a>で言及されたように、型の文脈は型変数または一つ以上の型変数の適用のみ制約できる。
よって、一般化によって生成された型は全ての文脈の制約が「頭部正規形」に簡約されなければいけない形式に表現されなければならない。
例として、次の定義を考えてもらいたい。</p>
<pre><code class="language-hs">xs y  =  xs == [y]
</code></pre>
<p>その型は次のもので与えられ、</p>
<pre><code class="language-hs">f :: Eq a =&gt; [a] -&gt; a -&gt; Bool
</code></pre>
<p>以下のものではない。</p>
<pre><code class="language-hs">f :: Eq [a] =&gt; [a] -&gt; a -&gt; Bool
</code></pre>
<p>等号はリストに対して使われているが、文脈は簡単な形にしなければならず、一般化の前にリストに対する<code>Eq</code>のインスタンス宣言を用いて行う。
もしそのようなインスタンスがスコープ内に無いなら、静的エラーが起きる。</p>
<p>ここには<em>m</em>が一般化された型変数のひとつである形式<em>C (m t)</em>の制約のための要求を示す例がある。
すなわち、クラスCを型変数または型コンストラクタではない型式に適用する場合である。
次のものを考えてもらいたい。</p>
<pre><code class="language-hs">f :: (Monad m, Eq (m a)) =&gt; a -&gt; m a -&gt; Bool  
f x y = return x == y
</code></pre>
<p><code>return</code>の型は<code>Monad m =&gt; a -&gt; m a</code>であり、<code>(==)</code>の型は<code>Eq a =&gt; a -&gt; a -&gt; Bool</code>である。
<code>f</code>の型は従って<code>(Monad m, Eq (m a)) =&gt; a -&gt; m a -&gt; Bool</code>であるべきで、その文脈はそれ以上簡易化されることはできない。</p>
<p>データ型<code>deriving</code>句(セクション<a href="#a%E5%B0%8E%E5%87%BA%E3%81%95%E3%82%8C%E3%81%9F%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9">4.3.3</a>)から派生したインスタンス宣言は、あらゆるインスタンス宣言のように、<strong>簡単な文脈</strong>を持たなければならない。
すなわち、全ての制約は<em>a</em>が型変数である形式<em>C a</em>でなければならない。
例えば、以下の型において</p>
<pre><code class="language-hs">data Apply a b = App (a b)  deriving Show
</code></pre>
<p>導出されたShowインスタンスは文脈<code>Show (a b)</code>を生成し、そしてそれは簡約されることはできず、かつシンプルではないゆえに静的エラーが結果として生じる。</p>
<a class="header" href="#単相性" id="単相性"><h3>単相性</h3></a>
<p>時々、その定義の型の中に使用されるすべての型変数にわたる一般化ができないことがある。
例えば、次の宣言を考える。</p>
<pre><code class="language-hs">f x = let g y z = ([x,y], z)  
      in ...
</code></pre>
<p><code>x</code>が型<em>a</em>を持ち、<code>g</code>の定義の型は<em>a  →  b  →  ([a],b)</em>という環境である。
一般化の手順は型<code>∀ <em>b</em>.  <em>a</em>  →  <em>b</em>  →  <em>([a],b)</em></code>という<code>g</code>に帰属する。
<em>a</em>が型環境に現れているため、<em>b</em>のみが全称量化されることが可能である。
このことを<code>g</code>の型が<strong>型変数aに単相的</strong>であると言う。</p>
<p>そのような単相性の結果として<code>g</code>の全ての適用の初めの引数が単一の型でなければならない。
例えば、次の式は<code>”...”</code>に有効であろう。</p>
<pre><code class="language-hs">(g True, g False)
</code></pre>
<p>(ついでに言うと<code>x</code>を<code>Bool</code>型を持つよう強制させる。)　しかし次のものは不正である。</p>
<pre><code class="language-hs">(g True, g 'c')
</code></pre>
<p>一般的にもし<code>a</code>が<code>∀ <span class="overline">u</span>. <em>cx  ⇒  t</em>.</code>の中で自由なら、型<code>∀ <em>u. cx  ⇒  t</em></code>は型変数<em>a</em>に<strong>単相的</strong>であると言われる。</p>
<p>Haskellによって与えられる明示的な型シグネチャは単相的な型変数を含む型を表現するのに十分な力がないことには注意すべきである。
例えば、次のものは書くことができない。</p>
<pre><code class="language-hs">f x = let  
        g :: a -&gt; b -&gt; ([a],b)  
        g y z = ([x,y], z)  
      in ...
</code></pre>
<p>なぜなら、あれは<code>g</code>が<code>a</code>と<code>b</code>の両方に多相的であることを要求されるからだ(セクション<a href="#a%E5%9E%8B%E3%82%B7%E3%82%B0%E3%83%8D%E3%83%81%E3%83%A3">4.4.1</a>)。
このプログラムでは、<code>g</code>は最初の引数が型変数を含まないものに制限された場合にのみ型シグネチャを与えられる。
例えば、</p>
<pre><code class="language-hs">g :: Int -&gt; b -&gt; ([Int],b)
</code></pre>
<p>このシグネチャは<code>Int</code>型を持つ<code>x</code>ももたらすだろう。</p>
<a class="header" href="#単相性の制限" id="単相性の制限"><h3>単相性の制限</h3></a>
<p>Haskellは上記の標準Hindley-Milner制限の範囲を超えて、一般化の手順に一定の余分な制限を配置し、特定の場合において多相性をさらに削減する。</p>
<p>単相性の制限は変数の束縛する構文に依存する。
変数は <strong>関数束縛</strong> または <strong>パターン束縛</strong> のどちらかによって束縛されることを思い出してほしい。
しかも、 <strong>単純な</strong> パターン束縛はそのパターンが単一の変数のみで構成するパターン束縛である(セクション<a href="#a%E9%96%A2%E6%95%B0%E3%81%A8%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E6%9D%9F%E7%B8%9B">4.4.3</a>)。</p>
<p>次の2つのルールは単相性の制限を定義する。</p>
<div class="column">
<p><strong>単相性の制限</strong></p>
<ul>
<li>
<p><strong>ルール1</strong><br>
次の条件を満たすとき、与えられた宣言グループが <strong>非制限的</strong> であるという。</p>
<ul>
<li><strong>(a):</strong><br>
グループ内の各変数は関数束縛または単純なパターン束縛によって束縛される(セクション<a href="%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E6%9D%9F%E7%B8%9B">4.4.3.2</a>)。かつ、</li>
<li><strong>(b):</strong><br>
単純なパターン束縛によって束縛されるようなグループ内のすべての変数に対して明示的な型シグネチャが与えられている。</li>
</ul>
<p>Hindley-Milnerの多相性に関する通常の制限とは、環境に自由に出現しない型変数のみが一般化されるというものである。
それに加えて、該当するグループの一般化のステップにおいて、<strong>制限的な宣言グループの制約された型変数は一般化されない場合がある</strong>。
(もし同じ型クラスに属さないといけないなら、型変数が制約されていることを思い出すこと。セクション<a href="#a%E4%B8%80%E8%88%AC%E5%8C%96">4.5.2</a>を参照。)</p>
</li>
<li>
<p><strong>ルール2</strong><br>
全部のモジュールへの型推論が完了した時に残るあらゆる単相的な型変数は曖昧だと考えられ、そしてデフォルトのルールを使用した各々の型に解決される(セクション<a href="#a%E6%9B%96%E6%98%A7%E3%81%AA%E5%9E%8B%E3%81%A8%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AD%E3%83%BC%E3%83%89%E3%81%95%E3%82%8C%E3%81%9F%E6%95%B0%E5%80%A4%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E6%97%A2%E5%AE%9A%E5%80%A4">4.3.4</a>)。</p>
</li>
</ul>
</div>
<p><strong>動機</strong>　ルール1は2つの理由により要求され、両方ともかなり巧妙である。</p>
<ul>
<li>
<p><strong>ルール1は思いがけなく繰り返されることから計算を防止する。</strong>
例えば、<code>genericLength</code>は型が次のもので与えられる(<code>Data.List</code>ライブラリの)標準関数である。</p>
<pre><code class="language-hs">genericLength :: Num a =&gt; [b] -&gt; a
</code></pre>
<p>では、次の式を考えて欲しい。</p>
<pre><code class="language-hs">let { len = genericLength xs } in (len, len)
</code></pre>
<p>まるで<code>len</code>が一度だけ計算されるべきかのように見れるが、ルール1がなければ2回の異なるオーバーロード毎に一回づつで、計二回計算されるであろう。
もしプログラマが実際に計算が繰り返されてほしいと考えているなら、明示的な型シグネチャを追加するだろう。</p>
<pre><code class="language-hs">let { len :: Num a =&gt; a; len = genericLength xs } in (len, len)
</code></pre>
</li>
<li>
<p><strong>ルール1は曖昧さを防止する</strong>。例えば、次の宣言グループを考えてほしい。</p>
<pre><code class="language-hs">[(n,s)] = reads t
</code></pre>
<p><code>reads</code>は型がシグネチャによって与えられる標準関数であることを思い出してほしい。</p>
<pre><code class="language-hs">reads :: (Read a) =&gt; String -&gt; [(a,String)]
</code></pre>
<p>ルール1なしで、<code>n</code>は型<code>∀ <em>a</em>. Read <em>a  ⇒  a</em></code>を割り当てられるであろう。そして、<code>s</code>は型<code>∀ <em>a</em>. Read <em>a</em> ⇒  String</code>である。
後者は不正な型である、なぜなら本質的に曖昧であるからだ。
<code>s</code>を使うオーバーロードするもので決定することは可能ではなく、そして<code>s</code>に型シグネチャを追加することで解決されることもできない。
このゆえに、<strong>単純ではないパターン</strong>束縛が使われている時(セクション<a href="#a%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E6%9D%9F%E7%B8%9B">4.4.3.2</a>)、型シグネチャが与えられるかどうかにかかわりなく、推論された型はそれらの制約された型変数の中で常に単相的である。
この場合において、<code>n</code>と<code>s</code>の両者は<em>a</em>に単相的である。</p>
<p>同じ制約はパターン束縛関数に適用する。
例えば、次の中の</p>
<pre><code class="language-hs">(f,g) = ((+),(-))
</code></pre>
<p><code>f</code>と<code>g</code>の両者は<code>f</code>または<code>g</code>に与えられる型シグネチャにかかわらず単相的である。</p>
</li>
</ul>
<p>ルール2は現在のモジュールの外側のモジュール上で型推論を行うことを除いて、<strong>エクスポートされた</strong>束縛の単相的な使用を強いるための方法がないことから要求される。
ルール2はモジュール内に束縛された全変数の正確な型がそのモジュールのみで決定されなければならないことを述べ、それをインポートするモジュールによってではないことを述べている。</p>
<pre><code class="language-hs">module M1(len1) where
default( Int, Double )
len1 = genericLength &quot;Hello&quot;

module M2 where
  import M1(len1)
  len2 = (2⋆len1) :: Rational
</code></pre>
<p>モジュール<code>M1</code>上の型推論が完了した時、<code>len1</code>は(ルール1によって)単相的な型<code>Num a =&gt; a</code>を持つ。
ルール2はそのとき単相的な型変数<code>a</code>が曖昧であると述べ、セクション<a href="#a%E6%9B%96%E6%98%A7%E3%81%AA%E5%9E%8B%E3%81%A8%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AD%E3%83%BC%E3%83%89%E3%81%95%E3%82%8C%E3%81%9F%E6%95%B0%E5%80%A4%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E6%97%A2%E5%AE%9A%E5%80%A4">4.3.4</a>の既定のルールを使い解決されなければならない。
それゆえに、<code>len1</code>が型<code>Int</code>を取得し、<code>len2</code>の中の使用は誤った型である。
(もし上記のコードが実際に求められるなら、<code>len1</code>上の型シグネチャはその問題を解決するであろう。)</p>
<p>この問題はネストされた束縛では起きない。なぜなら、それらの全体のスコープがコンパイラに見えているからだ。</p>
<p><strong>結果</strong>
単相性ルールはプログラマに多くの結果をもたらす。
関数構文を用いて定義されたどんなものも、通常期待されるような関数に一般化される。
例として、</p>
<pre><code class="language-hs">f x y = x+y
</code></pre>
<p>関数<code>f</code>はクラス<code>Num</code>にオーバーロードするもので使われる。
ここに再計算の危険はない。
しかしながら、次のパターン構文を伴い定義される同じ関数は、</p>
<pre><code class="language-hs">f = \x -&gt; \y -&gt; x+y
</code></pre>
<p>もし<code>f</code>が完全にオーバーロードされるなら型シグネチャを要求する。
多くの関数は単純なパターン束縛を使用してたいてい自然に定義される。
ユーザーは、完全なオーバーローディングを保つためには型シグネチャを添えることを心掛けなければならない。
標準Preludeはこのことのたくさんの例を含む。</p>
<pre><code class="language-hs">sum  :: (Num a) =&gt; [a] -&gt; a  
sum  =  foldl (+) 0   
</code></pre>
<p>ルール1はトップレベルとネストされた定義の両方に適用する。
次のものを考えてほしい。</p>
<pre><code class="language-hs">module M where  
  len1 = genericLength &quot;Hello&quot;  
  len2 = (2⋆len1) :: Rational
</code></pre>
<p>ここで、型推論は<code>len1</code>が単相的な型<code>(Num a =&gt; a)</code>を持つことを探し、その型変数<code>a</code>は<code>len2</code>上の型推論を行う時に<code>Rational</code>に解決される。</p>
<a class="header" href="#カインドの推論" id="カインドの推論"><h2>カインドの推論</h2></a>
<p>このセクションは <strong>カインドの推論</strong> 、すなわち与えられたプログラムに現れる各型コンストラクタとクラスに適切なカインドを計算することに使われるルールを述べる。</p>
<p>カインドの推論の工程の最初の手順は依存グループデータ型やシノニム、クラス定義のセットを整理することである。
これはセクション<a href="#a%E9%96%A2%E6%95%B0%E3%81%A8%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E6%9D%9F%E7%B8%9B%E3%81%AE%E9%9D%99%E7%9A%84%E3%81%AA%E6%84%8F%E5%91%B3%E8%AB%96">4.5</a>で述べられた値宣言の依存解析のように同じ方法を多く成し遂げられることができる。
例えば、次のプログラムの断片はデータ型コンストラクタ<code>D</code>とシノニム<code>S</code>、クラス<code>C</code>の定義を含み、
その全ては同じ依存グループに含まれているであろう。</p>
<pre><code class="language-hs">data C a =&gt; D a = Foo (S a)  
type S a = [D a]  
class C a where  
    bar :: a -&gt; D a -&gt; Bool
</code></pre>
<p>各グループ内の変数やコンストラクタ、クラスのカインドは型推論とカインドを保存するユニフィケーションの標準的なテクニックを用いて決定される[<a href="chapters/../bibliography.html">8</a>]。
例えば上で定義した中で、パラメータ<code>a</code>は<code>bar</code>の型の関数コンストラクタ<code>(-&gt;)</code>の引数のように現れ、これゆえにカインド<code>∗</code>を持たなければならない。
それは<code>D</code>と<code>S</code>の両方がカインド<code>∗→∗</code>を、かつクラス<code>C</code>の全インスタンスがカインド<code>∗</code>を持たなければならないということを結果として生ずる。</p>
<p>推論されたカインドのいくつかの部分は対応する定義によっておそらく完全に決定されないであろうことも起こりうる。
そのような場合、<code>∗</code>の既定値は推測される。
例えば、次の例の各々の<code>a</code>パラメータに任意のカインド<em>κ</em>を推測できるだろう。</p>
<pre><code class="language-hs">data App f a = A (f a)  
data Tree a  = Leaf | Fork (Tree a) (Tree a)
</code></pre>
<p>これは任意のカインド<code><em>κ</em></code>に対して、それぞれ<code>App</code>と<code>Tree</code>にカインド<code>(<em>κ</em> →∗) → <em>κ</em> →∗</code>と<code><em>κ</em> →∗</code>を与えるであろう。
そして、多相的なカインドを許すように拡張を要求するであろう。
代わりに、デフォルト束縛<code><em>κ</em> = ∗</code>を用いれば、これら2つのコンストラクタへ与えられる実際のカインドはおのおの、<code>(∗→∗) →∗→∗</code>と<code>∗→∗</code>になる。</p>
<p>既定値は特別な型コンストラクタ定数またはクラスが後ろの依存グループまたはプログラムの他の場所で使われる方法の検討なしで各依存グループに与えられる。
例として、上のソースコードに次に続く定義を追加することは(例えば<code>(∗→∗) →∗</code>に変化することによって)<code>Tree</code>へ推論されたカインドに影響を及ぼさない。
そして代わりに静的エラーを生成する。
なぜなら<code>[], ∗→∗,</code>のカインドは<code>Tree</code>の引数へ期待されるカインド<code>∗</code>と適合しないからだ。</p>
<pre><code class="language-hs">type FunnyTree = Tree []     -- invalid
</code></pre>
<p>これは各コンストラクタとクラスがスコープ内にある時はいつでも同じカインドで一貫して使われていることを保証するため重要である。</p>
<a class="header" href="#モジュール" id="モジュール"><h1>モジュール</h1></a>
<p>モジュールは(他のモジュールからスコープの中へもたらされたリソースの) <strong>インポート</strong> の一式によって作成された環境の中の値やデータ型、型シノニム、クラスなど(<a href="chapters/./4-declarations-and-bindings.html">４</a>章を参照)の集まりを定義する。
これらのリソースのいくつかを <strong>エクスポート</strong> し、他のモジュールでそれらを利用できるようにする。
モジュールの中で定義された、またはその中へインポートされた、あるいはエクスポートされた値または型クラスに参照するために項の <strong>エンティティ</strong> を使用する。</p>
<p>Haskell <strong>プログラム</strong> はモジュールの集まりであり、その中の一つから規約により、<code>Main</code>が呼ばれなければならず、かつ<code>main</code>値をエクスポートしなければいけない。
プログラムの <strong>値</strong> はモジュール<code>Main</code>の中の識別子<code>main</code>の値であり、そしていくつかの型<code>τ</code>のための型<code>IO τ</code>の計算結果でなければいけない(<a href="chapters/./7-basic-input-output.html">７</a>章を参照)。
プログラムが実行されたとき、計算結果<code>main</code>は行わられ、(型<code>τ</code>の)その結果は捨てられる。</p>
<p>モジュールは明示的な<code>import</code>宣言により他のモジュールを参照することができ、
その各々でインポートされたモジュールの名前を与え、かつインポートされるためにそのエンティティを明記する。
モジュールは互いに再帰的にインポートされることもできる。</p>
<p>モジュールは名前空間の制御に使われ、かつファーストクラス値ではない。
複数のモジュールからなるHaskellのプログラムは、単一のモジュールのプログラムに、各エンティティに一意な名前を与え、その参照が出現する全ての場所を適切に一意な名前に変えて全てのモジュールの本体<sup><a href="#footnote-1">1</a></sup>の名前を連結することにより変換することができる。</p>
<p>例えば、ここに３つのモジュールプログラムがある。</p>
<pre><code class="language-hs">module Main where  
    import A  
    import B  
    main = A.f &gt;&gt; B.f  

module A where  
    f = ...  

module B where  
    f = ... 
</code></pre>
<p>それは次の単一モジュールプログラムに等しい。</p>
<pre><code class="language-hs">module Main where  
    main = af &gt;&gt; bf  

    af = ...  

    bf = ... 
</code></pre>
<p>なぜならそれらは互いに再帰的であることが許可され、モジュールはプログラムを依存の状態に注意することなく自由に分割することを許す。</p>
<p>モジュールの名前(語彙素<em>modid</em>)は大文字で始まり、ドットで区切られ、空白をはさまない一つ以上の識別子の列である。
例えば、<code>Data.Bool</code>と<code>Main</code>、<code>Foreign.Marshal.Alloc</code>はすべて有効なモジュール名である。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>modid</em></td><td>→</td><td>{<em>conid</em> .} <em>conid</em></td><td>(modules)</td></tr>
</tbody></table>
<p>モジュール名は新しいコンポーネントを追加すると、元々のモジュール名の子を階層の中に作成し、その階層の中に配置されているように考えることができる。
例えば、モジュール<code>Contorl.Monad.ST</code>は<code>Contorl.Monad</code>下の階層の子である。
しかしこれは単なる慣習であり、言語の定義には含まれない。このリポートでは<em>modid</em>は平坦な名前空間を占有する単一の識別子のように扱われる。</p>
<p>中でも特別なモジュール Prelude が存在し、これはデフォルトで全てのモジュールにインポートされる(セクション<a href="#%E6%A8%99%E6%BA%96Prelude">5.6</a>)。
加えて、必要に応じてインポートされる標準ライブラリのモジュールの集合も特別である(Part<a href="https://www.haskell.org/onlinereport/haskell2010/haskellpa2.html#x20-192000II">2</a>を参照)。</p>
<p>(訳注:上のリンク先であるPart2はHaskell2010のライブラリの部分でこのリポートの13章から42章までを指す。)</p>
<p><a name="footnote-1"><sup>1</sup></a> この文に2つの小さな例外がある。
一つは、デフォルト宣言のスコープは単一のモジュール内のみに及ぶ(セクション<a href="chapters/./4-declarations-and-bindings.html#%E6%9B%96%E6%98%A7%E3%81%AA%E5%9E%8B%E3%81%A8%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AD%E3%83%BC%E3%83%89%E3%81%95%E3%82%8C%E3%81%9F%E6%95%B0%E5%80%A4%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E6%97%A2%E5%AE%9A%E5%80%A4">4.3.4</a>)。
二つめは、単相性の制約のルール2がモジュールの境界によって影響を受ける。</p>
<a class="header" href="#モジュールの構造" id="モジュールの構造"><h2>モジュールの構造</h2></a>
<p>モジュールは値束縛やデータ型、型シノニム、クラスなどへの宣言を含む相互再帰的なスコープを定義する(<a href="chapters/./4-declarations-and-bindings.html">4</a>章を参照)。</p>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>module</em> </td><td>→</td><td><code>module</code> <em>modid</em> [<em>exports</em>] <code>where</code> <em>body</em></td><td> </td></tr>
<tr><td>           </td><td>|</td><td><em>body</em></td><td> </td></tr>
<tr><td><em>body</em>   </td><td>→</td><td>{ <em>impdecls</em> ; <em>topdecls</em> }</td><td> </td></tr>
<tr><td>           </td><td>|</td><td>{ <em>impdecls</em> }</td><td> </td></tr>
<tr><td>           </td><td>|</td><td>{ <em>topdecls</em> }</td><td> </td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td><em>impdecls</em> </td><td>→</td><td><em>impdecl<sub>1</sub></em> ; … ; <em>impdecl<sub>n</sub></em></td><td>(<em>n</em> ≥ 1)</td></tr>
<tr><td><em>topdecls</em> </td><td>→</td><td><em>topdecl<sub>1</sub></em> ; … ; <em>topdecl<sub>n</sub></em></td><td>(<em>n</em> ≥ 1)</td></tr>
</tbody></table>
<p>モジュールは<code>module</code>キーワードとその名前、エクスポートされる(丸括弧で囲まれた)エンティティのリストをヘッダーに伴って始まる。
そのヘッダーの次にはインポートされるモジュールを明記する空かもしれない<code>import</code>宣言(<code>impdecls</code>、セクション<a href="#%E3%82%A4%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%88%E5%AE%A3%E8%A8%80">5.3</a>)のリストが続き、
必要に応じてインポートされる束縛を制限する。
これには空かもしれないトップレベルの宣言のリストが次に続くであろう(<code>topdecls</code>、<a href="chapters/./4-declarations-and-bindings.html">4</a>章)。</p>
<p>モジュールの本体のみで成るモジュールの短縮形式は許される。
もしこれが使われるなら、そのヘッダーは<code>‘module Main(main) where’</code>であると推測される。
もし短縮されたモジュールの初めの語彙素が<code>{</code>でなければ、そのときそのレイアウトルールはそのモジュールのトップレベルへ適用される。</p>
<a class="header" href="#エクスポートリスト" id="エクスポートリスト"><h2>エクスポートリスト</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td> <em>exports</em></td><td>→</td><td> ( <em>export<sub>1</sub></em> , … , <em>export<sub>n</sub></em> [ , ] )         </td><td> (<em>n</em> ≥ 0)</td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td>  <em>export</em></td><td>→</td><td> <em>qvar</em></td><td> </td></tr>
<tr><td>   </td><td>|</td><td> <em>qtycon</em> [(..) | ( <em>cname<sub>1</sub></em> , … , <em>cname<sub>n</sub></em> )] </td><td> (<em>n</em> ≥ 0)</td></tr>
<tr><td>   </td><td>|</td><td> <em>qtycls</em> [(..) | ( <em>var<sub>1</sub></em> , … , <em>var<sub>n</sub></em> )]     </td><td> (<em>n</em> ≥ 0)</td></tr>
<tr><td>   </td><td>|</td><td> <code>module</code> <em>modid</em> </td><td> </td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td>   <em>cname</em></td><td>→</td><td> <em>var</em> | <em>con</em> </td><td> </td></tr>
</tbody></table>
<p><strong>エクスポートリスト</strong>はモジュール宣言によってエクスポートされるエンティティを識別する。
モジュールの実装はそのモジュールで宣言しているまたは他のモジュールからインポートしているエンティティのみをエクスポートできる。
もしエクスポートリストが省略されるなら、モジュールの中で定義されたすべての値や型、クラスはインポートされるものを除いてエクスポートされる。</p>
<p>エクスポートリストのエンティティは次に従う名前である。</p>
<ol>
<li>
<p>値、フィールド名またはクラスメソッドはそれらがモジュールの本体またはインポートによって宣言されたものかどうかにかかわらず、
<code>qvarid</code>のように値の名前を与えることによって名前をつけることができ、そしてそれはスコープ内でなければならない。
演算子はそれらを<code>qvarids</code>に変えるために丸括弧で閉じられなければならない。</p>
</li>
<li>
<p><code>data</code>または<code>newtype</code>宣言で宣言された代数データ型<em>T</em>は次の3つの方法の一つで名前をつけることができる。</p>
<ul>
<li>形式<em>T</em>は <strong>コンストラクタまたはフィールド名によってではなく</strong>、 型によって名前がつけられる。
コンストラクタなしに型をエクスポート出来るという仕様は、抽象データ型のコンストラクタについても同様である(セクション<a href="#%E6%8A%BD%E8%B1%A1%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B">5.8</a>)。</li>
<li>形式<em>T(c<sub>1</sub>,...,c<sub>n</sub>)</em>は型とそのコンストラクタとフィールド名の複数または全ての名前である。</li>
<li>略された形式<em>T(..)</em>は(修飾されたかされていないかのどちらにしろ)現在のスコープにある型と全てのそのコンストラクタとフィールド名の名前である。</li>
</ul>
<p>全てのケースにおいて(修飾されているかもしれない)型コンストラクタ<em>T</em>はスコープになければならない。
2番目の形式の中の<em>c<sub>i</sub></em>の名前であるそのコンストラクタとフィールドは修飾されない。
これらの付随する名前の一つは次の場合にのみ正当である。
(a) <em>T</em>のコンストラクタまたはフィールドの名前である。かつ、
(b) コンストラクタまたはフィールドが <strong>修飾されるかされない名前の下のスコープ内にあるかどうかにかかわらず</strong> モジュール本体のスコープ内にある。
例えば、次のコードは正当である。</p>
<pre><code class="language-hs">module A( Mb.Maybe( Nothing, Just ) ) where  
import qualified Data.Maybe as Mb 
</code></pre>
<p>データコンストラクタは付随する名前のようなものを除いてエクスポートリストの中で名前をつけることはできない。
なぜならそうでなければ型コンストラクタから見分けられないからだ。</p>
</li>
<li>
<p><code>data</code>宣言によって宣言される型シノニム<em>T</em>は形式<em>T</em>によって名前をつけられることができ、<em>T</em>はスコープ内にある。</p>
</li>
<li>
<p><code>class</code>宣言で宣言される演算<em>f<em>1</em>,...,f<em>n</em>を伴う</em>クラス<em>C</em>は次の3つの方法のひとつから名前をつけることができる。</p>
<ul>
<li>形式<em>C</em>は <strong>クラスメソッドを除いて</strong> クラスの名前である。</li>
<li>形式<em>C(f<sub>1</sub>,...,f<sub>n</sub>)</em>はクラスとそのメソッドのいくつかまたは全ての名前である。</li>
<li>略された形式<em>C(..)</em>は(修飾されるされないか関係なく)スコープにあるクラスとその全てのメソッドの名前である。</li>
</ul>
<p>全てのケースにおいて、<em>C</em>はスコープになければならない。
2番目の形式の中で、(修飾されない)付随する名前<em>f<sub>i</sub></em>のひとつは次の場合にのみ正当である。
(a) <em>C</em>のクラスメソッドの名前である。かつ
(b) そのクラスメソッドが修飾されるされない名前の下のスコープ内にあるかどうかにかかわらずモジュール本体のスコープ内にある。</p>
</li>
<li>
<p>形式<code>module M</code>は修飾されない名前<code>&quot;e&quot;</code>と修飾される名前<code>&quot;M.e&quot;</code>の両方を伴うスコープ内にある全エンティティのセットの名前である。
このセットは空でもよい。
例えば、</p>
<pre><code class="language-hs">module Queue( module Stack, enqueue, dequeue ) where  
    import Stack  
    ... 
</code></pre>
<p>ここのモジュール<code>Queue</code>は<code>Stack</code>からインポートされた全エンティティを略して書くためそのエクスポートリスト内のモジュール名<code>Stack</code>を使う。
モジュールは構文<code>&quot;module M&quot;</code>内のそれが保有する名前を使うエクスポートリストの中で保有するローカルな定義の名前をつけることができる、
なぜなら、ローカル宣言は修飾されるされない名前の両方をスコープの中へもたらす(セクション<a href="#%E4%BF%AE%E9%A3%BE%E3%81%95%E3%82%8C%E3%81%9F%E5%90%8D%E5%89%8D">5.5.1</a>)。
例えば、</p>
<pre><code class="language-hs">module Mod1( module Mod1, module Mod2 ) where  
import Mod2  
import Mod3 
</code></pre>
<p>ここのモジュール<code>Mod1</code>は<code>Mod2</code>からインポートされたそれらと同様に全てのローカル定義をエクスポートするが、<code>Mod3</code>からインポートされたものは異なる。</p>
<p><code>M</code>がエクスポートリストをもつモジュールでない限り、または少なくとも1つのインポート宣言によって(修飾されるかどうかにかかわらず)インポートされたモジュールでない限り、<code>module M</code>をエクスポートリストで使うことはエラーとなる。</p>
</li>
</ol>
<p>エクスポートリストは累積される。
すなわち、エクスポートリストによってエクスポートされるエンティティのセットはリストの個々のアイテムによってエクスポートされたエンティティの和集合である。</p>
<p>エンティティがどのようにエクスポートされているものであっても、インポートしているモジュールには違いがない。
例えば、データ型<code>T</code>からフィールド名<code>f</code>は個々に(<code>f</code>、上記のアイテム(1))エクスポートしてよい。
あるいはそのデータ型(<code>T(f)、アイテム(2)</code>)の明示的に名前をつけられたメンバーのようにしても、
あるいは暗黙的に名前をつけられたメンバー(<code>T(..)、アイテム(2)</code>)のようにしても、
モジュール本体(<code>module M</code>、アイテム(5))をエクスポートすることによっても、同様にエクスポートしてもよい。</p>
<p>モジュールによってエクスポートされたエンティティの <strong>修飾される</strong> 名前は(それら各々の名前空間の範囲で)全て異ならなければならない。
例えば、</p>
<pre><code class="language-hs">module A ( C.f, C.g, g, module B ) where   -- an invalid module  
import B(f)  
import qualified C(f,g)  
g = f True
</code></pre>
<p>モジュールAそれ自身の範囲で衝突する名前はないが、
<code>C.g</code>と<code>g</code>の間(<code>C.g</code>と<code>g</code>は異なる実体であると仮定する。モジュールは相互再帰的にインポートできることを思い出してほしい。)と
<code>module B</code>と<code>C.f</code>の間(<code>B.f</code>と<code>C.f</code>は異なる実体であると仮定する)にエクスポートリスト内で衝突する名前がある。</p>
<a class="header" href="#インポート宣言" id="インポート宣言"><h2>インポート宣言</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td>  <em>impdecl</em></td><td>→</td><td><code>import</code> [<code>qualified</code>] <em>modid</em> [<code>as</code> <em>modid</em>] [<em>impspec</em>]</td><td> </td></tr>
<tr><td>     </td><td>|</td><td>                                             </td><td>(<em>empty declaration</em>)</td></tr>
<tr><td>  <em>impspec</em></td><td>→</td><td>( <em>import<sub>1</sub></em> , … , <em>import<sub>n</sub></em> [ , ] )</td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td>     </td><td>|</td><td><code>hiding</code> ( <em>import<sub>1</sub></em> , … , <em>import<sub>n</sub></em> [ , ] )</td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td>   <em>import</em></td><td>→</td><td><em>var</em></td><td> </td></tr>
<tr><td>     </td><td>|</td><td> <em>tycon</em> [ <code>(..)</code> | ( <em>cname<sub>1</sub></em> , … , <em>cname<sub>n</sub></em> )]</td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td>     </td><td>|</td><td>  <em>tycls</em> [<code>(..)</code> | ( <em>var<sub>1</sub></em> , … , <em>var<sub>n</sub></em> )]</td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td>    <em>cname</em></td><td>→</td><td><em>var</em> | <em>con</em> </td><td> </td></tr>
</tbody></table>
<p>モジュールによってエクスポートされたエンティティはモジュールのはじめの<code>import</code>宣言を伴って他のモジュールのスコープの中へもたらされる。
<code>import</code>宣言はインポートされるモジュールの名前をつけ、任意でインポートされるエンティティを明示する。
単一モジュールは一つ以上の<code>import</code>宣言によってインポートされるかもしれない。
インポートされた名前はトップレベルの宣言のように扱い、
そのスコープはモジュールの実体全体に及ぶが、ローカルのトップレベルではない束縛によってシャドーイングされることもある。</p>
<p>複数の<code>import</code>宣言の効果は厳密に累積し、
もしモジュール内の<code>import</code>宣言のいずれかでインポートされるなら、エンティティはスコープ内にある。
インポート宣言の順序は無関係である。</p>
<p>語彙的に、終端期号<code>&quot;as&quot;</code>や<code>&quot;qualified&quot;</code>、<code>&quot;hiding&quot;</code>はそれぞれ<em>reservedid</em>ではなく<em>varid</em>である。
それらは<code>import</code>宣言の文脈内でのみ特別な意味を持ち、変数のようにも使われることが出来る。</p>
<a class="header" href="#何がインポートされるか" id="何がインポートされるか"><h3>何がインポートされるか</h3></a>
<p>正確にどのエンティティがインポートされるかは次に3つの方法の一つで明示されることが出来る。</p>
<ol>
<li>
<p>インポートされるエンティティは丸括弧の中のリスト化しているものによってはっきりと明示されることが出来る。
そのリストの中のアイテムは修飾子が許可されないことと<code>module &lt;em&gt;modid&lt;/em&gt;</code>エンティティが許可されないことを除いてエクスポートリスト内のものと同様に同じ形式を持つ。
インポートの形式<code>(..)</code>が型またはクラスで使われるとき、<code>(..)</code>はモジュールからエクスポートされるコンストラクタまたはメソッド、フィールド名の全てを参照する。</p>
<p>そのリストはインポートされるモジュールによってエクスポートされるエンティティのみに名前をつけないといけない。
リストは空でもよく、その場合はインスタンス以外はインポートされない。</p>
</li>
<li>
<p>エンティティは形式<code>hiding</code>(<em>inport<sub>1</sub>, ..., import<sub>n</sub></em>)を使うことによって除外されることができる。
そして名前がつけられたモジュールによってエクスポートされる全エンティティはリスト内で名前を付けられたものを除いてインポートされるべきことを明示する。
データコンストラクタは関連する型で接頭辞をつけられることなく隠れているリスト内で直接名前をつけることが出来る。
例えば、</p>
<pre><code class="language-hs">import M hiding (C)
</code></pre>
<p><code>C</code>と名前を付けられるあらゆるコンストラクタまたはクラス、型は除外される。
対象的にインポートリスト内で<code>C</code>を使うことはクラスまたは型のみに名前をつける。</p>
<p>インポートされたモジュールによって実際にエクスポートされないエンティティを隠すことはエラーである。</p>
</li>
<li>
<p>最後にもし<em>impspec</em>は省かれるなら、そのとき明示されたモジュールによってエクスポートされるエンティティはインポートされる。</p>
</li>
</ol>
<a class="header" href="#修飾されるインポート" id="修飾されるインポート"><h3>修飾されるインポート</h3></a>
<p>セクション<a href="#%E3%82%A4%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%88%E3%81%95%E3%82%8C%E3%82%8B%E3%81%A8%E3%81%AF%E4%BD%95%E3%81%8B">5.3.1</a>のルールの下で各エンティティに対して、トップレベルの環境は拡張される。
もしインポート宣言が<code>qualified</code>キーワードを使っていたなら、エンティティの<strong>修飾された名前</strong>のみがスコープ内へともたらされる。
もし<code>qualified</code>キーワードが省略されているなら、そのときエンティティの修飾される名前 <strong>と</strong> 修飾されない名前の <strong>両者</strong>はスコープの中へともたらされる。
セクション<a href="">5.5.1</a>では修飾される名前のより詳細を述べていく。</p>
<p>インポートされる名前の修飾子はインポートされるモジュールの名前か<code>import</code>文の<code>as</code>句に与えられるローカルな別名のどちらかである。
このゆえに、<strong>修飾子は必ずしもインポートするエンティティが元々宣言されていたモジュールの名前でなくとも良い。</strong></p>
<p>修飾されない名前を除外するための機能は修飾されない名前空間のプログラマによる完全な制御を許し、
ローカルで定義されたエンティティは修飾子つきでインポートされたものと同じ名前を共有することが出来る。</p>
<pre><code class="language-hs">module Ring where  
import qualified Prelude    -- All Prelude names must be qualified  
import Data.List( nub )  

l1 + l2 = l1 Prelude.++ l2  -- This + differs from the one in the Prelude  
l1 ⋆ l2 = nub (l1 + l2)     -- This ⋆ differs from the one in the Prelude  

succ = (Prelude.+ 1)
</code></pre>
<a class="header" href="#ローカルな別名" id="ローカルな別名"><h3>ローカルな別名</h3></a>
<p>インポートされるモジュールは<code>as</code>句を使いインポートするモジュールの中でローカルな別名を割り当てられることができる。
例えば、次の</p>
<pre><code class="language-hs">import qualified VeryLongModuleName as C
</code></pre>
<p>モジュールの中ではエンティティは<code><code>VeryLongModuleName.</code></code>ではなく<code><code>C.</code></code>という修飾子を用いて参照されなければならない。
これはインポートされるモジュールで使われる修飾子を変更せずに異なるモジュールを<code>VeryLongModuleName</code>の代わりにされることも許す。
全ての名前が曖昧さなく解決される限りにおいては、2つ以上のモジュールがスコープ内で同じ修飾子を使用することは正当である。
例えば、</p>
<pre><code class="language-hs">module M where  
    import qualified Foo as A  
    import qualified Baz as A  
    x = A.f 
</code></pre>
<p>このモジュールは<code>Foo</code>と<code>Baz</code>が両方<code>f</code>をエクスポートしないときに限り正当である。</p>
<p><code>as</code>句は<code>qualifiedimport</code>ではない式でも使われることができる。</p>
<pre><code class="language-hs">import Foo as A(f)
</code></pre>
<p>この宣言は<code>f</code>と<code>A.f</code>をスコープの中にもたらす。</p>
<a class="header" href="#例" id="例"><h3>例</h3></a>
<p>上記のインポートルールを明らかにするため、<code>x</code>と<code>y</code>をエクスポートするモジュール<code>A</code>を想定してほしい。
そのときこの表は名前が明記されたインポート式によってスコープの中へもたらされることを示す。</p>
<table><thead><tr><th>インポート宣言</th><th>スコープの中にもたらされる名前</th></tr></thead><tbody>
<tr><td>import A                       </td><td> x, y, A.x, A.y </td></tr>
<tr><td>import A()                     </td><td> (nothing) </td></tr>
<tr><td>import A(x)                    </td><td>   x, A.x </td></tr>
<tr><td>import qualified A             </td><td> A.x, A.y </td></tr>
<tr><td>import qualified A()           </td><td> (nothing) </td></tr>
<tr><td>import qualified A(x)          </td><td> A.x </td></tr>
<tr><td>import A hiding ()             </td><td> x, y, A.x, A.y </td></tr>
<tr><td>import A hiding (x)            </td><td> y, A.y </td></tr>
<tr><td>import qualified A hiding ()   </td><td> A.x, A.y </td></tr>
<tr><td>import qualified A hiding (x)  </td><td> A.y </td></tr>
<tr><td>import A as B                  </td><td> x, y, B.x, B.y </td></tr>
<tr><td>import A as B(x)               </td><td> x, B.x </td></tr>
<tr><td>import qualified A as B        </td><td> B.x, B.y </td></tr>
</tbody></table>
<p>全てのケースで、モジュール<code>A</code>のスコープの中の全インスタンス宣言はインポートされる(セクション<a href="">5.4</a>)。</p>
<a class="header" href="#事前定義された型とクラス" id="事前定義された型とクラス"><h1>事前定義された型とクラス</h1></a>
<a class="header" href="#入出力の基本" id="入出力の基本"><h1>入出力の基本</h1></a>
<a class="header" href="#foreign-function-interface" id="foreign-function-interface"><h1>Foreign Function Interface</h1></a>
<a class="header" href="#標準-prelude" id="標準-prelude"><h1>標準 Prelude</h1></a>
<a class="header" href="#文法リファレンス" id="文法リファレンス"><h1>文法リファレンス</h1></a>
<a class="header" href="#慣習的表記" id="慣習的表記"><h2>慣習的表記</h2></a>
<p>以下の慣習的表記が文法を表現するのにつかわれる:</p>
<ul>
<li><code>[<em>pattern</em>]</code> 省略可能</li>
<li><code>{<em>pattern</em>}</code> 0回以上の繰り返し</li>
<li><code>(<em>pattern</em>)</code> グループ化</li>
<li><code><em>pat<sub>1</sub></em> | <em>pat<sub>2</sub></em></code> 選択</li>
<li><code>pat<sub>&lt;pat'&gt;</sub></code> 差(<code>pat</code>によって生成された要素で、<code>pat'</code>で生成されたものを除いたもの)</li>
<li><tt>fibonacci</tt> タイプライターフォントで表記される終端文法</li>
</ul>
<p>BNFのような文法をレポートを通して用いる。文法の生成は次のような形をしている:</p>
<pre>
nonterm -> alt<sub>1</sub> | alt<sub>2</sub> | .. | alt<sub>n</sub>
</pre>
<p>字句文法、文脈自由文法いずれも曖昧さが残るが、これは文法語句をできる限り長く取り、左から右に進む(shift-reduceパースでは、shift/reduceコンフリクトはシフトを取ることで解決する)ことで解決するものとする。字句文法では、これは「最長一致」と呼ばれるルールである。文脈自由文法では、これは条件式やlet式、ラムダ抽象などが右方向に取れるだけ長くとることを表す。</p>
<a class="header" href="#字句文法" id="字句文法"><h2>字句文法</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td> <em>program</em> </td><td>→</td><td> {<em>lexeme</em> | <em>whietespace</em>}</td><td> </td></tr>
<tr><td><em>lexeme</em></td><td>→</td><td><em>qvarid</em> | <em>qconid</em> | <em>qvarsym</em> | <em>qconsym</em></td><td> </td></tr>
<tr><td>       </td><td>|</td><td> <em>literal</em> | <em>special</em> | <em>reservedop</em> | <em>reservedid</em></td><td> </td></tr>
<tr><td> <em>literal</em> </td><td>→</td><td> <em>integer</em> | <em>float</em> | <em>char</em> | <em>string</em> </td><td> </td></tr>
<tr><td> <em>special</em> </td><td>→</td><td> <code>(</code> | <code>)</code> | <code>,</code> | <code>;</code> | <code>[</code> | <code>]</code> | <code>`</code> | <code>{</code> | <code>}</code> </td><td> </td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td> <em>whitespace</em> </td><td>→</td><td> <em>whitestuff</em> {<em>whitestuff</em>}</td><td> </td></tr>
<tr><td> <em>whitestuff</em> </td><td>→</td><td> <em>whitechar</em> | <em>comment</em> | <em>ncomment</em> </td><td> </td></tr>
<tr><td> <em>whitechar</em> </td><td>→</td><td> <em>newline</em> | <em>vertab</em> | <em>space</em> | <em>tab</em> | <em>uniWhite</em> </td><td> </td></tr>
<tr><td> <em>newline</em> </td><td>→</td><td> <em>return</em> <em>linefeed</em> | <em>return</em> | <em>linefeed</em> | <em>formfeed</em> </td><td> </td></tr>
<tr><td> <em>return</em> </td><td>→</td><td> キャレッジ⏎ </td><td> </td></tr>
<tr><td> <em>linefeed</em> </td><td>→</td><td> 改行 </td><td> </td></tr>
<tr><td> <em>vertab</em> </td><td>→</td><td> 垂直タブ </td><td> </td></tr>
<tr><td> <em>formfeed</em> </td><td>→</td><td> 改ページ </td><td> </td></tr>
<tr><td> <em>space</em> </td><td>→</td><td> 空白 </td><td> </td></tr>
<tr><td> <em>tab</em> </td><td>→</td><td> 水平タブ </td><td> </td></tr>
<tr><td> <em>uniWhite</em> </td><td>→</td><td> 空白として定義されたUnicode文字 </td><td> </td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td> <em>comment</em> </td><td>→</td><td> <em>dashes</em> [ <em>any</em><sub><em>symbol</em></sub> {<em>any</em>} ] <em>newline</em> </td><td> </td></tr>
<tr><td><em>dashes</em> </td><td>→</td><td> <code>--</code> {<code>-</code>} </td><td> </td></tr>
<tr><td><em>opencom</em> </td><td>→</td><td> <code>{-</code> </td><td> </td></tr>
<tr><td><em>closecom</em> </td><td>→</td><td> <code>-}</code> </td><td> </td></tr>
<tr><td><em>ncomment</em> </td><td>→</td><td> <em>opencom</em> <em>ANY seq</em> {<em>ncomment</em> <em>ANY seq</em>} <em>closecom</em> </td><td> </td></tr>
<tr><td><em>ANY seq</em> </td><td>→</td><td> {<em>ANY</em>}<sub>⟨{<em>ANY</em>} ( <em>opencom</em> | <em>closecom</em> ) {<em>ANY</em>}⟩</sub> </td><td> </td></tr>
<tr><td><em>ANY</em> </td><td>→</td><td> <em>graphic</em> | <em>whitechar</em> </td><td> </td></tr>
<tr><td><em>any</em> </td><td>→</td><td> <em>graphic</em> | <em>space</em> | <em>tab</em> </td><td> </td></tr>
<tr><td><em>graphic</em> </td><td>→</td><td> <em>small</em> | <em>large</em> | <em>symbol</em> | <em>digit</em> | <em>special</em> | <code>&quot;</code> | </td><td> <code>'</code> </td><td> </td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td><em>small</em> </td><td>→</td><td> <em>ascSmall</em> | <em>uniSmall</em> | <code>_</code> </td><td> </td></tr>
<tr><td><em>ascSmall</em> </td><td>→</td><td> <code>a</code> | <code>b</code> | … | <code>z</code> </td><td> </td></tr>
<tr><td><em>uniSmall</em> </td><td>→</td><td> 小文字Unicode </td><td> </td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td><em>large</em> </td><td>→</td><td> <em>ascLarge</em> | <em>uniLarge</em> </td><td> </td></tr>
<tr><td><em>ascLarge</em> </td><td>→</td><td> <code>A</code> | <code>B</code> | … | <code>Z</code> </td><td> </td></tr>
<tr><td><em>uniLarge</em> </td><td>→</td><td> 任意の大文字またはタイトルケースのユニコード文字<br>(<strong>訳注</strong>: タイトルケース 先頭のみ大文字で後は小文字にするスタイル) </td><td> </td></tr>
<tr><td><em>symbol</em> </td><td>→</td><td> <em>ascSymbol</em> | <em>uniSymbol</em><sub>⟨<em>special</em> | <code>_</code> | <code>&quot;</code> | <code>'</code>⟩</sub> </td><td> </td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td><em>ascSymbol</em></td><td>→</td><td><tt>!</tt> | <tt>#</tt> | <tt>$</tt> | <tt>%</tt> | <tt>&amp;</tt> | <tt>⋆</tt> | <tt>+</tt>  | <tt>.</tt> | <tt>/</tt> | <tt>&lt;</tt> | <tt>=</tt> | <tt>&gt;</tt> | <tt>?</tt> | <tt>@</tt></td><td> </td></tr>
<tr><td>                </td><td>|</td><td> <tt>\</tt> | <tt>^</tt> | <tt>|</tt> | <tt>-</tt> | <tt>~</tt> | <tt>:</tt></td><td> </td></tr>
<tr><td><em>uniSymbol</em> </td><td>→</td><td> Unicodeのシンボル、または句読点 </td><td> </td></tr>
<tr><td><em>digit</em> </td><td>→</td><td> <em>ascDigit</em> | <em>uniDigit</em> </td><td> </td></tr>
<tr><td><em>ascDigit</em> </td><td>→</td><td> <code>0</code> | <code>1</code> | … | <code>9</code> </td><td> </td></tr>
<tr><td><em>uniDigit</em> </td><td>→</td><td> 10進数Unicode </td><td> </td></tr>
<tr><td><em>octit</em> </td><td>→</td><td> <code>0</code> | <code>1</code> | … | <code>7</code> </td><td> </td></tr>
<tr><td><em>hexit</em> </td><td>→</td><td> <em>digit</em> | <code>A</code> | … | <code>F</code> | <code>a</code> | … | <code>f</code> </td><td> </td></tr>
<tr><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td><em>varid</em> </td><td> → </td><td> (<em>small</em> {<em>small</em> | <em>large</em> | <em>digit</em> | <code>'</code> })<sub>⟨<em>reservedid</em>⟩</sub></td><td> </td></tr>
<tr><td><em>conid</em> </td><td> → </td><td> <em>large</em> {<em>small</em> | <em>large</em> | <em>digit</em> | <code>'</code> }</td><td> </td></tr>
<tr><td><em>reservedid</em> </td><td> → </td><td> <code>case</code> | <code>class</code> | <code>data</code> | <code>default</code> | <code>deriving</code> | <code>do</code> | <code>else</code> </td><td> </td></tr>
<tr><td> </td><td> </td><td> <code>foreign</code> | <code>if</code> | <code>import</code> | <code>in</code> | <code>infix</code> | <code>infixl</code> </td><td> </td></tr>
<tr><td> </td><td> </td><td> <code>infixr</code> | <code>instance</code> | <code>let</code> | <code>module</code> | <code>newtype</code> | <code>of</code> </td><td> </td></tr>
<tr><td> </td><td> </td><td> <code>then</code> | <code>type</code> | <code>where</code> | <code>_</code></td><td> </td></tr>
<tr><td><em>varsym</em></td><td>→</td><td>( <em>symbol</em><sub>⟨<tt>:</tt>⟩</sub> {<em>symbol</em>} )<sub>⟨reservedop | dashes⟩</sub></td><td> </td></tr>
<tr><td><em>consym</em></td><td>→</td><td>( <tt>:</tt> {<em>symbol</em>})<sub>⟨reservedop⟩</sub></td><td> </td></tr>
<tr><td><em>reservedop</em></td><td>→</td><td><tt>..</tt> | <tt>:</tt> | <tt>::</tt> | <tt>=</tt> | <tt>\</tt> | <tt>|</tt> | <tt>&lt;-</tt> | <tt>-&gt;</tt> |  <tt>@</tt> | <tt>~</tt> | <tt>=&gt;</tt></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td> </td></tr>
<tr><td><em>varid</em></td><td> </td><td> </td><td>(変数)</td></tr>
<tr><td><em>conid</em></td><td> </td><td> </td><td>(コンストラクタ)</td></tr>
<tr><td><em>tyvar</em></td><td>→</td><td><em>varid</em></td><td>(型変数)</td></tr>
<tr><td><em>tycon</em></td><td>→</td><td><em>conid</em></td><td>(型コンストラクタ)</td></tr>
<tr><td><em>tycls</em></td><td>→</td><td><em>conid</em></td><td>(型クラス)</td></tr>
<tr><td><em>modid</em></td><td>→</td><td>{<em>conid</em> <code>.</code>} <em>conid</em></td><td>(モジュール)</td></tr>
<tr><td><em>qvarid</em></td><td>→</td><td>[ <em>modid</em> <code>.</code> ] <em>varid</em></td><td> </td></tr>
<tr><td><em>qconid</em></td><td>→</td><td>[ <em>modid</em> <code>.</code> ] <em>conid</em></td><td> </td></tr>
<tr><td><em>qtycon</em></td><td>→</td><td>[ <em>modid</em> <code>.</code> ] <em>tycon</em></td><td> </td></tr>
<tr><td><em>qtycls</em></td><td>→</td><td>[ <em>modid</em> <code>.</code> ] <em>tycls</em></td><td> </td></tr>
<tr><td><em>qvarsym</em></td><td>→</td><td>[ <em>modid</em> <code>.</code> ] <em>varsym</em></td><td> </td></tr>
<tr><td><em>qconsym</em></td><td>→</td><td>[ <em>modid</em> <code>.</code> ] <em>consym</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td> </td></tr>
<tr><td><em>decimal</em></td><td>→</td><td><em>digit</em>{<em>digit</em>}</td><td> </td></tr>
<tr><td><em>octal</em></td><td>→</td><td><em>octit</em>{<em>octit</em>}</td><td> </td></tr>
<tr><td><em>hexadecimal</em></td><td>→</td><td><em>hexit</em>{<em>hexit</em>}</td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td> </td></tr>
<tr><td><em>integer</em></td><td>→</td><td><em>decimal</em></td><td> </td></tr>
<tr><td>       </td><td>|</td><td> <code>0o</code> <em>octal</em> | <code>0O</code> <em>octal</em></td><td> </td></tr>
<tr><td>       </td><td>|</td><td> <code>0x</code> <em>hexadecimal</em> | <code>0X</code> <em>hexadecimal</em></td><td> </td></tr>
<tr><td><em>float</em></td><td>→</td><td><em>decimal</em> <code>.</code> <em>decimal</em> [<em>exponent</em></td><td> </td></tr>
<tr><td>       </td><td>|</td><td>    <em>decimal</em> <em>exponent</em></td><td> </td></tr>
<tr><td><em>exponent</em></td><td>→</td><td>(<code>e</code> | <code>E</code>) [<code>+</code> | <code>-</code>] <em>decimal</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td> </td></tr>
<tr><td><em>char</em></td><td>→</td><td><code>'</code> (<em>graphic</em><sub>⟨<code>'</code> | <code>\</code>⟩</sub> | <em>space</em> | <em>escape</em><sub>⟨<code>\&amp;</code>⟩</sub>) <code>'</code></td><td> </td></tr>
<tr><td><em>string</em></td><td>→</td><td><code>&quot;</code> {<em>graphic</em><sub>⟨<code>&quot;</code> | <code>\\</code>⟩</sub> | <em>space</em> | <em>escape</em> | <em>gap</em>} <code>&quot;</code></td><td> </td></tr>
<tr><td><em>escape</em></td><td>→</td><td><code>\\</code> ( <em>charesc</em> | <em>ascii</em> | <em>decimal</em> | <code>o</code> <em>octal</em> | <code>x</code> <em>hexadecimal</em> )</td><td> </td></tr>
<tr><td><em>charesc</em></td><td>→</td><td><code>a</code> | <code>b</code> | <code>f</code> | <code>n</code> | <code>r</code> | <code>t</code> | <code>v</code> | <code>\\</code> | <code>&quot;</code> | <code>'</code> | <code>&amp;</code></td><td> </td></tr>
<tr><td><em>ascii</em></td><td>→</td><td><code>^</code><em>cntrl</em> | <code>NUL</code> | <code>SOH</code> | <code>STX</code> | <code>ETX</code> | <code>EOT</code> | <code>ENQ</code> | <code>ACK</code></td><td> </td></tr>
<tr><td>       </td><td>|</td><td> <code>BEL</code> | <code>BS</code> | <code>HT</code> | <code>LF</code> | <code>VT</code> | <code>FF</code> | <code>CR</code> | <code>SO</code> | <code>SI</code> | <code>DLE</code></td><td> </td></tr>
<tr><td>       </td><td>|</td><td> <code>DC1</code> | <code>DC2</code> | <code>DC3</code> | <code>DC4</code> | <code>NAK</code> | <code>SYN</code> | <code>ETB</code> | <code>CAN</code></td><td> </td></tr>
<tr><td>       </td><td>|</td><td> <code>EM</code> | <code>SUB</code> | <code>ESC</code> | <code>FS</code> | <code>GS</code> | <code>RS</code> | <code>US</code> | <code>SP</code> | <code>DEL</code></td><td> </td></tr>
<tr><td><em>cntrl</em></td><td>→</td><td><em>ascLarge</em> | <code>@</code> | <code>[</code> | <code>\\</code> | <code>]</code> | <code>^</code> | <code>_</code></td><td> </td></tr>
<tr><td><em>gap</em></td><td>→</td><td><code>\</code> <em>whitechar</em> {<em>whitechar</em>} <code>\</code></td><td> </td></tr>
</tbody></table>
<a class="header" href="#レイアウト-1" id="レイアウト-1"><h2>レイアウト</h2></a>
<p>セクション2.7(<strong>[訳注]</strong> TODO:リンク)ではレイアウトルールに対する非形式的な議論を見た。このセクションではより正確に定義をする。</p>
<p>Haskellプログラムの意味はその<strong>レイアウト</strong>に依存する場合がある。レイアウトが意味に与える効果は波括弧とセミコロンをレイアウトによって決定される位置に追加することで完全に説明できる。このようにして追加されたプログラムの意味は今やレイアウトによって影響を受けない。</p>
<p>レイアウトがプログラムに対して与える影響は、このセクションで波括弧とセミコロンをどのように追加するかを説明することで指定される。仕様は、プログラムの返還を行う関数<code>L</code>の形で与えられる。<code>L</code>の入力は次のようなものである:</p>
<ul>
<li>Haskellレポートにある字句文法によって定められた語句の列であって、さらに次のような追加の語句を含む:
<ul>
<li><code>let, where, do, of</code>キーワードの後に<code>{</code>が続かない場合、トークン{n}がキーワードの後に挿入される。ただしnは、続くトークンがあればそのインデントを表し、ファイルの終端に達した場合は0を表す。</li>
<li>モジュールの最初のトークンが<code>{</code>でも<code>module</code>でもない場合、そのトークンのインデントをnとすると、{n}が先行する。</li>
<li>同じ行で空白のみが最初のトークンに先行する場合、<code>&lt;n&gt;</code>がこの語句に先行する。ここでnは語句のインデントであり、もしインデントが存在しない場合には先の2つのルールの結果として{n}が先行することとなる。(注意: 文字列リテラルはセクション<a href="chapters/./2-lexical-structure.html">2.6</a>で説明したように、複数行に及ぶこともある。よって次のコードにおいては、<code>\Bill</code>の前に<code>&lt;n&gt;</code>が挿入されることはない。なぜなら、これは完全な語句の開始でもなければ<code>,</code>の前でもなく、単純に空白文字によって先行されているだけだからである。)</li>
</ul>
</li>
</ul>
<pre><code class="language-haskell">f = (&quot;Hello \  
        \Bill&quot;, &quot;Jake&quot;)    
</code></pre>
<ul>
<li>&quot;レイアウト文脈&quot;のスタックで、各要素が次のいずれかであるもの:
<ul>
<li>文脈の囲みを明示することを表すゼロ(すなわち、プログラマは開いた波括弧を書いていた場合) 最も内側の文脈が0である場合、レイアウトトークンは文脈の囲いが終了するか新しい文脈が追加されるまで挿入されない。</li>
<li>レイアウト文脈を囲うインデントの段数を表す正の整数</li>
</ul>
</li>
</ul>
<p>語句の&quot;インデント&quot;とは、語句の最初の文字の段数である。そしてある行のインデントとは、最も左にある語句のインデントである。段数を決定するには、次の慣習に従う固定幅フォントを使っていると仮定する。
- 次の文字 <code>newline</code>, <code>return</code>, <code>linefeed</code>, <code>formfeed</code> は新しい行を開始する。
- 最初の段数は0ではなく、1とする。
- タブは8文字分の幅だけ次の文字位置までの間が空く。
- タブ文字は現在の位置をタブの次の文字位置まで揃えるためにそれに足りるだけのスペースを挿入させる。</p>
<p>レイアウトルールのために、ソースコード中のユニコード文字もASCII文字と同じ固定された幅をもつものとみなされる。しかし見た目の混乱を防ぐために、プログラマーは見た目に分からないレイアウトの意味を、空白でない文字幅に依存させるようなプログラムを書くことは避けるべきである。</p>
<p>関数適用 <code>L tokens []</code>  は、<code>tokens</code>をレイアウトに依存しないものへの変換である。ここで<code>tokens</code>はモジュールを字句解析して得られた結果で、上で説明したような段数を表す数字を追加している。<code>L</code>の定義は次のようになっている。ここで、<code>:</code>をストリームのコンストラクタ演算子として、<code>[]</code>を空のストリームとして使っている。</p>
<pre><code class="language-haskell">L (&lt; n &gt;: ts) (m : ms)  = ;  :  (L ts (m : ms))             if m = n
                        = }  :  (L (&lt; n &gt;: ts) ms)          if n &lt; m
L (&lt; n &gt;: ts) ms        = L ts ms
L ({n} : ts) (m : ms)   = {  :  (L ts (n : m : ms))         if n &gt; m (ノート) 1)
L ({n} : ts) []         = {  :  (L ts [n])                  if n &gt; 0 (ノート 1)
L ({n} : ts) ms         = {  :  }  :  (L (&lt; n &gt;: ts) ms)    (ノート 2)
L (} : ts) (0 : ms)     = }  :  (L ts ms)                   (ノート 3)
L (} : ts) ms           = parse-error                       (ノート 3)
L ({ : ts) ms           = {  :  (L ts (0 : ms))             (ノート 4)
L (t : ts) (m : ms)     = }  :  (L (t : ts) ms)             if m≠0 and parse-error(t)
                                                            (ノート 5)
L (t : ts) ms           = t  :  (L ts ms)
L [] []                 = []
L [] (m : ms)           = }  :  L [] ms                     if m≠0 (ノート 6)
</code></pre>
<p><strong>ノート1</strong>
ネストされたコンテキストは文脈の囲い<code>(n &gt; m)</code>よりも深くインデントされなければならない。そうでなければ、<code>L</code>は失敗し、コンパイラはレイアウトエラーを示すだろう。次は例である。</p>
<pre><code class="language-haskell">  f x = let  
           h y = let  
    p z = z  
                 in p  
        in h
</code></pre>
<p>ここで、<code>p</code>の定義は、ここでは<code>h</code>の定義によって定まっている文脈の囲いのインデントより浅くインデントされている。</p>
<p><strong>ノート2</strong>
(例えば)<code>where</code>の後に出現する最初のトークンがレイアウト文脈の囲いよりもインデントされていなかった場合、その<code>where</code>のブロックは空でなければならず、よって中身のないの波括弧が挿入される。<code>{n}</code>トークンは中身のない波括弧が明示されたを模倣して<code>&lt;n&gt;</code>によって置き換えられる。</p>
<p><strong>ノート3</strong>
現在のレイアウト文脈を0と比べることで、明示された閉じ波括弧が明示された開き波括弧のみと対応していることを保証できる。明示された閉じ波括弧が明示されていない開き波括弧と対応している場合はパースエラーが出力される。</p>
<p><strong>ノート4</strong>
この句は、ラベル付き構成と更新を含めた(セクション<a href="chapters/./3-expressions.html">3.15</a>)すべての波括弧の組が明示的なレイアウト文脈として扱われるようにするためのものである。この式はHaskell1.4とは異なっている。</p>
<p><strong>ノート5</strong>
横の条件<code>parse-error(t)</code>は次のように解釈される: <code>L</code>によってこれまでに生成された次のトークン<code>t</code>をもつトークン列がHaskell文法において無効なものから始まっていることを表しており、また<code>L</code>によってこれまでに生成された<code>&quot;}&quot;</code>に続くトークン列がHaskell文法において有効なものから始まっていることを表している場合、<code>parse-error(t)</code>は真である。</p>
<p>m≠0は暗黙的に追加された閉じ波括弧が明示されていない開き波括弧と対応することを確認している。</p>
<p><strong>ノート6</strong>
入力に終わりに、保留されている閉じ波括弧が挿入される。非レイアウト文脈に含まれている場合(すなわち、m = 0)、ここでエラーになる。</p>
<p>上のルールのいずれもマッチしない場合、このアルゴリズムは失敗する。例えば入力の最後に到達したときに、非レイアウト文脈が有効であれば、閉じ波括弧が存在しないので失敗することになる。このアルゴリズムによって検知されないエラー条件も一部存在する。例えば、<code>let }</code>である。</p>
<p>ノート1はレイアウト処理がパースエラーによって途中で停止する可能性があることを言っている。例えば</p>
<pre><code class="language-haskell">let x = e; y = x in e'
</code></pre>
<p>は有効である。なぜならこれは次のように変換されるからである。</p>
<pre><code class="language-haskell">let { x = e; y = x } in e'
</code></pre>
<p>閉じ波括弧は上のパースエラーのルールにより挿入される。</p>
<a class="header" href="#文芸的コメント" id="文芸的コメント"><h2>文芸的コメント</h2></a>
<p>「文芸的コメント」の慣習は、リチャード・バードとフィリップ・ワドラーらがOrwell言語のために初めて導入し、そして次にドナルド・クヌースの「文芸的プログラミング」に影響を与えたものであるが、Haskellのソースコードを記述するためのもう一つのスタイルである。文芸的スタイルはコメントを書くことを、それをデフォルトとすることで推奨している。始めの文字が&quot;&gt;&quot;である行はプログラムの一部として扱われ、それ以外の行はすべてコメントとなる。</p>
<p>プログラムの本文は&quot;&gt;&quot;で始まる行のみを拾い、&quot;&gt;&quot;とそれに続く空白を置き換えることで復元することができる。その結果残る本文の中では、レイアウトやコメントは<a href="chapters/./10-syntax-reference.html">10章</a>で説明したとおりに適用される。</p>
<p>&quot;&gt;&quot;を間違って省略してしまった場合に備えて、空でないコメント行に隣接するプログラム行はエラーになる。ここで空のコメント行とは、空白しか含まないもののことである。</p>
<p>慣習的に、コメントのスタイルはファイル拡張子によって指定される。&quot;.hs&quot;であれば通常のHaskellファイルであり、&quot;.lhs&quot;であれば文芸的Haskellファイルである。このスタイルを用いると、階乗の簡単なプログラムは次のようになる。</p>
<p>(<strong>訳注</strong>: 文芸的Haskellに対応するsyntax highlighterがないので通常のHaskellハイライトで代用しています。本来コメントとして扱われる<code>This literate...</code>や<code>This is the factorial...</code>などに色が付いていますがここは上でも説明があった通りコメントです。)</p>
<pre><code class="language-hs">   This literate program prompts the user for a number  
   and prints the factorial of that number:  

&gt; main :: IO ()  

&gt; main = do putStr &quot;Enter a number: &quot;  
&gt;           l &lt;- readLine  
&gt;           putStr &quot;n!= &quot;  
&gt;           print (fact (read l))  

  This is the factorial function.  

&gt; fact :: Integer -&gt; Integer  
&gt; fact 0 = 1  
&gt; fact n = n ⋆ fact (n-1)
</code></pre>
<p>文芸的プログラミングという代替スタイルは、文章処理システムのLaTeXを使う際に特に適している。この慣習の下では、<code>\begin{code}...\end{code}</code>デリミタで囲まれた部分全体が文芸的プログラムのプログラム本文として扱われ、その他の行はすべてコメントである。より正確には:</p>
<ul>
<li>プログラムコードは<code>\begin{code}</code>に続く次の行から始まり</li>
<li>プログラムコードは<code>\end{code}</code>で始まる行の直前で終わる (文字列リテラルは当然除く)</li>
</ul>
<p>これらデリミタの前後に余分な空白行を挿入する必要は必ずしもないが、スタイルとしてはそれが望ましいであろう。例えば次のようになる。</p>
<pre><code class="language-tex">\documentstyle{article}  

\begin{document}  

\chapter{Introduction}  

This is a trivial program that prints the first 20 factorials.  

\begin{code}  
main :: IO ()  
main =  print [ (n, product [1..n]) | n &lt;- [1..20]]  
\end{code}  

\end{document}
</code></pre>
<p>このスタイルは同じファイル拡張子を用いる。同じファイルに対してこれら2つのスタイルを混ぜるのはおすすめできない。</p>
<a class="header" href="#文脈自由構文" id="文脈自由構文"><h2>文脈自由構文</h2></a>
<table><thead><tr></tr></thead><tbody>
<tr><td><em>module</em></td><td>→</td><td><tt>module</tt> <em>modid</em> [<em>exports</em>] <tt>where</tt> <em>body</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <em>body</em></td><td> </td></tr>
<tr><td><em>body</em></td><td>→</td><td>{ <em>impdecls</em> <tt>;</tt> <em>topdecls</em> }</td><td> </td></tr>
<tr><td> </td><td>|</td><td>  { <em>impdecls</em> }</td><td> </td></tr>
<tr><td> </td><td>|</td><td>  { <em>topdecls</em> }</td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>impdecls</em></td><td>→</td><td><em>impdecl<sub>1</sub></em> <tt>;</tt> … <tt>;</tt> <em>impdecl<sub>n</sub></em></td><td>(<em>n</em> ≥ 1)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>exports</em></td><td>→</td><td>( <em>export<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>export<sub>n</sub></em> [ <tt>,</tt> ] )</td><td>(<em>n</em> ≥ 0)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>export</em></td><td>→</td><td><em>qvar</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <em>qtycon</em> [(..) | ( <em>cname<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>cname<sub>n</sub></em> )]</td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td> </td><td>|</td><td>  <em>qtycls</em> [(..) | ( <em>qvar<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>qvar<sub>n</sub></em> )]</td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td> </td><td>|</td><td>  <tt>module</tt> <em>modid</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>impdecl</em></td><td>→</td><td><tt>import</tt> [<tt>qualified</tt>] <em>modid</em> [<tt>as</tt> <em>modid</em>] [<em>impspec</em>]</td><td> </td></tr>
<tr><td> </td><td>|</td><td> </td><td>(empty declaration)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>impspec</em></td><td>→</td><td>( <em>import<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>import<sub>n</sub></em> [ <tt>,</tt> ] ) </td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td> </td><td>|</td><td>  <tt>hiding</tt> ( <em>import<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>import<sub>n</sub></em> [ <tt>,</tt> ] )      </td><td>(<em>n</em> ≥ 0)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>import</em></td><td>→</td><td><em>var</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <em>tycon</em> [ (..) | ( <em>cname<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>cname<sub>n</sub></em> )]     </td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td> </td><td>|</td><td>  <em>tycls</em> [(..) | ( <em>var<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>var<sub>n</sub></em> )]      </td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td><em>cname</em></td><td>→</td><td><em>var</em> | <em>con</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>topdecls</em></td><td>→</td><td><em>topdecl<sub>1</sub></em> <tt>;</tt> … <tt>;</tt> <em>topdecl<sub>n</sub></em>      </td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td><em>topdecl</em></td><td>→</td><td><tt>type</tt> <em>simpletype</em> = <em>type</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <tt>data</tt> [<em>context</em> =&gt;] <em>simpletype</em> [= <em>constrs</em>] [<em>deriving</em>]</td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <tt>newtype</tt> [<em>context</em> =&gt;] <em>simpletype</em> = <em>newconstr</em> [<em>deriving</em>]</td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <tt>class</tt> [<em>scontext</em> =&gt;] <em>tycls</em> <em>tyvar</em> [<tt>where</tt> <em>cdecls</em>]</td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <tt>instance</tt> [<em>scontext</em> =&gt;] <em>qtycls</em> <em>inst</em> [<tt>where</tt> <em>idecls</em>]</td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <tt>default</tt> (type1 <tt>,</tt> … <tt>,</tt> <em>type<sub>n</sub></em>)      </td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td> </td><td>|</td><td>  <tt>foreign</tt> <em>fdecl</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <em>decl</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>decls</em></td><td>→</td><td>{ <em>decl<sub>1</sub></em> <tt>;</tt> … <tt>;</tt> <em>decl<sub>n</sub></em> }       </td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td><em>decl</em></td><td>→</td><td><em>gendecl</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  (<em>funlhs</em> | <em>pat</em>) <em>rhs</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>cdecls</em></td><td>→</td><td>{ <em>cdecl<sub>1</sub></em> <tt>;</tt> … <tt>;</tt> <em>cdecl<sub>n</sub></em> }        </td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td><em>cdecl</em></td><td>→</td><td><em>gendecl</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  (<em>funlhs</em> | <em>var</em>) <em>rhs</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>idecls</em></td><td>→</td><td>{ <em>idecl<sub>1</sub></em> <tt>;</tt> … <tt>;</tt> <em>idecl<sub>n</sub></em> }        </td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td><em>idecl</em></td><td>→</td><td>(<em>funlhs</em> | <em>var</em>) <em>rhs</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>          </td><td>(empty)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>gendecl</em></td><td>→</td><td><em>vars</em> <tt>::</tt> [<em>context</em> =&gt;] <em>type</em>       </td><td>(type signature)</td></tr>
<tr><td> </td><td>|</td><td>  <em>fixity</em> [<em>integer</em>] <em>ops</em>     </td><td>(fixity declaration)</td></tr>
<tr><td> </td><td>|</td><td>          </td><td>(empty declaration)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>ops</em></td><td>→</td><td><em>op<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>op<sub>n</sub></em>     </td><td>(<em>n</em> ≥ 1)</td></tr>
<tr><td><em>vars</em></td><td>→</td><td><em>var<sub>1</sub></em> <tt>,</tt> …, <em>var<sub>n</sub></em>        </td><td>(<em>n</em> ≥ 1)</td></tr>
<tr><td><em>fixity</em></td><td>→</td><td><tt>infixl</tt> | <tt>infixr</tt> | <em>infix</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>type</em></td><td>→</td><td><em>btype</em> [-&gt; <em>type</em>]      </td><td>(function type)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>btype</em></td><td>→</td><td>[<em>btype</em>] <em>atype</em>       </td><td>(type application)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>atype</em></td><td>→</td><td><em>gtycon</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <em>tyvar</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  ( <em>type<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>type<sub>k</sub></em> )     </td><td>(tuple type, <em>k</em> ≥ 2)</td></tr>
<tr><td> </td><td>|</td><td>  [ <em>type</em> ]       </td><td>(list type)</td></tr>
<tr><td> </td><td>|</td><td>  ( <em>type</em> )       </td><td>(parenthesized constructor)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>gtycon</em></td><td>→</td><td><em>qtycon</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <tt>()</tt>     </td><td>(unit type)</td></tr>
<tr><td> </td><td>|</td><td>  <tt>[]</tt>     </td><td>(list constructor)</td></tr>
<tr><td> </td><td>|</td><td>  <tt>(-&gt;)</tt>       </td><td>(function constructor)</td></tr>
<tr><td> </td><td>|</td><td>  <tt>(,{,})</tt>     </td><td>(tupling constructors)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>context</em></td><td>→</td><td><em>class</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  ( <em>class<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>class<sub>n</sub></em> )       </td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td><em>class</em></td><td>→</td><td><em>qtycls</em> <em>tyvar</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <em>qtycls</em> ( <em>tyvar</em> <em>atype<sub>1</sub></em> … <em>atype<sub>n</sub></em> )      </td><td>(<em>n</em> ≥ 1)</td></tr>
<tr><td><em>scontext</em></td><td>→</td><td><em>simpleclass</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  ( <em>simpleclass<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>simpleclass<sub>n</sub></em> )       </td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td><em>simpleclass</em></td><td>→</td><td><em>qtycls</em> <em>tyvar</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>simpletype</em></td><td>→</td><td><em>tycon</em> <em>tyvar<sub>1</sub></em> … <em>tyvar<sub>k</sub></em>       </td><td>(<em>k</em> ≥ 0)</td></tr>
<tr><td><em>constrs</em></td><td>→</td><td><em>constr<sub>1</sub></em> | … | <em>constr<sub>n</sub></em>     </td><td>(<em>n</em> ≥ 1)</td></tr>
<tr><td><em>constr</em></td><td>→</td><td><em>con</em> [!] <em>atype<sub>1</sub></em> … [!] <em>atype<sub>k</sub></em>     </td><td>(arity <em>con</em>  =  <em>k</em>, <em>k</em> ≥ 0)</td></tr>
<tr><td> </td><td>|</td><td>  (<em>btype</em> | ! <em>atype</em>) <em>conop</em> (<em>btype</em> | ! <em>atype</em>)        </td><td>(infix <em>conop</em>)</td></tr>
<tr><td> </td><td>|</td><td>  <em>con</em> { <em>fielddecl<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>fielddecl<sub>n</sub></em> }      </td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td><em>newconstr</em></td><td>→</td><td><em>con</em> <em>atype</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <em>con</em> { <em>var</em> <tt>::</tt> <em>type</em> }</td><td> </td></tr>
<tr><td><em>fielddecl</em></td><td>→</td><td><em>vars</em> <tt>::</tt> (<em>type</em> | ! <em>atype</em>) </td></tr>
<tr><td><em>deriving</em></td><td>→</td><td><tt>deriving</tt> (dclass | (<em>dclass<tt>1</tt></em>, … <tt>,</tt> <em>dclass<sub>n</sub></em>))        </td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td><em>dclass</em></td><td>→</td><td><em>qtycls</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>inst</em></td><td>→</td><td><em>gtycon</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  ( <em>gtycon</em> <em>tyvar<sub>1</sub></em> … <em>tyvar<sub>k</sub></em> )     </td><td>(<em>k</em> ≥ 0, <em>tyvars</em> distinct)</td></tr>
<tr><td> </td><td>|</td><td>  ( <em>tyvar<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>tyvar<sub>k</sub></em> )       </td><td>(<em>k</em> ≥ 2, <em>tyvars</em> distinct)</td></tr>
<tr><td> </td><td>|</td><td>  [ <em>tyvar</em> ]</td><td> </td></tr>
<tr><td> </td><td>|</td><td>  ( <em>tyvar<sub>1</sub></em> -&gt; <em>tyvar<sub>2</sub></em> )        </td><td><em>tyvar<sub>1</sub></em> and <em>tyvar<sub>2</sub></em> distinct</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>fdecl</em></td><td>→</td><td><tt>import</tt> <em>callconv</em> [<em>safety</em>] <em>impent</em> <em>var</em> <tt>::</tt> <em>ftype</em>       </td><td>(define variable)</td></tr>
<tr><td> </td><td>|</td><td>  <tt>export</tt> <em>callconv</em> <em>expent</em> <em>var</em> <tt>::</tt> <em>ftype</em>       </td><td>(expose variable)</td></tr>
<tr><td><em>callconv</em></td><td>→</td><td><tt>ccall</tt> | <tt>stdcall</tt> | <tt>cplusplus</tt>       </td><td>(calling convention)</td></tr>
<tr><td> </td><td>|</td><td>  <tt>jvm</tt> | <tt>dotnet</tt></td><td> </td></tr>
<tr><td> </td><td>|</td><td>   <strong>system-specific calling conventions</strong></td><td> </td></tr>
<tr><td><em>impent</em></td><td>→</td><td>[<em>string</em>]        </td><td>(see Section <a href="chapters/%22./8-foreign-function-interface.html">8.5.1</a>)</td></tr>
<tr><td><em>expent</em></td><td>→</td><td>[<em>string</em>]        </td><td>(see Section <a href="chapters/%22./8-foreign-function-interface.html">8.5.1</a>)</td></tr>
<tr><td><em>safety</em></td><td>→</td><td><tt>unsafe</tt> | <tt>safe</tt></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>ftype</em></td><td>→</td><td><em>frtype</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <em>fatype</em> → <em>ftype</em></td><td> </td></tr>
<tr><td><em>frtype</em></td><td>→</td><td><em>fatype</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  ()</td><td> </td></tr>
<tr><td><em>fatype</em></td><td>→</td><td><em>qtycon</em> <em>atype<sub>1</sub></em> … <em>atype<sub>k</sub></em>      </td><td>(<em>k</em>  ≥  0)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>funlhs</em></td><td>→</td><td><em>var</em> <em>apat</em> { <em>apat</em> }</td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <em>pat</em> <em>varop</em> <em>pat</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  ( <em>funlhs</em> ) <em>apat</em> { <em>apat</em> }</td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>rhs</em></td><td>→</td><td>= <em>exp</em> [<tt>where</tt> <em>decls</em>]</td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <em>gdrhs</em> [<tt>where</tt> <em>decls</em>]</td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>gdrhs</em></td><td>→</td><td><em>guards</em> = <em>exp</em> [<em>gdrhs</em>]</td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>guards</em></td><td>→</td><td>| <em>guard<sub>1</sub></em>, …, <em>guard<sub>n</sub></em>     </td><td>(<em>n</em> ≥ 1)</td></tr>
<tr><td><em>guard</em></td><td>→</td><td><em>pat</em> &lt;- <em>infixexp</em>     </td><td>(pattern guard)</td></tr>
<tr><td> </td><td>|</td><td>  <tt>let</tt> <em>decls</em>     </td><td>(local declaration)</td></tr>
<tr><td> </td><td>|</td><td>  <em>infixexp</em>       </td><td>(boolean guard)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>exp</em></td><td>→</td><td><em>infixexp</em> <tt>::</tt> [<em>context</em> =&gt;] <em>type</em>       </td><td>(expression type signature)</td></tr>
<tr><td> </td><td>|</td><td>  <em>infixexp</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>infixexp</em></td><td>→</td><td><em>lexp</em> <em>qop</em> <em>infixexp</em>       </td><td>(infix operator application)</td></tr>
<tr><td> </td><td>|</td><td>  - <em>infixexp</em>     </td><td>(prefix negation)</td></tr>
<tr><td> </td><td>|</td><td>  <em>lexp</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>lexp</em></td><td>→</td><td>\ <em>apat<sub>1</sub></em> … <em>apat<sub>n</sub></em> -&gt; <em>exp</em>        </td><td>(lambda abstraction, <em>n</em> ≥ 1)</td></tr>
<tr><td> </td><td>|</td><td>  <tt>let</tt> <em>decls</em> <tt>in</tt> <em>exp</em>        </td><td>(let expression)</td></tr>
<tr><td> </td><td>|</td><td>  <tt>if</tt> <em>exp</em> [<tt>;</tt>] <tt>then</tt> <em>exp</em> [<tt>;</tt>] <tt>else</tt> <em>exp</em>        </td><td>(conditional)</td></tr>
<tr><td> </td><td>|</td><td>  <tt>case</tt> <em>exp</em> <tt>of</tt> { <em>alts</em> }        </td><td>(case expression)</td></tr>
<tr><td> </td><td>|</td><td>  <tt>do</tt> { <em>stmts</em> }      </td><td>(do expression)</td></tr>
<tr><td> </td><td>|</td><td>  <em>fexp</em></td><td> </td></tr>
<tr><td><em>fexp</em></td><td>→</td><td>[<em>fexp</em>] <em>aexp</em>      </td><td>(function application)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>aexp</em></td><td>→</td><td><em>qvar</em>      </td><td>(variable)</td></tr>
<tr><td> </td><td>|</td><td>  <em>gcon</em>       </td><td>(general constructor)</td></tr>
<tr><td> </td><td>|</td><td>  <em>literal</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  ( <em>exp</em> )        </td><td>(parenthesized expression)</td></tr>
<tr><td> </td><td>|</td><td>  ( <em>exp<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>exp<sub>k</sub></em> )       </td><td>(tuple, <em>k</em> ≥ 2)</td></tr>
<tr><td> </td><td>|</td><td>  [ <em>exp<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>exp<sub>k</sub></em> ]       </td><td>(list, <em>k</em> ≥ 1)</td></tr>
<tr><td> </td><td>|</td><td>  [ <em>exp<sub>1</sub></em> [<tt>,</tt> <em>exp<sub>2</sub></em>] .. [<em>exp<sub>3</sub></em>] ]        </td><td>(arithmetic sequence)</td></tr>
<tr><td> </td><td>|</td><td>  [ <em>exp</em> | <em>qual<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>qual<sub>n</sub></em> ]     </td><td>(list comprehension, <em>n</em> ≥ 1)</td></tr>
<tr><td> </td><td>|</td><td>  ( <em>infixexp</em> <em>qop</em> )      </td><td>(left section)</td></tr>
<tr><td> </td><td>|</td><td>  ( <em>qop</em>⟨-⟩ <em>infixexp</em> )       </td><td>(right section)</td></tr>
<tr><td> </td><td>|</td><td>  <em>qcon</em> { <em>fbind<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>fbind<sub>n</sub></em> }     </td><td>(labeled construction, <em>n</em> ≥ 0)</td></tr>
<tr><td> </td><td>|</td><td>  <em>aexp</em>⟨qcon⟩ { <em>fbind<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>fbind<sub>n</sub></em> }       </td><td>(labeled update, <em>n</em>  ≥  1)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>qual</em></td><td>→</td><td><em>pat</em> &lt;- <em>exp</em>       </td><td>(generator)</td></tr>
<tr><td> </td><td>|</td><td>  <tt>let</tt> <em>decls</em>     </td><td>(local declaration)</td></tr>
<tr><td> </td><td>|</td><td>  <em>exp</em>        </td><td>(guard)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>alts</em></td><td>→</td><td><em>alt<sub>1</sub></em> <tt>;</tt> … <tt>;</tt> <em>alt<sub>n</sub></em>      </td><td>(<em>n</em> ≥ 1)</td></tr>
<tr><td><em>alt</em></td><td>→</td><td><em>pat</em> -&gt; <em>exp</em> [<tt>where</tt> <em>decls</em>]</td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <em>pat</em> <em>gdpat</em> [<tt>where</tt> <em>decls</em>]</td><td> </td></tr>
<tr><td> </td><td>|</td><td>          </td><td>(empty alternative)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>gdpat</em></td><td>→</td><td><em>guards</em> -&gt; <em>exp</em> [ <em>gdpat</em> ]</td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>stmts</em></td><td>→</td><td><em>stmt<sub>1</sub></em> … <em>stmt<sub>n</sub></em> <em>exp</em> [<tt>;</tt>]       </td><td>(<em>n</em> ≥ 0)</td></tr>
<tr><td><em>stmt</em></td><td>→</td><td><em>exp</em> ;</td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <em>pat</em> &lt;- <em>exp</em> ;</td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <tt>let</tt> <em>decls</em> ;</td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <tt>;</tt>      </td><td>(<em>empty statement</em>)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>fbind</em></td><td>→</td><td><em>qvar</em> = <em>exp</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>pat</em></td><td>→</td><td><em>lpat</em> <em>qconop</em> <em>pat</em>      </td><td>(infix constructor)</td></tr>
<tr><td> </td><td>|</td><td>  <em>lpat</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>lpat</em></td><td>→</td><td><em>apat</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  - (integer | <em>float</em>)       </td><td>(negative literal)</td></tr>
<tr><td> </td><td>|</td><td>  <em>gcon</em> <em>apat<sub>1</sub></em> … <em>apat<sub>k</sub></em>     </td><td>(arity <em>gcon</em>  =  <em>k</em>, <em>k</em> ≥ 1)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>apat</em></td><td>→</td><td><em>var</em> [ @ <em>apat</em>]        </td><td>(as pattern)</td></tr>
<tr><td> </td><td>|</td><td>  <em>gcon</em>       </td><td>(arity <em>gcon</em>  =  0)</td></tr>
<tr><td> </td><td>|</td><td>  <em>qcon</em> { <em>fpat<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>fpat<sub>k</sub></em> }       </td><td>(labeled pattern, <em>k</em> ≥ 0)</td></tr>
<tr><td> </td><td>|</td><td>  <em>literal</em></td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <em>_</em>      </td><td>(wildcard)</td></tr>
<tr><td> </td><td>|</td><td>  ( <em>pat</em> )        </td><td>(parenthesized pattern)</td></tr>
<tr><td> </td><td>|</td><td>  ( <em>pat<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>pat<sub>k</sub></em> )       </td><td>(tuple pattern, <em>k</em> ≥ 2)</td></tr>
<tr><td> </td><td>|</td><td>  [ <em>pat<sub>1</sub></em> <tt>,</tt> … <tt>,</tt> <em>pat<sub>k</sub></em> ]       </td><td>(list pattern, <em>k</em> ≥ 1)</td></tr>
<tr><td> </td><td>|</td><td>  ~ <em>apat</em>     </td><td>(irrefutable pattern)</td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>fpat</em></td><td>→</td><td><em>qvar</em> = <em>pat</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>gcon</em></td><td>→</td><td>()</td><td> </td></tr>
<tr><td> </td><td>|</td><td>  [<em></em>]</td><td> </td></tr>
<tr><td> </td><td>|</td><td>  (,{,})</td><td> </td></tr>
<tr><td> </td><td>|</td><td>  <em>qcon</em></td><td> </td></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td><em>var</em></td><td>→</td><td><em>varid</em> | ( <em>varsym</em> )       </td><td>(variable)</td></tr>
<tr><td><em>qvar</em></td><td>→</td><td><em>qvarid</em> | ( <em>qvarsym</em> )        </td><td>(qualified variable)</td></tr>
<tr><td><em>con</em></td><td>→</td><td><em>conid</em> | ( <em>consym</em> )       </td><td>(constructor)</td></tr>
<tr><td><em>qcon</em></td><td>→</td><td><em>qconid</em> | ( <em>gconsym</em> )        </td><td>(qualified constructor)</td></tr>
<tr><td><em>varop</em></td><td>→</td><td><em>varsym</em> | <em>`</em>  <em>varid</em> <em>`</em>        </td><td>(variable operator)</td></tr>
<tr><td><em>qvarop</em></td><td>→</td><td><em>qvarsym</em> | <em>`</em>  <em>qvarid</em> <em>`</em>     </td><td>(qualified <em>variable</em> operator)</td></tr>
<tr><td><em>conop</em></td><td>→</td><td><em>consym</em> | <em>`</em>  <em>conid</em> <em>`</em>        </td><td>(constructor operator)</td></tr>
<tr><td><em>qconop</em></td><td>→</td><td><em>gconsym</em> | <em>`</em>  <em>qconid</em> <em>`</em>     </td><td>(qualified <em>constructor</em> operator)</td></tr>
<tr><td><em>op</em></td><td>→</td><td><em>varop</em> | <em>conop</em>     </td><td>(operator)</td></tr>
<tr><td><em>qop</em></td><td>→</td><td><em>qvarop</em> | <em>qconop</em>      </td><td>(qualified operator)</td></tr>
<tr><td><em>gconsym</em></td><td>→</td><td><tt>:</tt> | <em>qconsym</em></td><td> </td></tr>
</tbody></table>
<a class="header" href="#結合性解決" id="結合性解決"><h2>結合性解決</h2></a>
<p>次はHaskellの式における結合性解決の実装例である。結合性解決はHaskellのパターンに対しても適用可能であるが、パターンは式のサブセットであるので、以下では簡単のため式のみを考えることにする。</p>
<p><code>resolve</code>関数はリストであって、それぞれの要素が式または演算子であるもの、すなわち、文脈自由文法において非終端記号<code>infixexp</code>のインスタンスとなるもの(<strong>訳注</strong>: 上の文法表で<em>infixexp</em>に当てはまるもの、の意味)を受け取る。<code>resolve</code>は<code>Just e</code>(ここで<code>e</code>は解決された式)または、入力が意味のある式を表現していない場合には<code>Nothing</code>を返す。もちろん、コンパイラにおいては有益なエラーメッセージを生成するという目的のためには関係する演算子についての情報をより多く返す方がよいであろうが、ここではアルゴリズムを説明するのに<code>Maybe</code>型で十分である。</p>
<pre><code class="language-hs">import Control.Monad  

type Prec   = Int  
type Var    = String  

data Op = Op String Prec Fixity  
  deriving (Eq,Show)  

data Fixity = Leftfix | Rightfix | Nonfix  
  deriving (Eq,Show)  

data Exp = Var Var | OpApp Exp Op Exp | Neg Exp  
  deriving (Eq,Show)  

data Tok = TExp Exp | TOp Op | TNeg  
  deriving (Eq,Show)  

resolve :: [Tok] -&gt; Maybe Exp  
resolve tokens = fmap fst $ parseNeg (Op &quot;&quot; (-1) Nonfix) tokens  
  where  
    parseNeg :: Op -&gt; [Tok] -&gt; Maybe (Exp,[Tok])  
    parseNeg op1 (TExp e1 : rest)  
       = parse op1 e1 rest  
    parseNeg op1 (TNeg : rest)  
       = do guard (prec1 &lt; 6)  
            (r, rest') &lt;- parseNeg (Op &quot;-&quot; 6 Leftfix) rest  
            parse op1 (Neg r) rest'  
       where  
          Op _ prec1 fix1 = op1  

    parse :: Op -&gt; Exp -&gt; [Tok] -&gt; Maybe (Exp, [Tok])  
    parse _   e1 [] = Just (e1, [])  
    parse op1 e1 (TOp op2 : rest)  
       -- case (1): 不当な式をチェック
       | prec1 == prec2 &amp;&amp; (fix1 /= fix2 || fix1 == Nonfix)  
       = Nothing  

       -- case (2): op1とop2は左結合であるべきである
       | prec1 &gt; prec2 || (prec1 == prec2 &amp;&amp; fix1 == Leftfix)  
       = Just (e1, TOp op2 : rest)  

       -- case (3): op1とop2は右結合であるべきである
       | otherwise  
       = do (r,rest') &lt;- parseNeg op2 rest  
            parse op1 (OpApp e1 op2 r) rest'  
       where  
         Op _ prec1 fix1 = op1  
         Op _ prec2 fix2 = op2
</code></pre>
<p>このアルゴリズムは次のように働く。各段階において関数呼び出し</p>
<pre><code class="language-hs">parse op1 E1 (op2 : tokens)
</code></pre>
<p>があるが、これは次のような式であることを確かめていることを意味している。(ここで、呼び出し側がE0を保持している)</p>
<pre><code class="language-hs">E0 ‘op1‘ E1 ‘op2‘ ...     (1)
</code></pre>
<p><code>parse</code>の仕事は<code>op1</code>の右側の式を構築し、入力の残りの部分を返すことである。</p>
<p>3つの場合を考慮する必要がある:</p>
<ol>
<li><code>op1</code>と<code>op2</code>が同じ優先度であるが、同じ結合性を持たない場合あるいは不結合(nonfix)であることが宣言されている場合には、式は不当である。</li>
<li><code>op1</code>が<code>op2</code>よりも高い優先度であるか<code>op1</code>と<code>op2</code>が左結合である場合には、<code>op1</code>の右側の式は<code>E1</code>であることがわかり、よってこれを呼び出し側に返却する。</li>
<li>いずれでもない場合、<code>E1 `op2` R</code>の形の式が求めているものであることがわかる。<code>R</code>を見つけるには、<code>parseNeg op2 tokens</code>を呼び出して<code>op2</code>の右側の式を計算し、これを今は<code>R</code>と名前を付ける(<code>parseNeg</code>以下の部分についての詳細は以下に示すが、本質的には、もしも<code>tokens</code>が<code>(E2 : tokens)</code>の形をしている場合、<code>parseNeg</code>は<code>parse op2 E2 rest</code>と同値である)。さて、<code>E0 `op1` (E1 `op2` R) `op3` ...</code>の形を得た、ここで<code>op3</code>は入力に出現する次の演算子である。これは上の(1)の場合の具体的な例になっているから、<code>E1 == (E1 `op2` R)</code>と新たに置いて<code>parse</code>を続いて呼び出す。</li>
</ol>
<p>アルゴリズムを初期化するには、<code>op1</code>は他の何よりも優先度の低い仮想的な演算子であるとおく。そして<code>parse</code>は入力全体を消費し結果の式を返す。</p>
<p>前置マイナス演算子の<code>-</code>の扱いは若干込み入っている。前置のマイナスは中置のマイナスと同じ結合性であったことを思い出そう、いずれも左結合で優先度は6だ。<code>-</code>の左にくる演算子は、もし存在すれば、式が正当であるためには優先度が6より低くなければならない。マイナス演算子そのものは同じ結合性を持つ演算子に対しては左結合的にはたらく(例: <code>+</code>)。よって例えば<code>-a + b</code>は正当であり<code>(-a) + b</code>として解決されるが、<code>a + -b</code>は不当である。</p>
<p>関数<code>parseNeg</code>は前置マイナスを処理する。前置演算子に遭遇して、それがその位置で正当であれば(左側にある演算子の優先度が6より低ければ)、上の(3)のケースと同様にして進めていく。つまり、<code>-</code>の引数を<code>parseNeg</code>を再帰的に呼ぶことで計算し、そして<code>parse</code>を呼んで続けていく。</p>
<p>このアルゴリズムは優先度の範囲と解決には影響されないことに注意せよ。原則として、Haskellの優先度が1から10までの範囲の整数に制限される理由は何もない。より広い範囲や分数の値を使うことで特別に難しくなるわけではない。</p>
<a class="header" href="#インスタンス導出の仕様" id="インスタンス導出の仕様"><h1>インスタンス導出の仕様</h1></a>
<p>インスタンス導出とは、データまたはnewtype宣言から自動的に生成されるインスタンス宣言である。インスタンス導出のコード本体は対応する型の定義から文法的に導出される。インスタンス導出はコンパイラが知っているクラスに対してのみ可能である。このようなクラスはPreludeまたは標準ライブラリで定義されている。この章では、Preludeによって定義されたクラスの導出について説明する。</p>
<p><code>T</code>が次のように定義された代数的データ型であるとする:</p>
<pre><code class="language-haskell">data cx =&gt; T u1 ... uk = K1 t11 ... t1k1 | ... | Kn tn1 ... tnkn
    deriving (C1, ..., Cm)
</code></pre>
<p>(ここで、<code>m ≥ 0</code>であるとする。また、<code>m = 1</code>のときは括弧は省略できる)</p>
<p>そしてクラス<code>C</code>に対するインスタンス導出宣言は次の条件を満たすときに可能である:</p>
<ol>
<li><code>C</code>は<code>Eq, Ord, Enum, Bounded, Show, Read</code>のいずれかである</li>
<li>文脈<code>cx'</code>であって、<code>cx' =&gt; C tij</code>が構成に使われているすべての型<code>tij</code>について成り立つようなものが存在する</li>
<li><code>C</code>が<code>Bounded</code>であるとき、型は列挙型である(どのコンストラクタもパラメーターを持たない)か、唯一のコンストラクタをもつ</li>
<li><code>C</code>が<code>Enum</code>であるとき、型は列挙型である</li>
<li><code>T u1 ... uk</code>が<code>C</code>のインスタンスになるような明示的なインスタンス宣言がプログラムのどこにも存在しない</li>
<li>データ宣言がコンストラクタをもたないとき(上で<code>n = 0</code>のとき)、どのクラスも導出可能でない(<code>m = 0</code>である)</li>
</ol>
<p>インスタンスを導出するという目的から、<code>newtype</code>宣言は<code>data</code>宣言で1つコンストラクタをもつものとして扱われる。</p>
<p><code>deriving</code>の形があるとき、各クラス<code>Ci</code>に対する<code>T u1 ... uk</code>のインスタンス宣言は自動的に生成される。どれかの<code>Ci</code>に対してインスタンス宣言が導出不可能であるとき、静的エラーが返る。インスタンス導出が必要でないときは、<code>deriving</code>の形は省略されるか、<code>deriving ()</code>が使われることもある。</p>
<p>それぞれの導出されたインスタンス宣言は <code>instance (cx, cx') =&gt; Ci (T u1 ... uk) where { d }</code> の形をしている。ただし<code>d</code>は<code>Ci</code>と<code>T</code>のデータ型宣言に依存して自動的に導出される(これについてはこのセクションの残りで説明する))。</p>
<p>コンテキスト <code>cx'</code>は上の(2)を満たす最小のコンテキストである。相互再帰データ型でこれを計算するためにコンパイラは不動点の計算を行う必要があることがある。</p>
<p>Preludeのクラスで導出可能なそれぞれについてのインスタンス導出の詳細をここで与える。ここでの説明で登場する自由変数とコンストラクタはすべて<code>Prelude</code>で定義されたものを指している。</p>
<a class="header" href="#eqとordのインスタンス導出" id="eqとordのインスタンス導出"><h3><code>Eq</code>と<code>Ord</code>のインスタンス導出</h3></a>
<p><code>Eq</code>と<code>Ord</code>のインスタンス導出によって自動的に導入されるクラスメソッドは <code>(==), (/=), compare, (&lt;), (&lt;=), (&gt;), (&gt;=), max, min</code>である。最後の7つの演算子は各コンストラクタの集合ごとに辞書順で比較を行うように定義される。すなわち、データ型宣言で先に書かれたコンストラクタは後に書かれたコンストラクタよりも小さい値として扱われる。例えば、<code>Bool</code>データ型に対して、<code>(True &gt; False) == True</code>が成り立つ。</p>
<p>導出された比較はコンストラクタを常に左から右に向かって走査する。このことは次の例から確かめられる:</p>
<pre><code class="language-haskell">(1,undefined) == (2,undefined) =&gt;    False
(undefined,1) == (undefined,2) =&gt;    ⊥
</code></pre>
<p>導出されたクラス<code>Eq</code>と<code>Ord</code>の演算はいずれも引数に対して正格である。例えば、<code>False</code>は<code>Bool</code>型の最初のコンストラクタであるが<code>False &lt;= ⊥</code>は<code>⊥</code>である。</p>
<a class="header" href="#enumのインスタンス導出" id="enumのインスタンス導出"><h3><code>Enum</code>のインスタンス導出</h3></a>
<p><code>Enum</code>のインスタンス導出宣言は列挙型(すべてのコンストラクタが引数をとらないようなデータ型)に対してのみ可能である。</p>
<p>引数をとらないコンストラクタはは左から右に向かって<code>0</code>から<code>n-1</code>までナンバリングされていると仮定する。このナンバリングの仕組みの下で<code>succ</code>と<code>pred</code>は値の次の値と前の値を与える演算子である。<code>succ</code>を最大の要素に適用したときと<code>pred</code>を最小の要素に適用したときはエラーになる。</p>
<p><code>toEnum</code>と<code>fromEnum</code>は列挙された値を<code>Int</code>へ、または<code>Int</code>から変換する演算子である。<code>toEnum</code>は<code>Int</code>の引数に一致するコンストラクタの番号がない場合は実行時エラーになる。</p>
<p>他のメソッドの定義は次である:</p>
<pre><code class="language-haskell">enumFrom x           = enumFromTo x lastCon
enumFromThen x y     = enumFromThenTo x y bound
    where  
        bound
            | fromEnum y &gt;= fromEnum x = lastCon
            | otherwise                = firstCon
enumFromTo x y       = map toEnum [fromEnum x .. fromEnum y]
enumFromThenTo x y z = map toEnum [fromEnum x, fromEnum y .. fromEnum z]
</code></pre>
<p>ここで、<code>firstCon</code>と<code>lastCon</code>はそれぞれ<code>data</code>宣言にある最初と最後のコンストラクタである。例として、データ型</p>
<pre><code class="language-haskell">data Color = Red | Orange | Yellow | Green deriving (Enum)
</code></pre>
<p>が与えられたとき、次のようになる:</p>
<pre><code class="language-haskell">[Orange ..]         ==  [Orange, Yellow, Green]  
fromEnum Yellow     ==  2
</code></pre>
<a class="header" href="#boundedのインスタンス導出" id="boundedのインスタンス導出"><h3><code>Bounded</code>のインスタンス導出</h3></a>
<p><code>Bounded</code>クラスは<code>minBound</code>と<code>maxBound</code>をクラスメソッドとして導入するが、これはそれぞれその型の最小、最大の要素を定めるメソッドである。列挙型に対しては、<code>data</code>宣言にある最初と最後のコンストラクタが境界になる。コンストラクタが1つの型に対しては、コンストラクタを構成型の教会に適用したものになる。例として、次のデータ型を考える。</p>
<pre><code class="language-haskell">data Pair a b = Pair a b deriving Bounded
</code></pre>
<p>これは次のような<code>Bounded</code>インスタンスを生成する:</p>
<pre><code class="language-haskell">instance (Bounded a,Bounded b) =&gt; Bounded (Pair a b) where  
    minBound = Pair minBound minBound  
    maxBound = Pair maxBound maxBound
</code></pre>
<a class="header" href="#readとshowのインスタンス導出" id="readとshowのインスタンス導出"><h3><code>Read</code>と<code>Show</code>のインスタンス導出</h3></a>
<p><code>Read</code>と<code>Show</code>のインスタンス導出で自動的に導入されるクラスメソッドは<code>showsPrec, readsPrec, showList, readList</code>である。これらは値を文字列に変換し、文字列をパースして値にするために使われる。</p>
<p>関数<code>showsPrec d x r</code>は優先度<code>d</code>(<code>0</code>から<code>11</code>の間の数値をとる)、値<code>x</code>、文字列<code>r</code>を受ける。これは<code>r</code>に<code>x</code>の文字列表現を結合したものを返す。<code>showsPrec</code>は次の規則を満たす: <code>showsPrec d x r ++ s == showsPred d x (r ++ s)</code> この表現は、<code>x</code>のトップレベルコンストラクタの優先度が<code>d</code>よりも小さいときは括弧で囲われる。追加のパラメータ<code>r</code>は木などの構造を木のサイズに対して二次関数的でなく線形時間で出力するためには必須になる。</p>
<p>関数<code>readsPrec d s</code>は優先度<code>d</code>(<code>0</code>から<code>10</code>の数値をとる)と文字列<code>s</code>を受け取り、文字列の先頭から値をパースすることを試み、(パースされた値, 残りの文字列)なるペアのリストを返す。パースに成功することがない場合、返却されるリストは空になる。括弧のない中置演算子の適用のパースが成功するのは演算子の優先度が<code>d</code>以上の時だけである。</p>
<p>次が成り立つ。</p>
<pre><code class="language-haskell">(x,&quot;&quot;) は (readsPrec d (showsPrec d x &quot;&quot;)) の要素である
</code></pre>
<p>つまり、<code>readsPrec</code>は<code>showsPrec</code>によって生成された文字列をパースでき、<code>showsPrec</code>に初めに渡された値が得られるべきである。</p>
<p><code>showList</code>と<code>readList</code>は標準的でない表示を使ってオブジェクトのリストを表現できるようにする。</p>
<p><code>readsPrec</code>は文字列以外の標準的な型のどんな有効な表現もパースできる。文字列に対してはクォートされた文字列のみが許され、他にはリストに対しては、ブラケットで囲まれた形<code>[...]</code>のみが許される。詳細は9章(<strong>[訳注]</strong> リンク)を見よ。</p>
<p><code>show</code>の結果は、結合性の宣言がその型が宣言された時点で有効になっている場合であれば、定数のみを含んだHaskellの文法的に正しい式になる。戻り値は、データ型で定義されたコンストラクタの名前と括弧、スペースのみを含む。ラベル付きコンストラクタフィールドが使われているときは、波括弧、コンマ、フィールド名、等号も使われる。括弧は<strong>結合性を無視して</strong>必要なところでだけ追加される。<code>show</code>の戻り値は、すべてのコンポーネント型がread可能ならば<code>read</code>できる。(これはPreludeで定義されたすべてのインスタンスに対しては正しいが、ユーザーによって定義されたインスタンスではそうとは限らない。)</p>
<p><code>Read</code>のインスタンス導出によって、次のようなことが仮定される。そしてこれらの過程は<code>Show</code>のインスタンス導出も従う:</p>
<ul>
<li>
<p>コンストラクタが中置演算子として定義されているならば、<code>Read</code>インスタンスの導出はコンストラクタの(前置形ではなく)中置適用のみをパースする。</p>
</li>
<li>
<p>結合性は括弧を減らすためには使われないが、優先度はそうと使われる場合がある。例として</p>
<pre><code class="language-haskell">infixr 4 :$
data T = Int :$ T | NT
</code></pre>
<p>があったとき、</p>
<ul>
<li><code>show (1 :$ 2 :$ NT)</code>は文字列<code>&quot;1 :$ (2 :$ NT)&quot;</code>を生成する。</li>
<li><code>read &quot;1 :$ (2 :$ NT)&quot;</code>は成功し、当然の結果を返す。</li>
<li><code>read 1 :$ 2 :$ NT</code>は失敗する。</li>
</ul>
</li>
<li>
<p>コンストラクタがレコード構文により定義されている場合、導出された<code>Read</code>はレコード構文の形のみパースし、さらにフィールドは元々の宣言と同じ順番でしか与えることはできない。</p>
</li>
<li>
<p><code>Read</code>インスタンスの導出は入力文字列のトークンの間に任意のHaskellの空白を許す。余分な括弧も許される。</p>
</li>
</ul>
<p><code>Read</code>と<code>Show</code>インスタンスの導出が不適切なケースもある。次のような問題がある:</p>
<ul>
<li>循環構造はこれらのインスタンスによっては出力、読み取りできない。</li>
<li>出力によって部分構造の共有が失われる。つまり、オブジェクトが出力された表現は必要より遥かに大きくなる場合がある。</li>
<li><code>read</code>で使われるパースの方法は非常に非効率的であるので、巨大な構造の読み取りは非常に遅い場合がある。</li>
<li>Preludeで定義された型の出力はユーザーによる制御ができない。例えば、浮動小数点数のフォーマットを変える方法がない。</li>
</ul>
<a class="header" href="#例-1" id="例-1"><h3>例</h3></a>
<p>完結した例として木構造を考えよう:</p>
<pre><code class="language-haskell">data Tree a = Leaf a | Tree a :^: Tree a
    deriving (Eq, Ord, Read, Show)
</code></pre>
<p><code>Tree</code>は列挙型でもなければコンストラクタが1つでもないので、<code>Bounded</code>と<code>Enum</code>のインスタンスの自動導出はできない。<code>Tree</code>のインスタンス宣言の完全なものはFigure 11.1にある。デフォルトクラスメソッド定義に注意せよ。例えば、<code>Ord</code>に対しては<code>&lt;=</code>のみが定義されており、ほかのクラスメソッド(<code>&lt;,&gt;,&gt;=,max,min</code>)はFigure 6.1に示されている、クラス宣言で与えられたデフォルト値によって与えられている。</p>
<p><strong>Figure11.1</strong>: インスタンス導出の例</p>
<pre><code class="language-haskell">infixr 5 :^:  
data Tree a =  Leaf a  |  Tree a :^: Tree a  
 
instance (Eq a) =&gt; Eq (Tree a) where  
        Leaf m == Leaf n  =  m==n  
        u:^:v  == x:^:y   =  u==x &amp;&amp; v==y  
             _ == _       =  False  
 
instance (Ord a) =&gt; Ord (Tree a) where  
        Leaf m &lt;= Leaf n  =  m&lt;=n  
        Leaf m &lt;= x:^:y   =  True  
        u:^:v  &lt;= Leaf n  =  False  
        u:^:v  &lt;= x:^:y   =  u&lt;x || u==x &amp;&amp; v&lt;=y  
 
instance (Show a) =&gt; Show (Tree a) where  
 
        showsPrec d (Leaf m) = showParen (d &gt; app_prec) showStr  
          where  
             showStr = showString &quot;Leaf &quot; . showsPrec (app_prec+1) m  
 
        showsPrec d (u :^: v) = showParen (d &gt; up_prec) showStr  
          where  
             showStr = showsPrec (up_prec+1) u .  
                       showString &quot; :^: &quot;      .  
                       showsPrec (up_prec+1) v  
                -- Note: right-associativity of :^: ignored  
 
instance (Read a) =&gt; Read (Tree a) where  
 
        readsPrec d r =  readParen (d &gt; up_prec)  
                         (\r -&gt; [(u:^:v,w) |  
                                 (u,s) &lt;- readsPrec (up_prec+1) r,  
                                 (&quot;:^:&quot;,t) &lt;- lex s,  
                                 (v,w) &lt;- readsPrec (up_prec+1) t]) r  
 
                      ++ readParen (d &gt; app_prec)  
                         (\r -&gt; [(Leaf m,t) |  
                                 (&quot;Leaf&quot;,s) &lt;- lex r,  
                                 (m,t) &lt;- readsPrec (app_prec+1) s]) r  
 
up_prec  = 5    -- :^: の結合優先度
app_prec = 10   -- 適用はどんな結合優先度の高い演算子よりも優先度が高い
</code></pre>
<a class="header" href="#コンパイラプラグマ" id="コンパイラプラグマ"><h1>コンパイラプラグマ</h1></a>
<p>一部のコンパイラ実装は <strong>コンパイラプラグマ</strong> と呼ばれる仕組みを備えている。これはコンパイラに対して命令を追加したりヒントを与えるようなものであるが、これは正確にはHaskell言語の規格には含まれず、よってプログラムの意味を変えない。この章では実際に使われてきた実践をまとめたものである。実装が各プラグマを提供することは必須ではないが、実装によって認識されないプラグマは無視されるべきである。実際に多くの言語拡張が使われていることもあり、実装は以下に述べるLANGUAGEプラグマをサポートすることが強く推奨されている。</p>
<p>トークンとしては、プラグマは <code>{-##-}</code> で囲まれる文法であることを除いてはコメントと同じ方法で記される。</p>
<a class="header" href="#インライン化" id="インライン化"><h3>インライン化</h3></a>
<pre>
<em>decl</em> -> {-# INLINE <em>qvars</em> #-}
<em>decl</em> -> {-# NOINLINE <em>qvars</em> #-}
</pre>
<p><code>INLINE</code>プラグマは、コンパイラが指定の変数を使用する際にインライン化するよう指示する。コンパイラは単純な式のインライン化をしばしば自動的に行う。<code>NOINLINE</code>プラグマによってインライン化を止めることもある。</p>
<a class="header" href="#特殊化" id="特殊化"><h3>特殊化</h3></a>
<pre>
<em>decl</em> -> {-# SPECIALIZE <em>spec_1</em>, ..., <em>spec_k</em> #-}   (k >= 1)
<em>spec</em> -> <em>vars</em> :: <em>type</em>
</pre>
<p>特殊化はオーバーロードされた関数が非効率に実行されることを防ぐ目的で使われる。例えば、次のプログラム</p>
<pre><code class="language-haskell">factorial :: Num a =&gt; a -&gt; a  
factorial 0 = 0  
factorial n = n ⋆ factorial (n-1)  
{-# SPECIALIZE factorial :: Int -&gt; Int,  
               factorial :: Integer -&gt; Integer #-}
</code></pre>
<p>では、<code>factorial</code>の呼び出しで、コンパイラが渡されたパラメーターが<code>Int</code>または<code>Integer</code>であることを検出すると、数値オーバーロードされた方ではなく特殊化された<code>factorial</code>を用いる。</p>
<a class="header" href="#言語拡張" id="言語拡張"><h3>言語拡張</h3></a>
<p><code>LANGUAGE</code>プラグマはファイルの先頭に記述するプラグマ(ファイルヘッダープラグマ)である。ファイルヘッダープラグマはソースファイルでモジュールキーワードよりも前に置かなければならない。ファイルヘッダープラグマは好きなだけ書くことができるし、コメントよりも先に書いても後に書いてもよい。個々のLANGUAGEプラグマは<code>LANGUAGE</code>キーワードで始まり、カンマで区切られた、言語機能の名前の列を続けて書く。</p>
<p>例えば、スコープ付き型変数とCPPによるプリプロセッシングを有効にしたいのであれば、使っているHaskell実装がそれらをサポートしていれば、</p>
<pre><code class="language-haskell">{-# LANGUAGE ScopedTypeVariables, CPP #-}
</code></pre>
<p>と書くことができる。</p>
<p>Haskellの実装がソースファイルで要求された特定の言語機能を認識またはサポートしない(または要求された言語機能を組み合わてサポートできない)場合は、いかなる方法によるコンパイルでも、あるいはいかなる方法でそのファイルとHaskell実装を用いても、エラーによって失敗しなければならない。</p>
<p>移植性の観点から、サポートされた同じ言語機能を有効にする場合はどのような仕方でも明確に認められている(例: コマンドライン引数、あるいは実装が指定する依存関係や標準的でないプラグマを経由するなど)。<code>LANGUAGE</code>プラグマをサポートするHaskell 2010実装は</p>
<pre><code class="language-haskell">{-# LANGUAGE Haskell2010 #-}
</code></pre>
<p>をサポートしなければならない。</p>
<p>そのような実装はさらに次のような名前の言語機能をサポートすることが推奨されている:</p>
<pre><code class="language-haskell">PatternGuards, NoNPlusKPatterns, RelaxedPolyRec,  
EmptyDataDecls, ForeignFunctionInterface
</code></pre>
<p>これらはHaskell 2010以前、一部の実装でサポートされていたものがこのレポートに入ることになった言語拡張である。</p>
<a class="header" href="#controlmonad" id="controlmonad"><h1>Control.Monad</h1></a>
<pre><code class="language-hs">module Control.Monad (  
    Functor(fmap),  Monad((&gt;&gt;=), (&gt;&gt;), return, fail),  MonadPlus(mzero, mplus),  
    mapM,  mapM_,  forM,  forM_,  sequence,  sequence_,  (=&lt;&lt;),  (&gt;=&gt;),  (&lt;=&lt;),  
    forever,  void,  join,  msum,  filterM,  mapAndUnzipM,  zipWithM,  
    zipWithM_,  foldM,  foldM_,  replicateM,  replicateM_,  guard,  when,  
    unless,  liftM,  liftM2,  liftM3,  liftM4,  liftM5,  ap  
  ) where
</code></pre>
<p><code>Control.Monad</code>モジュールは<code>Functor</code>, <code>Monad</code>, <code>MonadPlus</code>クラスと、いくつかのモナド上の便利な演算子を提供する。</p>
<p>(<strong>訳注</strong>: 以下の説明は現状のGHCの提供するものとは異なっています。)</p>
<a class="header" href="#functorとmonadクラス" id="functorとmonadクラス"><h2>FunctorとMonadクラス</h2></a>
<a class="header" href="#型クラス" id="型クラス"><h4>型クラス</h4></a>
<pre><code class="language-hs">class Functor f where
</code></pre>
<p><code>Functor</code>クラスはそれ上にマップできるような型に使われる。<code>Functor</code>インスタンスは次の法則を満たすべきである:</p>
<ul>
<li><code>fmap id == id</code></li>
<li><code>fmap (f . g) == fmap f . fmap g</code></li>
</ul>
<p>リスト、<code>Data.Maybe.Maybe</code>、<code>System.IO.IO</code>に対する<code>Functor</code>のインスタンスはこの法則を満たす。</p>
<a class="header" href="#メソッド" id="メソッド"><h4>メソッド</h4></a>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<a class="header" href="#インスタンス" id="インスタンス"><h4>インスタンス</h4></a>
<pre><code class="language-hs">instance Functor []
instance Functor IO
instance Functor Maybe
instance Ix i =&gt; Functor (Array i)
</code></pre>
<a class="header" href="#型クラス-1" id="型クラス-1"><h4>型クラス</h4></a>
<pre><code class="language-hs">class Monad f where
</code></pre>
<p><code>Monad</code>クラスはモナド上の基本的な演算子を定義する。<strong>モナド</strong>は<strong>圏論</strong>と呼ばれる数学の一分野から来た概念である。しかしながら、Haskellプログラマの観点からはモナドはアクションの<strong>抽象データ型</strong>のことであると思うのが最適である。Haskellの<code>do</code>式はモナディックな式を書くための便利な構文を提供している。</p>
<p>最小完全定義: <code>&gt;&gt;=</code>と<code>return</code></p>
<p><code>Monad</code>のインスタンスは次の法則をみたすべきである:</p>
<ul>
<li><code>return a &gt;&gt;= k == k a</code></li>
<li><code>m &gt;&gt;= return == m</code></li>
<li><code>m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h) == (m &gt;&gt;= k) &gt;&gt;= h</code></li>
</ul>
<p><code>Monad</code>と<code>Functor</code>のインスタンスは追加で次の法則も満たすべきである。</p>
<ul>
<li><code>fmap f xs == xs &gt;&gt;= return . f</code></li>
</ul>
<p>Preludeで定義されているリスト、<code>Data.Maybe.Maybe</code>、<code>System.IO.IO</code>に対する<code>Monad</code>のインスタンスはこの法則を満たす。</p>
<a class="header" href="#メソッド-1" id="メソッド-1"><h4>メソッド</h4></a>
<pre><code class="language-hs">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
</code></pre>
<p>最初のアクションによって生成された値を2つ目のアクションの引数として渡すことで連続して2つのアクションを合成する。</p>
<pre><code class="language-hs">(&gt;&gt;) :: m a -&gt; m b -&gt; m b
</code></pre>
<p>最初のアクションによって生成された値を捨てることで連続して2つのアクションを合成する。これは手続き型言語での順列を表す演算子(例えばセミコロン)のようなものである。</p>
<pre><code class="language-hs">return :: a -&gt; m a
</code></pre>
<p>値をモナディックな型に注入する。</p>
<pre><code class="language-hs">fail :: String -&gt; m a
</code></pre>
<p>メッセージとともに失敗する。この演算子はモナドの数学的な定義の一部ではないが、<code>do</code>式の中でパターンマッチに失敗した際に呼ばれる。</p>
<a class="header" href="#インスタンス-1" id="インスタンス-1"><h4>インスタンス</h4></a>
<pre><code class="language-hs">instance Monad []
instance Monad IO
instance Monad Maybe
</code></pre>
<a class="header" href="#型クラス-2" id="型クラス-2"><h4>型クラス</h4></a>
<pre><code class="language-hs">class Monad m =&gt; MonadPlus m where
</code></pre>
<p>モナドであって、選択と失敗を備えたもの。</p>
<a class="header" href="#メソッド-2" id="メソッド-2"><h4>メソッド</h4></a>
<pre><code class="language-hs">mzero :: m a
</code></pre>
<p><code>mplus</code>の単位元。さらに次の法則も満たすべきである:</p>
<ul>
<li><code>mzero &gt;&gt;= f = mzero</code></li>
<li><code>v &gt;&gt; mzero = mzero</code></li>
</ul>
<pre><code class="language-hs">mplus :: m a -&gt; m a -&gt; m a
</code></pre>
<p>結合的な演算子。</p>
<a class="header" href="#インスタンス-2" id="インスタンス-2"><h4>インスタンス</h4></a>
<pre><code class="language-hs">instance MonadPlus []
instance MonadPlus Maybe
</code></pre>
<a class="header" href="#関数" id="関数"><h2>関数</h2></a>
<a class="header" href="#名前付けの慣習" id="名前付けの慣習"><h3>名前付けの慣習</h3></a>
<p>このライブラリの関数は次のような名前付けの慣習に従っている。</p>
<ul>
<li><code>M</code>が後ろにつくものはクライスリ圏での関数を表す。すなわち、モナド型コンストラクタ<code>m</code>が関数の結果(カリー化していない形)に対して付けられ、それ以外にはつかない。よって、例としては次:</li>
</ul>
<pre><code class="language-hs">filter  ::              (a -&gt;   Bool) -&gt; [a] -&gt;   [a]  
filterM :: (Monad m) =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m [a]
</code></pre>
<ul>
<li><code>_</code>が後ろにつくものは結果の型が<code>(m a)</code>から<code>(m ())</code>になる。よって、例としては次:</li>
</ul>
<pre><code class="language-hs">sequence  :: Monad m =&gt; [m a] -&gt; m [a]  
sequence_ :: Monad m =&gt; [m a] -&gt; m ()
</code></pre>
<ul>
<li><code>m</code>が先頭につくものは、すでに存在する関数をモナディックな形に一般化したものである。よって、例としては次:</li>
</ul>
<pre><code class="language-hs">sum  :: Num a       =&gt; [a]   -&gt; a  
msum :: MonadPlus m =&gt; [m a] -&gt; m a
</code></pre>
<a class="header" href="#monadの基本的な関数" id="monadの基本的な関数"><h3><code>Monad</code>の基本的な関数</h3></a>
<pre><code class="language-hs">mapM :: Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
</code></pre>
<p><code>mapM f</code>は<code>sequence . map f</code>と同値である。</p>
<pre><code class="language-hs">mapM_ :: Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m ()
</code></pre>
<p><code>mapM_ f</code>は<code>sequence_ . map f</code>と同値である。</p>
<pre><code class="language-hs">forM :: Monad m =&gt; [a] -&gt; (a -&gt; m b) -&gt; m [b]
</code></pre>
<p><code>forM</code>は<code>mapM</code>の引数を逆にしたものである。</p>
<pre><code class="language-hs">forM_ :: Monad m =&gt; [a] -&gt; (a -&gt; m b) -&gt; m ()
</code></pre>
<p><code>forM_</code>は<code>mapM_</code>の引数を逆にしたものである。</p>
<pre><code class="language-hs">sequence :: Monad m =&gt; [m a] -&gt; m [a]
</code></pre>
<p>各アクションを左から右に順番に評価し、結果を集める。</p>
<pre><code class="language-hs">sequence_ :: Monad m =&gt; [m a] -&gt; m ()
</code></pre>
<p>各アクションを左から右に順番に評価し、結果を無視する。</p>
<pre><code class="language-hs">(=&lt;&lt;) :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</code></pre>
<p><code>&gt;&gt;=</code>と同じで、引数が入れ替えたもの。</p>
<pre><code class="language-hs">(&gt;=&gt;) :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c
</code></pre>
<p>左から右へのモナドのクライスリ合成。</p>
<pre><code class="language-hs">(&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
</code></pre>
<p>右から左へのモナドのクライスリ合成。<code>&gt;&gt;=</code>の引数を逆にしたもの。</p>
<pre><code class="language-hs">forever :: Monad m =&gt; m a -&gt; m b
</code></pre>
<p><code>forever act</code>はアクションを無限に繰り返す。</p>
<pre><code class="language-hs">void :: Functor f =&gt; f a -&gt; f ()
</code></pre>
<p><code>void value</code>は<code>IO</code>アクションの結果の値といった評価の結果を捨て、または無視する。</p>
<a class="header" href="#リストの関数の一般化" id="リストの関数の一般化"><h3>リストの関数の一般化</h3></a>
<pre><code class="language-hs">join :: Monad m =&gt; m (m a) -&gt; m a
</code></pre>
<p><code>join</code>関数はモナドの従来のjoin演算子である。モナドの構造を1レベル取り除き、(束縛されている)引数をより外側のレベルへ射影するために使われる。</p>
<pre><code class="language-hs">msum :: MonadPlus m =&gt; [m a] -&gt; m a
</code></pre>
<p>リストに対する<code>concat</code>関数の一般化である。</p>
<pre><code class="language-hs">filterM :: Monad m =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m [a]
</code></pre>
<p>リストに対する<code>filter</code>関数の一般化である。</p>
<pre><code class="language-hs">mapAndUnzipM :: Monad m =&gt; (a -&gt; m (b, c)) -&gt; [a] -&gt; m ([b], [c])
</code></pre>
<p><code>mapAndUnzipM</code>関数は第一引数をリストに適用し、ペアのリストを結果として返す。この関数は複雑なデータや状態変化を行うようなモナドで主に使われる。</p>
<pre><code class="language-hs">zipWithM :: Monad m =&gt; (a -&gt; b -&gt; m c) -&gt; [a] -&gt; [b] -&gt; m [c]
</code></pre>
<p><code>zipWithM</code>関数は<code>zipWith</code>を任意のモナドに一般化したものである。</p>
<pre><code class="language-hs">zipWithM_ :: Monad m =&gt; (a -&gt; b -&gt; m c) -&gt; [a] -&gt; [b] -&gt; m ()
</code></pre>
<p><code>zipWithM_</code>は<code>zipWithM</code>の拡張で、最後の結果を無視するものである。</p>
<pre><code class="language-hs">foldM :: Monad m =&gt; (a -&gt; b -&gt; m a) -&gt; a -&gt; [b] -&gt; m a
</code></pre>
<p><code>foldM</code>関数は<code>foldl</code>に似たものであるが、結果がモナドに包まれているところが異なる。<code>foldM</code>は引数であるリストを左から右に向かって走査することに注意せよ。このことは、<code>&gt;&gt;</code>と&quot;畳み込み関数&quot;が可換でない場合に問題になりうる。</p>
<pre><code class="language-hs">       foldM f a1 [x1, x2, ..., xm]
==

       do  
         a2 &lt;- f a1 x1  
         a3 &lt;- f a2 x2  
         ...  
         f am xm
</code></pre>
<p>右から左に向かった評価が必要であれば、入力のリストを反転させればよい。</p>
<pre><code class="language-hs">foldM_ :: Monad m =&gt; (a -&gt; b -&gt; m a) -&gt; a -&gt; [b] -&gt; m ()
</code></pre>
<p><code>foldM</code>に近いが、結果を捨てる。</p>
<pre><code class="language-hs">replicateM :: Monad m =&gt; Int -&gt; m a -&gt; m [a]
</code></pre>
<p><code>replicateM n act</code>はアクションを<code>n</code>回行い、結果を集める。</p>
<pre><code class="language-hs">replicateM_ :: Monad m =&gt; Int -&gt; m a -&gt; m ()
</code></pre>
<p><code>replicateM</code>に近いが、結果を捨てる。</p>
<a class="header" href="#モナディックな式の条件付き実行" id="モナディックな式の条件付き実行"><h3>モナディックな式の条件付き実行</h3></a>
<pre><code class="language-hs">guard :: MonadPlus m =&gt; Bool -&gt; m ()
</code></pre>
<p><code>guard b</code>は<code>b</code>が<code>True</code>であれば<code>return ()</code>であり、<code>b</code>が<code>False</code>であれば<code>mzero</code>である。</p>
<pre><code class="language-hs">when :: Monad m =&gt; Bool -&gt; m () -&gt; m ()
</code></pre>
<p>モナディックな式の条件付き実行である。例えば、</p>
<pre><code class="language-hs">       when debug (putStr &quot;Debugging\n&quot;)
</code></pre>
<p>はブール値<code>debug</code>が<code>True</code>であれば文字列<code>Debugging\n</code>を出力し、そうでなければ何もしない。</p>
<pre><code class="language-hs">unless :: Monad m =&gt; Bool -&gt; m () -&gt; m ()
</code></pre>
<p><code>when</code>の逆である。</p>
<a class="header" href="#モナディックな持ち上げ演算子" id="モナディックな持ち上げ演算子"><h3>モナディックな持ち上げ演算子</h3></a>
<pre><code class="language-hs">liftM :: Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</code></pre>
<p>関数をモナドに持ち上げる。</p>
<pre><code class="language-hs">liftM2 :: Monad m =&gt; (a1 -&gt; a2 -&gt; r) -&gt; m a1 -&gt; m a2 -&gt; m r
</code></pre>
<p>関数をモナドに持ち上げ、モナディックな引数を左から右へと走査する。例えば、</p>
<pre><code class="language-hs">    liftM2 (+) [0,1] [0,2] = [0,2,1,3]  
    liftM2 (+) (Just 1) Nothing = Nothing
</code></pre>
<pre><code class="language-hs">liftM3 :: Monad m =&gt; (a1 -&gt; a2 -&gt; a3 -&gt; r)
                     -&gt; m a1 -&gt; m a2 -&gt; m a3 -&gt; m r
</code></pre>
<p>関数をモナドに持ち上げ、モナディックな引数を左から右へと走査する。(<code>liftM2</code>を参照)</p>
<pre><code class="language-hs">liftM4 :: Monad m =&gt; (a1 -&gt; a2 -&gt; a3 -&gt; a4 -&gt; r)
                     -&gt; m a1 -&gt; m a2 -&gt; m a3 -&gt; m a4 -&gt; m r
</code></pre>
<p>関数をモナドに持ち上げ、モナディックな引数を左から右へと走査する。(<code>liftM2</code>を参照)</p>
<pre><code class="language-hs">liftM5 :: Monad m =&gt; (a1 -&gt; a2 -&gt; a3 -&gt; a4 -&gt; a5 -&gt; r)
                     -&gt; m a1 -&gt; m a2 -&gt; m a3 -&gt; m a4 -&gt; m a5 -&gt; m r
</code></pre>
<p>関数をモナドに持ち上げ、モナディックな引数を左から右へと走査する。(<code>liftM2</code>を参照)</p>
<pre><code class="language-hs">ap :: Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
</code></pre>
<p>多く場合<code>liftM</code>演算子は、(関数適用を持ち上げる)<code>ap</code>を使用したものに置き換えることができる。</p>
<pre><code class="language-hs">       return f ‘ap‘ x1 ‘ap‘ ... ‘ap‘ xn
</code></pre>
<p>は次と等しい。</p>
<pre><code class="language-hs">       liftMn f x1 x2 ... xn
</code></pre>
<a class="header" href="#dataarray" id="dataarray"><h1>Data.Array</h1></a>
<a class="header" href="#databits" id="databits"><h1>Data.Bits</h1></a>
<a class="header" href="#datachar" id="datachar"><h1>Data.Char</h1></a>
<a class="header" href="#datacomplex" id="datacomplex"><h1>Data.Complex</h1></a>
<a class="header" href="#dataint" id="dataint"><h1>Data.Int</h1></a>
<a class="header" href="#dataix" id="dataix"><h1>Data.Ix</h1></a>
<a class="header" href="#datalist" id="datalist"><h1>Data.List</h1></a>
<a class="header" href="#datamaybe" id="datamaybe"><h1>Data.Maybe</h1></a>
<a class="header" href="#dataratio" id="dataratio"><h1>Data.Ratio</h1></a>
<a class="header" href="#dataword" id="dataword"><h1>Data.Word</h1></a>
<a class="header" href="#foreign" id="foreign"><h1>Foreign</h1></a>
<a class="header" href="#foreignc" id="foreignc"><h1>Foreign.C</h1></a>
<a class="header" href="#foreigncerror" id="foreigncerror"><h1>Foreign.C.Error</h1></a>
<a class="header" href="#foreigncstring" id="foreigncstring"><h1>Foreign.C.String</h1></a>
<a class="header" href="#foreignctypes" id="foreignctypes"><h1>Foreign.C.Types</h1></a>
<a class="header" href="#foreignforeignptr" id="foreignforeignptr"><h1>Foreign.ForeignPtr</h1></a>
<a class="header" href="#foreignmarshal" id="foreignmarshal"><h1>Foreign.Marshal</h1></a>
<a class="header" href="#foreignmarshalalloc" id="foreignmarshalalloc"><h1>Foreign.Marshal.Alloc</h1></a>
<a class="header" href="#foreignmarshalarray" id="foreignmarshalarray"><h1>Foreign.Marshal.Array</h1></a>
<a class="header" href="#foreignmarshalerror" id="foreignmarshalerror"><h1>Foreign.Marshal.Error</h1></a>
<a class="header" href="#foreignmarshalutils" id="foreignmarshalutils"><h1>Foreign.Marshal.Utils</h1></a>
<a class="header" href="#foreignptr" id="foreignptr"><h1>Foreign.Ptr</h1></a>
<a class="header" href="#foreginstableptr" id="foreginstableptr"><h1>Foregin.StablePtr</h1></a>
<a class="header" href="#foreginstorable" id="foreginstorable"><h1>Foregin.Storable</h1></a>
<a class="header" href="#numeric" id="numeric"><h1>Numeric</h1></a>
<a class="header" href="#systemenvironment" id="systemenvironment"><h1>System.Environment</h1></a>
<a class="header" href="#sytemexit" id="sytemexit"><h1>Sytem.Exit</h1></a>
<a class="header" href="#systemio" id="systemio"><h1>System.IO</h1></a>
<a class="header" href="#systemioerror" id="systemioerror"><h1>System.IO.Error</h1></a>
<a class="header" href="#参考文献" id="参考文献"><h1>参考文献</h1></a>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="customize.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
