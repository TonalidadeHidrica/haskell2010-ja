# モジュール

モジュールは(他のモジュールからスコープの中へもたらされたリソースの) **インポート** の一式によって作成された環境の中の値やデータ型、型シノニム、クラスなど([４](./4-declarations-and-bindings.md)章を参照)の集まりを定義する。
これらのリソースのいくつかを **エクスポート** し、他のモジュールでそれらを利用できるようにする。
モジュールの中で定義された、またはその中へインポートされた、あるいはエクスポートされた値または型クラスに参照するために項の **エンティティ** を使用する。

Haskell **プログラム** はモジュールの集まりであり、その中の一つから規約により、`Main`が呼ばれなければならず、かつ`main`値をエクスポートしなければいけない。
プログラムの **値** はモジュール`Main`の中の識別子`main`の値であり、そしていくつかの型`τ`のための型`IO τ`の計算結果でなければいけない([７](./7-basic-input-output.md)章を参照)。
プログラムが実行されたとき、計算結果`main`は行わられ、(型`τ`の)その結果は捨てられる。

モジュールは明示的な`import`宣言により他のモジュールを参照することができ、
その各々でインポートされたモジュールの名前を与え、かつインポートされるためにそのエンティティを明記する。
モジュールは互いに再帰的にインポートされることもできる。

モジュールは名前空間の制御に使われ、かつファーストクラス値ではない。
複数のモジュールからなるHaskellのプログラムは、単一のモジュールのプログラムに、各エンティティに一意な名前を与え、その参照が出現する全ての場所を適切に一意な名前に変えて全てのモジュールの本体<sup><a href="#footnote-1">1</a></sup>の名前を連結することにより変換することができる。

例えば、ここに３つのモジュールプログラムがある。

```hs
module Main where  
	import A  
	import B  
	main = A.f >> B.f  

module A where  
	f = ...  

module B where  
	f = ... 
```

それは次の単一モジュールプログラムに等しい。

```hs
module Main where  
	main = af >> bf  

	af = ...  

	bf = ... 
```

なぜならそれらは互いに再帰的であることが許可され、モジュールはプログラムを依存の状態に注意することなく自由に分割することを許す。

モジュールの名前(語彙素<em>modid</em>)は大文字で始まり、ドットで区切られ、空白をはさまない一つ以上の識別子の列である。
例えば、`Data.Bool`と`Main`、`Foreign.Marshal.Alloc`はすべて有効なモジュール名である。

|||||
|--|--|--|--|
|<em>modid</em>|→|{<em>conid</em> .} <em>conid</em>|(modules)|

モジュール名は新しいコンポーネントを追加すると、元々のモジュール名の子を階層の中に作成し、その階層の中に配置されているように考えることができる。
例えば、モジュール`Contorl.Monad.ST`は`Contorl.Monad`下の階層の子である。
しかしこれは単なる慣習であり、言語の定義には含まれない。このリポートでは<em>modid</em>は平坦な名前空間を占有する単一の識別子のように扱われる。

中でも特別なモジュール Prelude が存在し、これはデフォルトで全てのモジュールにインポートされる(セクション[5.6](#標準Prelude))。
加えて、必要に応じてインポートされる標準ライブラリのモジュールの集合も特別である(Part[2](https://www.haskell.org/onlinereport/haskell2010/haskellpa2.html#x20-192000II)を参照)。

(訳注:上のリンク先であるPart2はHaskell2010のライブラリの部分でこのリポートの13章から42章までを指す。)

<a name="footnote-1"><sup>1</sup></a> この文に2つの小さな例外がある。
一つは、デフォルト宣言のスコープは単一のモジュール内のみに及ぶ(セクション[4.3.4](./4-declarations-and-bindings.md#曖昧な型とオーバーロードされた数値演算子の既定値))。
二つめは、単相性の制約のルール2がモジュールの境界によって影響を受ける。

