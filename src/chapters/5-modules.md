# モジュール

モジュールは(他のモジュールからスコープの中へもたらされたリソースの) **インポート** の一式によって作成された環境の中の値やデータ型、型シノニム、クラスなど([４](./4-declarations-and-bindings.md)章を参照)の集まりを定義する。
これらのリソースのいくつかを **エクスポート** し、他のモジュールでそれらを利用できるようにする。
モジュールの中で定義された、またはその中へインポートされた、あるいはエクスポートされた値または型クラスに参照するために項の **エンティティ** を使用する。

Haskell **プログラム** はモジュールの集まりであり、その中の一つから規約により、`Main`が呼ばれなければならず、かつ`main`値をエクスポートしなければいけない。
プログラムの **値** はモジュール`Main`の中の識別子`main`の値であり、そしていくつかの型`τ`のための型`IO τ`の計算結果でなければいけない([７](./7-basic-input-output.md)章を参照)。
プログラムが実行されたとき、計算結果`main`は行わられ、(型`τ`の)その結果は捨てられる。

モジュールは明示的な`import`宣言により他のモジュールを参照することができ、
その各々でインポートされたモジュールの名前を与え、かつインポートされるためにそのエンティティを明記する。
モジュールは互いに再帰的にインポートされることもできる。

モジュールは名前空間の制御に使われ、かつファーストクラス値ではない。
複数のモジュールからなるHaskellのプログラムは、単一のモジュールのプログラムに、各エンティティに一意な名前を与え、その参照が出現する全ての場所を適切に一意な名前に変えて全てのモジュールの本体<sup><a href="#footnote-1">1</a></sup>の名前を連結することにより変換することができる。

例えば、ここに３つのモジュールプログラムがある。

```hs
module Main where  
	import A  
	import B  
	main = A.f >> B.f  

module A where  
	f = ...  

module B where  
	f = ... 
```

それは次の単一モジュールプログラムに等しい。

```hs
module Main where  
	main = af >> bf  

	af = ...  

	bf = ... 
```

なぜならそれらは互いに再帰的であることが許可され、モジュールはプログラムを依存の状態に注意することなく自由に分割することを許す。

モジュールの名前(語彙素<em>modid</em>)は大文字で始まり、ドットで区切られ、空白をはさまない一つ以上の識別子の列である。
例えば、`Data.Bool`と`Main`、`Foreign.Marshal.Alloc`はすべて有効なモジュール名である。

|||||
|--|--|--|--|
|<em>modid</em>|→|{<em>conid</em> .} <em>conid</em>|(modules)|

モジュール名は新しいコンポーネントを追加すると、元々のモジュール名の子を階層の中に作成し、その階層の中に配置されているように考えることができる。
例えば、モジュール`Contorl.Monad.ST`は`Contorl.Monad`下の階層の子である。
しかしこれは単なる慣習であり、言語の定義には含まれない。このリポートでは<em>modid</em>は平坦な名前空間を占有する単一の識別子のように扱われる。

中でも特別なモジュール Prelude が存在し、これはデフォルトで全てのモジュールにインポートされる(セクション[5.6](#標準Prelude))。
加えて、必要に応じてインポートされる標準ライブラリのモジュールの集合も特別である(Part[2](https://www.haskell.org/onlinereport/haskell2010/haskellpa2.html#x20-192000II)を参照)。

(訳注:上のリンク先であるPart2はHaskell2010のライブラリの部分でこのリポートの13章から42章までを指す。)

<a name="footnote-1"><sup>1</sup></a> この文に2つの小さな例外がある。
一つは、デフォルト宣言のスコープは単一のモジュール内のみに及ぶ(セクション[4.3.4](./4-declarations-and-bindings.md#曖昧な型とオーバーロードされた数値演算子の既定値))。
二つめは、単相性の制約のルール2がモジュールの境界によって影響を受ける。

## モジュールの構造

モジュールは値束縛やデータ型、型シノニム、クラスなどへの宣言を含む相互再帰的なスコープを定義する([4](./4-declarations-and-bindings.md)章を参照)。

|||||
|--|--|--|--|
|<em>module</em> |→|`module` <em>modid</em> [<em>exports</em>] `where` <em>body</em>| |
|			|&#124;|<em>body</em>| |
|<em>body</em>	 |→|{ <em>impdecls</em> ; <em>topdecls</em> }| |
|			|&#124;|{ <em>impdecls</em> }| |
|			|&#124;|{ <em>topdecls</em> }| |
| | | | |
|<em>impdecls</em> |→|<em>impdecl<sub>1</sub></em> ; … ; <em>impdecl<sub>n</sub></em>|(<em>n</em> ≥ 1)|
|<em>topdecls</em> |→|<em>topdecl<sub>1</sub></em> ; … ; <em>topdecl<sub>n</sub></em>|(<em>n</em> ≥ 1)|

モジュールは`module`キーワードとその名前、エクスポートされる(丸括弧で囲まれた)エンティティのリストをヘッダーに伴って始まる。
そのヘッダーの次にはインポートされるモジュールを明記する空かもしれない`import`宣言(`impdecls`、セクション[5.3](#インポート宣言))のリストが続き、
必要に応じてインポートされる束縛を制限する。
これには空かもしれないトップレベルの宣言のリストが次に続くであろう(`topdecls`、[4](./4-declarations-and-bindings.md)章)。

モジュールの本体のみで成るモジュールの短縮形式は許される。
もしこれが使われるなら、そのヘッダーは`‘module Main(main) where’`であると推測される。
もし短縮されたモジュールの初めの語彙素が`{`でなければ、そのときそのレイアウトルールはそのモジュールのトップレベルへ適用される。

## エクスポートリスト

|||||
|--|--|--|--|
| <em>exports</em>|→| ( <em>export<sub>1</sub></em> , … , <em>export<sub>n</sub></em> [ , ] )         | (<em>n</em> ≥ 0)|
| | | | |
|  <em>export</em>|→| <em>qvar</em>| |
|	|&#124;| <em>qtycon</em> [(..) &#124; ( <em>cname<sub>1</sub></em> , … , <em>cname<sub>n</sub></em> )] | (<em>n</em> ≥ 0)|
|	|&#124;| <em>qtycls</em> [(..) &#124; ( <em>var<sub>1</sub></em> , … , <em>var<sub>n</sub></em> )]     | (<em>n</em> ≥ 0)|
|	|&#124;| `module` <em>modid</em> | |
| | | | |
|   <em>cname</em>|→| <em>var</em> &#124; <em>con</em> | |

**エクスポートリスト**はモジュール宣言によってエクスポートされるエンティティを識別する。
モジュールの実装は宣言する、またはいくつかの他のモジュールからインポートするエンティティのみをエクスポートできる。
もしエクスポートリストが省略されるなら、モジュールの中で定義されたすべての値や型、クラスはインポートされるものを除いてエクスポートされる。

エクスポートリストのエンティティは次に従って名付けられる。

1. 値またはフィールド名、クラスメソッドはモジュールの本体またはインポートされたものの中で宣言されたかどうかは別にして、
   `qvarid`のように値の名前を与えることによって名付けられることができ、そしてそれはスコープ内でなければならない。
   演算子はそれらを`qvarids`に変えるために丸括弧で閉じられなければならない。
2. `data`または`newtype`宣言で宣言された代数データ型<em>T</em>は次の3つの方法の一つで名付けられることができる。
   - 形式<em>T</em>は **コンストラクタまたはフィールド名を除いて** 型を名付ける。
     そのコンストラクタなしに型をエクスポートできることは抽象データ型のコンストラクタを許す(セクション[5.8](#抽象データ型))。
   - 形式<em>T(c<sub>1</sub>,...,c<sub>n</sub>)</em>は型とそのコンストラクタとフィールド名の複数または全てを名付ける。
   - 略された形式<em>T(..)</em>は(修飾されたかされていないかのどちらにしろ)現在のスコープにある型と全てのそのコンストラクタとフィールド名を名付ける。
   
   全てのケースにおいて(修飾されているかもしれない)型コンストラクタ<em>T</em>はスコープになければならない。
   2番目の形式の中の<em>c<sub>i</sub></em>を名付けるそのコンストラクタとフィールドは修飾されない。
   これらの付随する名前の一つは次の場合にのみ正当である。
   (a) <em>T</em>のコンストラクタまたはフィールドを名付ける。かつ、
   (b) コンストラクタまたはフィールドが **修飾されるかされない名前の下のスコープ内にあるかどうかにかかわらず** モジュール本体のスコープ内にある。
   例えば、次のコードは正当である。

   ```hs
   module A( Mb.Maybe( Nothing, Just ) ) where  
   import qualified Data.Maybe as Mb 
   ```

   データコンストラクタは付随する名前のようなものを除いてエクスポートリストの中で名付けることはできない。
   なぜならそうでなければ型コンストラクタから見分けられないからだ。
3. `data`宣言によって宣言される型シノニム<em>T</em>は形式<em>T</em>によって名付けられることができ、<em>T</em>はスコープ内にある。
4. `class`宣言で宣言される演算<em>f<em>1</em>,...,f<em>n</em>を伴う</em>クラス<em>C</em>は次の3つの方法のひとつから名付けられる。
   - 形式<em>C</em>は **クラスメソッドを除いて** クラスを名付ける。
   - 形式<em>C(f<sub>1</sub>,...,f<sub>n</sub>)</em>はクラスとそのメソッドのいくつかまたは全てを名付ける。
   - 略された形式<em>C(..)</em>は(修飾されるされないか関係なく)スコープにあるクラスとその全てのメソッドを名付ける。
   
   全てのケースにおいて、<em>C</em>はスコープになければならない。
   2番目の形式の中で、(修飾されない)付随する名前<em>f<sub>i</sub></em>のひとつは次の場合にのみ正当である。
   (a) <em>C</em>のクラスメソッドを名付ける。かつ
   (b) そのクラスメソッドが修飾されるされない名前の下のスコープ内にあるかどうかにかかわらずモジュール本体のスコープ内にある。
5. 形式`module M`は修飾されない名前`"e"`と修飾される名前`"M.e"`の両方を伴うスコープ内にある全エンティティのセットを名付ける。
   このセットは空でもよい。
   例えば、
   ```hs
   module Queue( module Stack, enqueue, dequeue ) where  
       import Stack  
       ... 
   ```

   ここのモジュール`Queue`は`Stack`からインポートされた全エンティティを省力するためそのエクスポートリスト内のモジュール名`Stack`を使う。
   モジュールは構文`"module M"`内のそれが保有する名前を使うエクスポートリストの中で保有するローカルな定義を名付けることができる、
   なぜなら、ローカル宣言は修飾されるされない名前の両方をスコープの中へもたらす(セクション[5.5.1](#修飾された名前))。
   例えば、
   ```hs
   module Mod1( module Mod1, module Mod2 ) where  
   import Mod2  
   import Mod3 
   ```
   ここのモジュール`Mod1`は`Mod2`からインポートされたそれらと同様に全てのローカル定義をエクスポートするが、`Mod3`からインポートされたものは異なる。

   `M`がエクスポートリストを与えるモジュールであるまたは`M`が少なくとも1つのインポート宣言(修飾されるまたはされない)によってインポートされるにもかかわらずエクスポートリスト内で`module M`を使うことはエラーである。

エクスポートリストは累積される。
そして、エクスポートリストによってエクスポートされるエンティティのセットはリストの個々のアイテムによってエクスポートされたエンティティの和集合である。

それはどのようにエンティティをエクスポートされてもインポートするモジュールに差がないようにする。
例えば、データ型`T`からフィールド名`f`は個々に(`f`、上記のアイテム(1))、
またはそのデータ型(`T(f)、アイテム(2)`)の明示的に名付けられたメンバーのように、
または暗黙的に名付けられたメンバー(`T(..)、アイテム(2)`)のように、
またはエンティティモジュール(`module M`、アイテム(5))をエクスポートすることによってエクスポートされることができる。

モジュールによってエクスポートされたエンティティの **修飾される** 名前は(それら各々の名前空間の範囲で)全て明確でなければならない。
例えば、

```hs
module A ( C.f, C.g, g, module B ) where   -- an invalid module  
import B(f)  
import qualified C(f,g)  
g = f True
```

モジュールAそれ自身の範囲で衝突する名前はないが、
`C.g`と`g`の間(`C.g`と`g`は異なる実体であると仮定し、心に留めてほしいが、モジュールは再帰的に互いにインポートできる。)と
`module B`と`C.f`の間(`B.f`と`C.f`は異なる実体であると仮定する)にエクスポートリスト内で衝突する名前がある。

