# モジュール

モジュールは(他のモジュールからスコープの中へもたらされたリソースの) **インポート** の一式によって作成された環境の中の値やデータ型、型シノニム、クラスなど([４](./4-declarations-and-bindings.md)章を参照)の収集物を定義する。
これらのリソースのいくつかを **エクスポート** し、他のモジュールでそれらを利用できるようにする。
モジュールの中で定義された、またはその中へインポートされた、あるいはエクスポートされた値または型クラスに参照するために項の**実体**を使用する。

Haskell **プログラム** はモジュールの集まりであり、その中の一つから規約により、`Main`が呼ばれなければならず、かつ`main`値をエクスポートしなければいけない。
プログラムの **値** はモジュール`Main`の中の識別子`main`の値であり、そしていくつかの型`τ`のための型`IO τ`の計算結果でなければいけない([７](./7-basic-input-output.md)章を参照)。
プログラムが実行されたとき、計算結果`main`は行わられ、(型`τ`の)その結果は捨てられる。

モジュールは明示的な`import`宣言により他のモジュールを参照することができ、
その各々でインポートされたモジュールの名前を与え、かつインポートされるためにその実体を明記する。
モジュールは互いに再帰的にインポートされることもできる。

モジュールは名前空間の制御に使われ、かつファーストクラス値ではない。
複数のモジュールのHaskellプログラムは各実体の特有の名前を与え、適切な特有の名前に参照するために全出現を変更し、その時すべてのモジュールの実体<span class="overline"><a href="https://www.haskell.org/onlinereport/haskell2010/haskell12.html">1</a></span>を連結することによって単一のモジュールプログラムに変換されることが可能だ。
例えば、ここに３つのモジュールプログラムがある。

```hs
module Main where  
	import A  
	import B  
	main = A.f >> B.f  

module A where  
	f = ...  

module B where  
	f = ... 
```

それは次の単一モジュールプログラムに等しい。

```hs
module Main where  
	main = af >> bf  

	af = ...  

	bf = ... 
```

なぜならそれらは互いに再帰的であることが許可され、モジュールはプログラムを依存の状態に注意することなく自由に分割することを許す。

モジュールの名前(語彙素<em>modid</em>)は大文字で始まり、ドットで区切られ、空白をはさまない一つ以上の識別子の列である。
例えば、`Data.Bool`と`Main`、`Foreign.Marshal.Alloc`はすべて有効なモジュール名である。

|||||
|--|--|--|--|
|<em>modid</em>|→|{<em>conid</em> .} <em>conid</em>|(modules)|

モジュール名は新しいコンポーネントを追加すると、元々のモジュール名の子を階層の中に作成し、その階層の中に配置されているように考えることができる。
例えば、モジュール`Contorl.Monad.ST`は`Contorl.Monad`下の階層の子である。
これは単なる規約であるが、しかしながら言語定義の部分ではなく、このリポートでは<em>modid</em>は平坦な名前空間を占有する単一の識別子のように扱われる。

ひとつの有名なモジュール`Prelude`があり、要求されたものとしてインポートされるであろう標準ライブラリモジュールのひと組を加えて(Part[2](https://www.haskell.org/onlinereport/haskell2010/haskellpa2.html#x20-192000II)を参照)、デフォルトですべてのモジュールの中へインポートされる(セクション[5.6](#a標準Prelude))。

(訳注:上のリンク先であるPart2はHaskell2010のライブラリの部分でこのリポートの13章から42章までを指す。)

