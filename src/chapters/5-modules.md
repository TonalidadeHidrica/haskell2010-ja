# モジュール

モジュールは(他のモジュールからスコープの中へもたらされたリソースの) **インポート** の一式によって作成された環境の中の値やデータ型、型シノニム、クラスなど([４](./4-declarations-and-bindings.md)章を参照)の集まりを定義する。
これらのリソースのいくつかを **エクスポート** し、他のモジュールでそれらを利用できるようにする。
モジュールの中で定義された、またはその中へインポートされた、あるいはエクスポートされた値または型クラスに参照するために項の **エンティティ** を使用する。

Haskell **プログラム** はモジュールの集まりであり、その中の一つから規約により、`Main`が呼ばれなければならず、かつ`main`値をエクスポートしなければいけない。
プログラムの **値** はモジュール`Main`の中の識別子`main`の値であり、そしていくつかの型`τ`のための型`IO τ`の計算結果でなければいけない([７](./7-basic-input-output.md)章を参照)。
プログラムが実行されたとき、計算結果`main`は行わられ、(型`τ`の)その結果は捨てられる。

モジュールは明示的な`import`宣言により他のモジュールを参照することができ、
その各々でインポートされたモジュールの名前を与え、かつインポートされるためにそのエンティティを明記する。
モジュールは互いに再帰的にインポートされることもできる。

モジュールは名前空間の制御に使われ、かつファーストクラス値ではない。
複数のモジュールからなるHaskellのプログラムは、単一のモジュールのプログラムに、各エンティティに一意な名前を与え、その参照が出現する全ての場所を適切に一意な名前に変えて全てのモジュールの本体<sup><a href="#footnote-1">1</a></sup>の名前を連結することにより変換することができる。

例えば、ここに３つのモジュールプログラムがある。

```hs
module Main where  
	import A  
	import B  
	main = A.f >> B.f  

module A where  
	f = ...  

module B where  
	f = ... 
```

それは次の単一モジュールプログラムに等しい。

```hs
module Main where  
	main = af >> bf  

	af = ...  

	bf = ... 
```

なぜならそれらは互いに再帰的であることが許可され、モジュールはプログラムを依存の状態に注意することなく自由に分割することを許す。

モジュールの名前(語彙素<em>modid</em>)は大文字で始まり、ドットで区切られ、空白をはさまない一つ以上の識別子の列である。
例えば、`Data.Bool`と`Main`、`Foreign.Marshal.Alloc`はすべて有効なモジュール名である。

|||||
|--|--|--|--|
|<em>modid</em>|→|{<em>conid</em> .} <em>conid</em>|(modules)|

モジュール名は新しいコンポーネントを追加すると、元々のモジュール名の子を階層の中に作成し、その階層の中に配置されているように考えることができる。
例えば、モジュール`Contorl.Monad.ST`は`Contorl.Monad`下の階層の子である。
しかしこれは単なる慣習であり、言語の定義には含まれない。このリポートでは<em>modid</em>は平坦な名前空間を占有する単一の識別子のように扱われる。

中でも特別なモジュール Prelude が存在し、これはデフォルトで全てのモジュールにインポートされる(セクション[5.6](#標準Prelude))。
加えて、必要に応じてインポートされる標準ライブラリのモジュールの集合も特別である(Part[2](https://www.haskell.org/onlinereport/haskell2010/haskellpa2.html#x20-192000II)を参照)。

(訳注:上のリンク先であるPart2はHaskell2010のライブラリの部分でこのリポートの13章から42章までを指す。)

<a name="footnote-1"><sup>1</sup></a> この文に2つの小さな例外がある。
一つは、デフォルト宣言のスコープは単一のモジュール内のみに及ぶ(セクション[4.3.4](./4-declarations-and-bindings.md#曖昧な型とオーバーロードされた数値演算子の既定値))。
二つめは、単相性の制約のルール2がモジュールの境界によって影響を受ける。

## モジュールの構造

モジュールは値束縛やデータ型、型シノニム、クラスなどへの宣言を含む相互再帰的なスコープを定義する([4](./4-declarations-and-bindings.md)章を参照)。

|||||
|--|--|--|--|
|<em>module</em> |→|`module` <em>modid</em> [<em>exports</em>] `where` <em>body</em>| |
|			|&#124;|<em>body</em>| |
|<em>body</em>	 |→|{ <em>impdecls</em> ; <em>topdecls</em> }| |
|			|&#124;|{ <em>impdecls</em> }| |
|			|&#124;|{ <em>topdecls</em> }| |
| | | | |
|<em>impdecls</em> |→|<em>impdecl<sub>1</sub></em> ; … ; <em>impdecl<sub>n</sub></em>|(<em>n</em> ≥ 1)|
|<em>topdecls</em> |→|<em>topdecl<sub>1</sub></em> ; … ; <em>topdecl<sub>n</sub></em>|(<em>n</em> ≥ 1)|

モジュールは`module`キーワードとその名前、エクスポートされる(丸括弧で囲まれた)エンティティのリストをヘッダーに伴って始まる。
そのヘッダーの次にはインポートされるモジュールを明記する空かもしれない`import`宣言(`impdecls`、セクション[5.3](#インポート宣言))のリストが続き、
必要に応じてインポートされる束縛を制限する。
これには空かもしれないトップレベルの宣言のリストが次に続くであろう(`topdecls`、[4](./4-declarations-and-bindings.md)章)。

モジュールの本体のみで成るモジュールの短縮形式は許される。
もしこれが使われるなら、そのヘッダーは`‘module Main(main) where’`であると推測される。
もし短縮されたモジュールの初めの語彙素が`{`でなければ、そのときそのレイアウトルールはそのモジュールのトップレベルへ適用される。

## エクスポートリスト

|||||
|--|--|--|--|
| <em>exports</em>|→| ( <em>export<sub>1</sub></em> , … , <em>export<sub>n</sub></em> [ , ] )         | (<em>n</em> ≥ 0)|
| | | | |
|  <em>export</em>|→| <em>qvar</em>| |
|	|&#124;| <em>qtycon</em> [(..) &#124; ( <em>cname<sub>1</sub></em> , … , <em>cname<sub>n</sub></em> )] | (<em>n</em> ≥ 0)|
|	|&#124;| <em>qtycls</em> [(..) &#124; ( <em>var<sub>1</sub></em> , … , <em>var<sub>n</sub></em> )]     | (<em>n</em> ≥ 0)|
|	|&#124;| `module` <em>modid</em> | |
| | | | |
|   <em>cname</em>|→| <em>var</em> &#124; <em>con</em> | |

**エクスポートリスト**はモジュール宣言によってエクスポートされるエンティティを識別する。
モジュールの実装はそのモジュールで宣言しているまたは他のモジュールからインポートしているエンティティのみをエクスポートできる。
もしエクスポートリストが省略されるなら、モジュールの中で定義されたすべての値や型、クラスはインポートされるものを除いてエクスポートされる。

エクスポートリストのエンティティは次に従う名前である。

1. 値、フィールド名またはクラスメソッドはそれらがモジュールの本体またはインポートによって宣言されたものかどうかにかかわらず、
   `qvarid`のように値の名前を与えることによって名前をつけることができ、そしてそれはスコープ内でなければならない。
   演算子はそれらを`qvarids`に変えるために丸括弧で閉じられなければならない。
2. `data`または`newtype`宣言で宣言された代数データ型<em>T</em>は次の3つの方法の一つで名前をつけることができる。
   - 形式<em>T</em>は **コンストラクタまたはフィールド名によってではなく**、 型によって名前がつけられる。
     コンストラクタなしに型をエクスポート出来るという仕様は、抽象データ型のコンストラクタについても同様である(セクション[5.8](#抽象データ型))。
   - 形式<em>T(c<sub>1</sub>,...,c<sub>n</sub>)</em>は型とそのコンストラクタとフィールド名の複数または全ての名前である。
   - 略された形式<em>T(..)</em>は(修飾されたかされていないかのどちらにしろ)現在のスコープにある型と全てのそのコンストラクタとフィールド名の名前である。
   
   全てのケースにおいて(修飾されているかもしれない)型コンストラクタ<em>T</em>はスコープになければならない。
   2番目の形式の中の<em>c<sub>i</sub></em>の名前であるそのコンストラクタとフィールドは修飾されない。
   これらの付随する名前の一つは次の場合にのみ正当である。
   (a) <em>T</em>のコンストラクタまたはフィールドの名前である。かつ、
   (b) コンストラクタまたはフィールドが **修飾されるかされない名前の下のスコープ内にあるかどうかにかかわらず** モジュール本体のスコープ内にある。
   例えば、次のコードは正当である。

   ```hs
   module A( Mb.Maybe( Nothing, Just ) ) where  
   import qualified Data.Maybe as Mb 
   ```

   データコンストラクタは付随する名前のようなものを除いてエクスポートリストの中で名前をつけることはできない。
   なぜならそうでなければ型コンストラクタから見分けられないからだ。
3. `data`宣言によって宣言される型シノニム<em>T</em>は形式<em>T</em>によって名前をつけられることができ、<em>T</em>はスコープ内にある。
4. `class`宣言で宣言される演算<em>f<em>1</em>,...,f<em>n</em>を伴う</em>クラス<em>C</em>は次の3つの方法のひとつから名前をつけることができる。
   - 形式<em>C</em>は **クラスメソッドを除いて** クラスの名前である。
   - 形式<em>C(f<sub>1</sub>,...,f<sub>n</sub>)</em>はクラスとそのメソッドのいくつかまたは全ての名前である。
   - 略された形式<em>C(..)</em>は(修飾されるされないか関係なく)スコープにあるクラスとその全てのメソッドの名前である。
   
   全てのケースにおいて、<em>C</em>はスコープになければならない。
   2番目の形式の中で、(修飾されない)付随する名前<em>f<sub>i</sub></em>のひとつは次の場合にのみ正当である。
   (a) <em>C</em>のクラスメソッドの名前である。かつ
   (b) そのクラスメソッドが修飾されるされない名前の下のスコープ内にあるかどうかにかかわらずモジュール本体のスコープ内にある。
5. 形式`module M`は修飾されない名前`"e"`と修飾される名前`"M.e"`の両方を伴うスコープ内にある全エンティティのセットの名前である。
   このセットは空でもよい。
   例えば、
   ```hs
   module Queue( module Stack, enqueue, dequeue ) where  
       import Stack  
       ... 
   ```

   ここのモジュール`Queue`は`Stack`からインポートされた全エンティティを略して書くためそのエクスポートリスト内のモジュール名`Stack`を使う。
   モジュールは構文`"module M"`内のそれが保有する名前を使うエクスポートリストの中で保有するローカルな定義の名前をつけることができる、
   なぜなら、ローカル宣言は修飾されるされない名前の両方をスコープの中へもたらす(セクション[5.5.1](#修飾された名前))。
   例えば、
   ```hs
   module Mod1( module Mod1, module Mod2 ) where  
   import Mod2  
   import Mod3 
   ```
   ここのモジュール`Mod1`は`Mod2`からインポートされたそれらと同様に全てのローカル定義をエクスポートするが、`Mod3`からインポートされたものは異なる。

   `M`がエクスポートリストをもつモジュールでない限り、または少なくとも1つのインポート宣言によって(修飾されるかどうかにかかわらず)インポートされたモジュールでない限り、`module M`をエクスポートリストで使うことはエラーとなる。

エクスポートリストは累積される。
すなわち、エクスポートリストによってエクスポートされるエンティティのセットはリストの個々のアイテムによってエクスポートされたエンティティの和集合である。

エンティティがどのようにエクスポートされているものであっても、インポートしているモジュールには違いがない。
例えば、データ型`T`からフィールド名`f`は個々に(`f`、上記のアイテム(1))エクスポートしてよい。
あるいはそのデータ型(`T(f)、アイテム(2)`)の明示的に名前をつけられたメンバーのようにしても、
あるいは暗黙的に名前をつけられたメンバー(`T(..)、アイテム(2)`)のようにしても、
モジュール本体(`module M`、アイテム(5))をエクスポートすることによっても、同様にエクスポートしてもよい。

モジュールによってエクスポートされたエンティティの **修飾される** 名前は(それら各々の名前空間の範囲で)全て異ならなければならない。
例えば、

```hs
module A ( C.f, C.g, g, module B ) where   -- an invalid module  
import B(f)  
import qualified C(f,g)  
g = f True
```

モジュールAそれ自身の範囲で衝突する名前はないが、
`C.g`と`g`の間(`C.g`と`g`は異なる実体であると仮定する。モジュールは相互再帰的にインポートできることを思い出してほしい。)と
`module B`と`C.f`の間(`B.f`と`C.f`は異なる実体であると仮定する)にエクスポートリスト内で衝突する名前がある。

## インポート宣言

|||||
|--|--|--|--|
|  <em>impdecl</em>|→|`import` [`qualified`] <em>modid</em> [`as` <em>modid</em>] [<em>impspec</em>]| |
|	  |&#124;|                                             |(<em>empty declaration</em>)|
|  <em>impspec</em>|→|( <em>import<sub>1</sub></em> , … , <em>import<sub>n</sub></em> [ , ] )|(<em>n</em> ≥ 0)|
|	  |&#124;|`hiding` ( <em>import<sub>1</sub></em> , … , <em>import<sub>n</sub></em> [ , ] )|(<em>n</em> ≥ 0)|
| | | | |
|   <em>import</em>|→|<em>var</em>| |
|	  |&#124;| <em>tycon</em> [ `(..)` &#124; ( <em>cname<sub>1</sub></em> , … , <em>cname<sub>n</sub></em> )]|(<em>n</em> ≥ 0)|
|	  |&#124;|	<em>tycls</em> [`(..)` &#124; ( <em>var<sub>1</sub></em> , … , <em>var<sub>n</sub></em> )]|(<em>n</em> ≥ 0)|
|    <em>cname</em>|→|<em>var</em> &#124; <em>con</em> | |

モジュールによってエクスポートされたエンティティはモジュールのはじめの`import`宣言を伴って他のモジュールのスコープの中へもたらされる。
`import`宣言はインポートされるモジュールの名前をつけ、任意でインポートされるエンティティを明示する。
単一モジュールは一つ以上の`import`宣言によってインポートされるかもしれない。
インポートされた名前はトップレベルの宣言のように扱い、
そしてそのモジュールの全実体上が有効範囲であるが、ローカルのトップレベルではない束縛によって覆われる。

複数の`import`宣言の効果は厳密に累積し、
もしモジュール内の`import`宣言のいずれかでインポートされるなら、エンティティはスコープ内にある。
インポート宣言の順序は無意味である。

語彙的に、終端期号`"as"`や`"qualified"`、`"hiding"`はそれぞれ<em>reservedid</em>ではなく<em>varid</em>である。
それらは`import`宣言の文脈内でのみ特別な意味を持ち、変数のようにも使われることが出来る。

### インポートされるとは何か

正確にどのエンティティがインポートされるかは次に3つの方法の一つで明示されることが出来る。

1. インポートされるエンティティは丸括弧の中のリスト化しているものによってはっきりと明示されることが出来る。
    そのリストの中のアイテムは修飾子が許可されないことと`module <em>modid</em>`エンティティが許可されないことを除いてエクスポートリスト内のものと同様に同じ形式を持つ。
    インポートの形式`(..)`が型またはクラスで使われるとき、`(..)`はモジュールからエクスポートされるコンストラクタまたはメソッド、フィールド名の全てを参照する。

    そのリストはインポートされるモジュールによってエクスポートされるエンティティのみに名前をつけないといけない。
    リストは空でもよく、その場合はインスタンス以外はインポートされない。

2. エンティティは形式`hiding`(<em>inport<sub>1</sub>, ..., import<sub>n</sub></em>)を使うことによって除外されることができる。
   そして名前がつけられたモジュールによってエクスポートされる全エンティティはリスト内で名前を付けられたものを除いてインポートされるべきことを明示する。
   データコンストラクタは関連する型で接頭辞をつけられることなく隠れているリスト内で直接名前をつけることが出来る。
   例えば、

   ```hs
   import M hiding (C)
   ```

   `C`と名前を付けられるあらゆるコンストラクタまたはクラス、型は除外される。
   対象的にインポートリスト内で`C`を使うことはクラスまたは型のみに名前をつける。

   インポートされたモジュールによって実際にエクスポートされないエンティティを隠すことはエラーである。

3. 最後にもし<em>impspec</em>は省かれるなら、そのとき明示されたモジュールによってエクスポートされるエンティティはインポートされる。
   
### 修飾されるインポート

セクション[5.3.1](#インポートされるとは何か)のルールの下で各エンティティのために、トップレベルの環境は拡張される。
もしインポート宣言が`qualified`キーワードを使っていたなら、エンティティの**修飾された名前**のみがスコープ内へともたらされる。
もし`qualified`キーワードが省略されているなら、そのときエンティティの修飾される名前 **と** 修飾されない名前の **両者**はスコープの中へともたらされる。
セクション[5.5.1]()では修飾される名前のより詳細を述べていく。

インポートされる名前の修飾子はインポートされるモジュールの名前か`import`文の`as`句に与えられるローカルな別名のどちらかである。
このゆえに、**修飾子はエンティティが最初に宣言される中でモジュールの名前を必要としない。**

修飾されない名前を除外するための機能は修飾されない名前空間のプログラマによる完全な制御を許し、
ローカルで定義されたエンティティは修飾されるインポートのように同じ名前を共有可能である。

```hs
module Ring where  
import qualified Prelude    -- All Prelude names must be qualified  
import Data.List( nub )  

l1 + l2 = l1 Prelude.++ l2  -- This + differs from the one in the Prelude  
l1 ⋆ l2 = nub (l1 + l2)     -- This ⋆ differs from the one in the Prelude  

succ = (Prelude.+ 1)
```

### ローカルな別名

インポートされるモジュールは`as`句を使いインポートするモジュールの中でローカルな別名を割り当てられることができる。
例えば、次の

```hs
import qualified VeryLongModuleName as C
```

エンティティの中は<code>`VeryLongModuleName.`</code>の代わりの修飾子と同様に使用する<code>`C.`</code>を参照されないといけない。
これはインポートされるモジュールで使われる修飾子を変更せずに異なるモジュールを`VeryLongModuleName`の代わりにされることも許す。
それは同じ修飾子を使用するスコープ内の一つ以上のモジュールにとって正当であり、
全ての名前が明白にまだ解決されることが可能であることに提供される。
例えば、

```hs
module M where  
    import qualified Foo as A  
    import qualified Baz as A  
    x = A.f 
```

このモジュールは`Foo`と`Baz`が両方共`f`をエクスポートしないときのみに正当に提供される。

`as`句は`qualifiedimport`ではない式でも使われることができる。

```hs
import Foo as A(f)
```

この宣言は`f`と`A.f`をスコープの中にもたらす。

### 例

上記のインポートルールを明らかにするため、`x`と`y`をエクスポートするモジュール`A`を想定してほしい。
そのときこの表は名前が明記されたインポート式によってスコープの中へもたらされることを示す。

|インポート宣言|スコープの中にもたらされる名前|
|--|--|
|import A                       | x, y, A.x, A.y |
|import A()                     | (nothing) |
|import A(x)                    |	x, A.x |
|import qualified A             | A.x, A.y | 
|import qualified A()           | (nothing) |
|import qualified A(x)          | A.x |
|import A hiding ()             | x, y, A.x, A.y |
|import A hiding (x)            | y, A.y |
|import qualified A hiding ()   | A.x, A.y |
|import qualified A hiding (x)  | A.y | 
|import A as B                  | x, y, B.x, B.y |
|import A as B(x)               | x, B.x | 
|import qualified A as B        | B.x, B.y |

全てのケースで、モジュール`A`のスコープの中の全インスタンス宣言はインポートされる(セクション[5.4]())。

