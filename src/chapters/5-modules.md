# モジュール

モジュールは(他のモジュールからスコープの中へもたらされたリソースの) **インポート** の一式によって作成された環境の中の値やデータ型、型シノニム、クラスなど([４](./4-declarations-and-bindings.md)章を参照)の集まりを定義する。
これらのリソースのいくつかを **エクスポート** し、他のモジュールでそれらを利用できるようにする。
モジュールの中で定義された、またはその中へインポートされた、あるいはエクスポートされた値または型クラスに参照するために項の **エンティティ** を使用する。

Haskell **プログラム** はモジュールの集まりであり、その中の一つから規約により、`Main`が呼ばれなければならず、かつ`main`値をエクスポートしなければいけない。
プログラムの **値** はモジュール`Main`の中の識別子`main`の値であり、そしていくつかの型`τ`のための型`IO τ`の計算結果でなければいけない([７](./7-basic-input-output.md)章を参照)。
プログラムが実行されたとき、計算結果`main`は行わられ、(型`τ`の)その結果は捨てられる。

モジュールは明示的な`import`宣言により他のモジュールを参照することができ、
その各々でインポートされたモジュールの名前を与え、かつインポートされるためにそのエンティティを明記する。
モジュールは互いに再帰的にインポートされることもできる。

モジュールは名前空間の制御に使われ、かつファーストクラス値ではない。
複数のモジュールからなるHaskellのプログラムは、単一のモジュールのプログラムに、各エンティティに一意な名前を与え、その参照が出現する全ての場所を適切に一意な名前に変えて全てのモジュールの本体<sup><a href="#footnote-1">1</a></sup>の名前を連結することにより変換することができる。

例えば、ここに３つのモジュールプログラムがある。

```hs
module Main where  
	import A  
	import B  
	main = A.f >> B.f  

module A where  
	f = ...  

module B where  
	f = ... 
```

それは次の単一モジュールプログラムに等しい。

```hs
module Main where  
	main = af >> bf  

	af = ...  

	bf = ... 
```

なぜならそれらは互いに再帰的であることが許可され、モジュールはプログラムを依存の状態に注意することなく自由に分割することを許す。

モジュールの名前(語彙素<em>modid</em>)は大文字で始まり、ドットで区切られ、空白をはさまない一つ以上の識別子の列である。
例えば、`Data.Bool`と`Main`、`Foreign.Marshal.Alloc`はすべて有効なモジュール名である。

|||||
|--|--|--|--|
|<em>modid</em>|→|{<em>conid</em> .} <em>conid</em>|(modules)|

モジュール名は新しいコンポーネントを追加すると、元々のモジュール名の子を階層の中に作成し、その階層の中に配置されているように考えることができる。
例えば、モジュール`Contorl.Monad.ST`は`Contorl.Monad`下の階層の子である。
しかしこれは単なる慣習であり、言語の定義には含まれない。このリポートでは<em>modid</em>は平坦な名前空間を占有する単一の識別子のように扱われる。

中でも特別なモジュール Prelude が存在し、これはデフォルトで全てのモジュールにインポートされる(セクション[5.6](#標準Prelude))。
加えて、必要に応じてインポートされる標準ライブラリのモジュールの集合も特別である(Part[2](https://www.haskell.org/onlinereport/haskell2010/haskellpa2.html#x20-192000II)を参照)。

(訳注:上のリンク先であるPart2はHaskell2010のライブラリの部分でこのリポートの13章から42章までを指す。)

<a name="footnote-1"><sup>1</sup></a> この文に2つの小さな例外がある。
一つは、デフォルト宣言のスコープは単一のモジュール内のみに及ぶ(セクション[4.3.4](./4-declarations-and-bindings.md#曖昧な型とオーバーロードされた数値演算子の既定値))。
二つめは、単相性の制約のルール2がモジュールの境界によって影響を受ける。

## モジュールの構造

モジュールは値束縛やデータ型、型シノニム、クラスなどへの宣言を含む相互再帰的なスコープを定義する([4](./4-declarations-and-bindings.md)章を参照)。

|||||
|--|--|--|--|
|<em>module</em> |→|`module` <em>modid</em> [<em>exports</em>] `where` <em>body</em>| |
|			|&#124;|<em>body</em>| |
|<em>body</em>	 |→|{ <em>impdecls</em> ; <em>topdecls</em> }| |
|			|&#124;|{ <em>impdecls</em> }| |
|			|&#124;|{ <em>topdecls</em> }| |
| | | | |
|<em>impdecls</em> |→|<em>impdecl<sub>1</sub></em> ; … ; <em>impdecl<sub>n</sub></em>|(<em>n</em> ≥ 1)|
|<em>topdecls</em> |→|<em>topdecl<sub>1</sub></em> ; … ; <em>topdecl<sub>n</sub></em>|(<em>n</em> ≥ 1)|

モジュールは`module`キーワードとその名前、エクスポートされる(丸括弧で囲まれた)エンティティのリストをヘッダーに伴って始まる。
そのヘッダーの次にはインポートされるモジュールを明記する空かもしれない`import`宣言(`impdecls`、セクション[5.3](#インポート宣言))のリストが続き、
必要に応じてインポートされる束縛を制限する。
これには空かもしれないトップレベルの宣言のリストが次に続くであろう(`topdecls`、[4](./4-declarations-and-bindings.md)章)。

モジュールの本体のみで成るモジュールの短縮形式は許される。
もしこれが使われるなら、そのヘッダーは`‘module Main(main) where’`であると推測される。
もし短縮されたモジュールの初めの語彙素が`{`でなければ、そのときそのレイアウトルールはそのモジュールのトップレベルへ適用される。

## インポート宣言

|||||
|--|--|--|--|
|  <em>impdecl</em>|→|`import` [`qualified`] <em>modid</em> [`as` <em>modid</em>] [<em>impspec</em>]| |
|	  |&#124;|                                             |(<em>empty declaration</em>)|
|  <em>impspec</em>|→|( <em>import<sub>1</sub></em> , … , <em>import<sub>n</sub></em> [ , ] )|(<em>n</em> ≥ 0)|
|	  |&#124;|`hiding` ( <em>import<sub>1</sub></em> , … , <em>import<sub>n</sub></em> [ , ] )|(<em>n</em> ≥ 0)|
| | | | |
|   <em>import</em>|→|<em>var</em>| |
|	  |&#124;| <em>tycon</em> [ `(..)` &#124; ( <em>cname<sub>1</sub></em> , … , <em>cname<sub>n</sub></em> )]|(<em>n</em> ≥ 0)|
|	  |&#124;|	<em>tycls</em> [`(..)` &#124; ( <em>var<sub>1</sub></em> , … , <em>var<sub>n</sub></em> )]|(<em>n</em> ≥ 0)|
|    <em>cname</em>|→|<em>var</em> &#124; <em>con</em> | |

モジュールによってエクスポートされたエンティティはモジュールのはじめの`import`宣言を伴って他のモジュールのスコープの中へもたらされる。
`import`宣言はインポートされるモジュールの名前をつけ、任意でインポートされるエンティティを明示する。
単一モジュールは一つ以上の`import`宣言によってインポートされるかもしれない。
インポートされた名前はトップレベルの宣言のように扱い、
そしてそのモジュールの全実体上が有効範囲であるが、ローカルのトップレベルではない束縛によって覆われる。

複数の`import`宣言の効果は厳密に累積し、
もしモジュール内の`import`宣言のいずれかでインポートされるなら、エンティティはスコープ内にある。
インポート宣言の順序は無意味である。

語彙的に、終端期号`"as"`や`"qualified"`、`"hiding"`はそれぞれ<em>reservedid</em>ではなく<em>varid</em>である。
それらは`import`宣言の文脈内でのみ特別な意味を持ち、変数のようにも使われることが出来る。

### インポートされるとは何か

正確にどのエンティティがインポートされるかは次に3つの方法の一つで明示されることが出来る。

1. インポートされるエンティティは丸括弧の中のリスト化しているものによってはっきりと明示されることが出来る。
    そのリストの中のアイテムは修飾子が許可されないことと`module <em>modid</em>`エンティティが許可されないことを除いてエクスポートリスト内のものと同様に同じ形式を持つ。
    インポートの形式`(..)`が型またはクラスで使われるとき、`(..)`はモジュールからエクスポートされるコンストラクタまたはメソッド、フィールド名の全てを参照する。

    そのリストはインポートされるモジュールによってエクスポートされるエンティティのみに名前をつけないといけない。
    リストは空でもよく、その場合はインスタンス以外はインポートされない。

2. エンティティは形式`hiding`(<em>inport<sub>1</sub>, ..., import<sub>n</sub></em>)を使うことによって除外されることができる。
   そして名前がつけられたモジュールによってエクスポートされる全エンティティはリスト内で名前を付けられたものを除いてインポートされるべきことを明示する。
   データコンストラクタは関連する型で接頭辞をつけられることなく隠れているリスト内で直接名前をつけることが出来る。
   例えば、

   ```hs
   import M hiding (C)
   ```

   `C`と名前を付けられるあらゆるコンストラクタまたはクラス、型は除外される。
   対象的にインポートリスト内で`C`を使うことはクラスまたは型のみに名前をつける。

   インポートされたモジュールによって実際にエクスポートされないエンティティを隠すことはエラーである。

3. 最後にもし<em>impspec</em>は省かれるなら、そのとき明示されたモジュールによってエクスポートされるエンティティはインポートされる。
   
### 修飾されるインポート

セクション[5.3.1](#インポートされるとは何か)のルールの下で各エンティティのために、トップレベルの環境は拡張される。
もしインポート宣言が`qualified`キーワードを使っていたなら、エンティティの**修飾された名前**のみがスコープ内へともたらされる。
もし`qualified`キーワードが省略されているなら、そのときエンティティの修飾される名前 **と** 修飾されない名前の **両者**はスコープの中へともたらされる。
セクション[5.5.1]()では修飾される名前のより詳細を述べていく。

インポートされる名前の修飾子はインポートされるモジュールの名前か`import`文の`as`句に与えられるローカルな別名のどちらかである。
このゆえに、**修飾子はエンティティが最初に宣言される中でモジュールの名前を必要としない。**

修飾されない名前を除外するための機能は修飾されない名前空間のプログラマによる完全な制御を許し、
ローカルで定義されたエンティティは修飾されるインポートのように同じ名前を共有可能である。

```hs
module Ring where  
import qualified Prelude    -- All Prelude names must be qualified  
import Data.List( nub )  

l1 + l2 = l1 Prelude.++ l2  -- This + differs from the one in the Prelude  
l1 ⋆ l2 = nub (l1 + l2)     -- This ⋆ differs from the one in the Prelude  

succ = (Prelude.+ 1)
```

### ローカルな別名

インポートされるモジュールは`as`句を使いインポートするモジュールの中でローカルな別名を割り当てられることができる。
例えば、次の

```hs
import qualified VeryLongModuleName as C
```

エンティティの中は<code>`VeryLongModuleName.`</code>の代わりの修飾子と同様に使用する<code>`C.`</code>を参照されないといけない。
これはインポートされるモジュールで使われる修飾子を変更せずに異なるモジュールを`VeryLongModuleName`の代わりにされることも許す。
それは同じ修飾子を使用するスコープ内の一つ以上のモジュールにとって正当であり、
全ての名前が明白にまだ解決されることが可能であることに提供される。
例えば、

```hs
module M where  
    import qualified Foo as A  
    import qualified Baz as A  
    x = A.f 
```

このモジュールは`Foo`と`Baz`が両方共`f`をエクスポートしないときのみに正当に提供される。

`as`句は`qualifiedimport`ではない式でも使われることができる。

```hs
import Foo as A(f)
```

この宣言は`f`と`A.f`をスコープの中にもたらす。

### 例

上記のインポートルールを明らかにするため、`x`と`y`をエクスポートするモジュール`A`を想定してほしい。
そのときこの表は名前が明記されたインポート式によってスコープの中へもたらされることを示す。

|インポート宣言|スコープの中にもたらされる名前|
|--|--|
|import A                       | x, y, A.x, A.y |
|import A()                     | (nothing) |
|import A(x)                    |	x, A.x |
|import qualified A             | A.x, A.y | 
|import qualified A()           | (nothing) |
|import qualified A(x)          | A.x |
|import A hiding ()             | x, y, A.x, A.y |
|import A hiding (x)            | y, A.y |
|import qualified A hiding ()   | A.x, A.y |
|import qualified A hiding (x)  | A.y | 
|import A as B                  | x, y, B.x, B.y |
|import A as B(x)               | x, B.x | 
|import qualified A as B        | B.x, B.y |

全てのケースで、モジュール`A`のスコープの中の全インスタンス宣言はインポートされる(セクション[5.4]())。

